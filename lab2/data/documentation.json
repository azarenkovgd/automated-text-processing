[
    {
        "name": "Adding-defaults-to-your-bot.md",
        "description": "## Introduction\nAs of version 12.4, PTB supports passing default values for arguments such as `parse_mode` to reduce the need for repetition. For this purpose, the [Defaults](https://python-telegram-bot.readthedocs.io/telegram.ext.defaults.html) class was introduced. This makes it possible to set defaults for often used arguments. These are set at the creation of the bot and are _immutable_.\n\n## What can be set to a default\n* `parse_mode`\n* `disable_notification`\n* `disable_web_page_preview`\n* `allow_sending_without_reply`\n* `do_quote`\n* `tzinfo`\n* `block`\n* `protect_content`\n* `link_preview_options`\n\n## Example\nHere is a show case for setting `parse_mode` to `ParseMode.HTML` and `tzinfo` to `pytz.timezone('Europe/Berlin')` by default:\n\n```python\nimport logging\n\nimport pytz\nimport datetime as dtm\n\nfrom telegram.constants import ParseMode\nfrom telegram.ext import MessageHandler, filters, Defaults, Application\n\nlogging.basicConfig(\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO\n)\n\n\nasync def job(context):\n    chat_id = context.job.chat_id\n    timezone = context.bot.defaults.tzinfo\n    local_now = dtm.datetime.now(timezone)\n    utc_now = dtm.datetime.utcnow()\n    text = f'Running job at {local_now} in timezone {timezone}, which equals {utc_now} UTC.'\n    await context.bot.send_message(chat_id=chat_id, text=text)\n\n\nasync def echo(update, context):\n    text = update.message.text\n    # Send with default parse mode\n    await update.message.reply_text(f'<b>{text}</b>')\n    # Override default parse mode locally\n    await update.message.reply_text(f'*{text}*', parse_mode=ParseMode.MARKDOWN)\n    # Send with no parse mode\n    await update.message.reply_text(f'*{text}*', parse_mode=None)\n\n    # Schedule job\n    context.job_queue.run_once(\n        job, dtm.datetime.now() + dtm.timedelta(seconds=1), chat_id=update.effective_chat.id\n    )\n\n\ndef main():\n    \"\"\"Instantiate a Defaults object\"\"\"\n    defaults = Defaults(parse_mode=ParseMode.HTML, tzinfo=pytz.timezone('Europe/Berlin'))\n\n    application = (\n        Application.builder()\n        .token(\"TOKEN\")\n        .defaults(defaults)\n        .build()\n    )\n\n    # on non command text message - echo the message on Telegram\n    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, echo))\n\n    # Start the Bot\n    application.run_polling()\n\n\nif __name__ == '__main__':\n    main()\n\n```"
    },
    {
        "name": "Arbitrary-callback_data.md",
        "description": "# Arbitrary objects as `InlineKeyboardButton.callback_data`\n\nThe Telegrams Bot API only accepts strings with length up to 64 bytes as `callback_data` for `InlineKeyboardButtons`, which sometimes is quite a limitation.\n\nWith PTB, you are able to pass *any* object as `callback_data`. This is achieved by storing the object in a cache and passing a unique identifier for that object to Telegram. When a `CallbackQuery` is received, the id in the `callback_data` is replaced with the stored object. To use this feature, set [`Application.arbitrary_callback_data`](https://docs.python-telegram-bot.org/telegram.ext.applicationbuilder.html#telegram.ext.ApplicationBuilder.arbitrary_callback_data) to `True`. The cache that holds the stored data has limited size (more details on memory usage below). If the cache is full and objects from a new `InlineKeyboardMarkup` need to be stored, it will discard the data for the least recently used keyboard.\n\nThis means two things for you:\n\n1. If you don't use [persistence](../wiki/Making-your-bot-persistent), buttons won't work after restarting your bot, as the stored updates are lost. More precisely, the `callback_data` you will receive is an instance of  `telegram.ext.InvalidCallbackData`. If you don't need persistence otherwise, you can set `store_callback_data` to `True` and all the others to `False`.\n2. If you have a number of keyboards that need to stay valid for a very long time, you might need to do some tweaking manually (see below)\n3. When using the `CallbackQueryHandler`, the `pattern` argument can now be either\n\n    * a regex expression, which will be used, if the `callback_data` is in fact a string\n    * a callable accepting the `callback_data` as only argument. You can perform any kinds of tests on the `callback_data` and return `True` or `False` accordingly\n    * a type. In that case the `CallbackQuery` will be handled, if the `callback_data` is an instance of that type. Btw: This allows you to inform users, when a buttons' data has been dropped from cache. With `CallbackQueryHandler(callback, pattern=InvalidCallbackData)` you can e.g., call `await update.callback_query.answer(text='Button is no longer valid', show_alert=True)` to inform the user.\n\n> [!Note]\n> You can of course also manually implement the idea of storing the object in a cache and passing a unique identifier for that object to Telegram, e.g. with the help of PTB [[storing data functionality|Storing-bot,-user-and-chat-related-data]]. PTBs built-in \"Arbitrary `callback_data`\" provides this mechanism in a way that requires minimal additional implementation effort on your end and that ties in well with the overall PTB framework.\n\n## Memory Usage\n\nPTB stores the callback data objects in memory. Additionally, to that, it stores a mapping of `CallbackQuery.id` to the corresponding UUID. By default, both storages contain a maximum number of 1024 items. You can change the size by passing an integer to the `arbitrary_callback_data` argument of `ApplicationBuilder`/`ExtBot`.\n\nAs PTB can't know when the stored data is no longer needed, it uses an LRU (Least Recently Used) cache. This means that when the cache is full, it will drop the keyboard that has been not used for the longest time. However, if you want to keep memory usage low, you have \nadditional options to drop data:\n\n* on receiving a `CallbackQuery`, you can call `context.drop_callback_data(callback_query)`. This will delete the data associated with the keyboard attached to the message that originated the `CallbackQuery`. Calling `context.drop_callback_data` is safe in any case where you change the keyboard, i.e. `callback_query.edit_message_text/reply_markup/…`\n  **Note:** If the user clicks a button more than one time fast enough, but you call `context.drop_callback_data` for the first resulting `CallbackQuery`, the second one will have `InvalidCallbackData` as `callback_data`. However, this is usually not a problem, because one only wants one button click anyway.\n* To drop more data from memory, you can call `bot.callback_data_cache.clear_callback_queries()` or `bot.callback_data_cache.clear_callback_data()`, which will drop the mapping of `CallbackQuery` ids to the associated UUID and the mapping of UUIDs to data, respectively. `clear_callback_data` also accepts a `time_cutoff`, allowing you to delete only entries older than a specified time.\n\n## Security of InlineKeyboardButtons\n\nCallback updates are not sent by Telegram, but by the client. This means that they can be manipulated by a user. (While Telegram unofficially does try to prevent this, they don't want Bot devs to rely on them doing the security checks).\n\nMost of the time, this is not really a problem, since `callback_data` often just is `Yes`, `No`, etc. However, if the callback data is something like `delete message_id 123`, the malicious user could delete any message sent by the bot.\n\nWhen using `arbitrary_callback_data` as described above, PTB replaces the outgoing `callback_data` with a [UUID](https://docs.python.org/3/library/uuid.html), i.e., a random unique identifier. This makes the `callback_data` safe: If a malicious client alters the sent `CallbackQuery`, the invalid UUID can't be resolved. In this case `CallbackQuery.data` will be an instance of `telegram.ext.InvalidCallbackData`. Note that this is also the case, when the UUID *was* valid, but the data has already been dropped from cache - PTB can't distinguish between the two cases.\n\n## Manually handling updates\n\nYou may be manually building your updates from JSON-data, e.g., in case you are using a custom webhooks setup. In this case you'll have to make sure that the cached data is inserted back into the buttons yourself, like this:\n\n```python\nupdate = Update.de_json(data, bot)\nif bot.arbitrary_callback_data:\n    bot.insert_callback_data(update)\n```\n\n## Special note about channel posts\n\nInline buttons are not only sent, your bot also receives them. In the return value of your bot message, when receiving messages that are replies to messages with an inline keyboard, have `message.pinned_message` or where `message.via_bot` is your bot (i.e., messages sent via your bot in inline mode). PTB tries very hard to insert the corresponding data back into all those keyboards, where appropriate - i.e., where the keyboard was sent by __your__ bot and not by another bot. There is however one case, where there is no way to tell that: channel posts have no `from_user`. So unless they have the `via_bot` attribute, there is no way to tell, if they were sent by your bot or another one. This means:\n\nIf your bot receives a channel post, which as `reply_to_message` or `pinned_message` and the latter has a keyboard, but was __not__ sent by your bot, all `callback_data` will contain `InvalidCallbackData` instances. This is of course unfortunate, but we do have a feeling that the cases where this would complicate things are so rare that it doesn't really matter 😉 "
    },
    {
        "name": "Architecture.md",
        "description": "# Architecture\n\nThe `telegram` and `telegram.ext` packages contain several classes that make writing (chat)bots easy.\nYou have met most of them in the [[tutorial|Extensions---Your-first-Bot]].\nBecause all of that can be a bit overwhelming, the below diagram gives you an overview of how the different components interact with each other.\n\n```mermaid\nflowchart TD;\n    AppBuilder(\"\n        ext.ApplicationBuilder\n        builder pattern for\n        ext.Application\n    \");\n    App(\"\n        ext.Application\n        \n        • entry point for the whole application</li>\n        • provides convenience methods for running the whole app via run_polling/webhook()</li>\n        • administers handlers and error handlers</li>\n        • administers user/chat/bot_data</li>\n    \");\n    BaseHandler(\"\n        ext.BaseHandler\n        specifies if and how\n        it handles updates\n    \");\n\n    BaseRequest(\"\n        request.BaseRequest\n        interface for handling the\n        networking backend\n    \");\n    BasePersistence(\"\n        ext.BasePersistence\n        interface for persisting\n        data from ext.Application\n        across restarts\n    \");\n    BaseUpdateProcessor(\"\n        ext.BaseUpdateProcessor\n        interface for processing\n        updates concurrently\n    \");\n    Bot(\"\n        (ext.Ext)Bot\n        Telegram Bot API client\n        used to make requests\n        to the API\n    \");\n    CallbackContext(\"\n        ext.CallbackContext\n        Convenience class for unified\n        access to different objects within\n        handler/job/error callbacks\n    \");\n        BaseRateLimiter(\"\n        ext.BaseRateLimiter\n        interface for rate limiting\n        API requests\n    \");\n        Defaults(\"\n        ext.Defaults\n        gathers default values for frequently\n        used parameters of (ext.Ext)Bot,\n        Ext.JobQueue and ext.BaseHandler\n    \");\n    CallbackDataCache(\"\n        ext.CallbackDataCache\n        in-memory LRU-cache for\n        arbitrary callback_data\n    \");\n    ContextTypes(\"\n        ext.ContextTypes\n        specifies types of\n        the context argument\n    \");\n\n    JobQueue(\"\n        ext.JobQueue\n        schedules tasks to run\n        at specific times\n    \");\n    Updater(\"\n        ext.Updater\n        fetches updates from Telegram\n        and puts them into the update_queue\n    \");\n    \n    AppBuilder -- builds --> App;\n    App -- accesses to build context --> ContextTypes;\n    App -- \"provides arguments for<br>handler callbacks, processes exceptions<br>raised in handler callbacks\" --> BaseHandler;\n    App -- processes exceptions<br>raised in jobs --> JobQueue;\n    App -- fetches data<br>and passes it to<br>ext.BasePersistence --> CallbackDataCache;\n    App -- fetches updates from<br>the update_queue --> Updater;\n    App -- updates in<br>regular intervals --> BasePersistence;\n    App -- gets default values<br>for parameters --> Defaults;\n    App -- dispatches updates --> BaseUpdateProcessor;\n    BaseUpdateProcessor -- processes updates<br>in specified<br>concurrency scheme--> BaseHandler;\n    ContextTypes -- specifies types --> CallbackContext;\n    BasePersistence -- holds a reference --> Bot;\n    BaseRateLimiter -- rate limits requests<br>to the API --> BaseRequest;\n    Bot -- dispatches requests<br>to the API --> BaseRateLimiter;\n        Bot -- stores arbitrary<br>callback_data --> CallbackDataCache;\n    Bot -- gets default values<br>for parameters --> Defaults;\n    JobQueue -- accesses to<br>build context --> ContextTypes;\n    Updater -- calls get_updates<br>& set/delete_webhook --> Bot;\n   \n```\n\n---\n\n`python-telegram-bot` is designed such that you can adjust it to many use cases.\nIn particular, many components/features are optional and some can even be fully customized.\nMoreover, the design allows the library to be used alongside other `asyncio` frameworks in the same Python script. We have a dedicated section on this in the [over here](../wiki/Frequently-requested-design-patterns#running-ptb-alongside-other-asyncio-frameworks).\n\n## Fetching updates\n\nThe `Updater` class is there to fetch updates from the Bot API for your bot.\nBut you don't need to use it.\nIf you want to implement a custom mechanism to fetch updates (e.g. a [[custom webhook setup|Webhooks]], you can just put your updates into the `Application.update_queue` or even manually call `Application.process_update`.\nTo build an `Application` that doesn't use an `Updater`, simply pass `None` to `ApplicationBuilder.updater`.\n\n## Concurrent update processing\n\nBy default, the `Application` handles updates sequentially, i.e. one by one.\nHowever, you can also process updates concurrently, i.e. multiple updates at the same time.\nIt is also possible to customize which updates should be processed concurrently and which should be processed sequentially by providing a custom implementation of the `BaseUpdateProcessor` interface class.\nPlease have a look at [[this wiki page|Concurrency]] for more info.\n\n## Scheduling tasks\n\nThe `JobQueue` class integrates scheduling logic into the setup of `telegram.ext`.\nThis feature is optional.\nIf you don't need/want to use a `JobQueue`, simply pass `None` to `ApplicationBuilder.job_queue`.\n\n## Arbitrary `callback_data`\n\nThe `CallbackDataCache` is the backend for caching arbitrary `callback_data`.\nThis feature must be explicitly activated to be used.\nPlease see [[this wiki page|Arbitrary-callback_data]] for more info.\n\n## Default values\n\nThe `Defaults` class allows you to specify default values for parameters that appear quite often, e.g. the `parse_mode` parameter.\nThis is an opt-in feature.\nPlease have a look at [[this wiki page|Adding-defaults-to-your-bot]] for more info.\n\n## Persisting data across restarts\n\nBy default, data like `Application.{chat, bot, user}_data` is stored in-memory and is lost when the bot shuts down.\nPTB includes an optional functionality to persist data across restarts, which has `BasePersistence` as interface class at it's core.\nHead to [[this page|Making-your-bot-persistent]] for more info.\n\n\n## Rate limiting\n\nBy default, all requests to the bot API, i.e. calling `Bot.send_message`, `Message.reply_text` or any other API method, are immediately forwarded to Telegram.\nSince Telegram imposes rate limits, this can lead to flood errors if you're making to many requests in a short time span.\nPTB includes an optional functionality to \"throttle\" the outgoing requests, which has `BaseRateLimiter` as interface class at it's core.\nHead to [[this page|Avoiding-flood-limits]] for more info.\n\n## Networking\n\nBy default, PTB will use the `httpx` library for the networking backend, i.e. making requests to the Bot API.\nHowever, you are free to use a custom backend implementation as well.\nFor this, you'll have to implement the `BaseRequest` interface class and pass two instances of your custom networking class to\n`ApplicationBuilder.request` and `ApplicationBuilder.get_updates_request`.\n\n## Update handlers\n\nThe `Handler` interface class is the most important class when it comes to the question of how the `Application` processes updates.\nPTB comes with a number of [[built-in handler|Types-of-Handlers]] which cover most important use cases.\nHowever, if you want to implement a custom logic of when an update should be handled, you can also write a custom implementation of `Handler` and use that.\n\n## Persistence\n\nAs mentioned above, PTBs persistence functionality is based on the interface class `BasePersistence`.\nTo use persistence in PTB, you use an implementation of this class.\nPTB comes already ships two implementations (see [[this page|Making-your-bot-persistent]]), but you are very welcome to implement a persistence class for your own serialization backend.\n\n## Customizing the `context` parameter\n\nThe class `CallbackContext` is a central part of the handler/job callbacks in PTB and more advanced users may want to add custom behavior to this class.\nYou can do so by passing an instance of the `ContextTypes` to `ApplicationBuilder.context_types`.\nHave a look at [this example](https://docs.python-telegram-bot.org/examples.html#examples-contexttypesbot) for example use cases."
    },
    {
        "name": "Ask-Right.md",
        "description": "# How to ask good technical questions\n\nWhen working with PTB, you will sooner or later have a question. And that's fine! You can only expand your knowledge by asking questions and getting answers.\nThis article is about *how to ask good questions*, focusing on questions appearing when working with PTB.\nBefore we begin, please try to keep one rule of thumb in mind:\n\n> You want something from somebody else, so please put some effort in it.\n\nPutting effort in it makes it easier for others to actually help you and it's more pleasant for both sides ;)\n\nErrors/questions can appear on a lot of different levels and need to be addressed differently. \n\n## General Python questions & Questions about other libraries\n\nWhen you're coding a bot, you will have to code a lot of stuff that doesn't actually have to do anything with PTB, i.e. the backend. \nMaybe you're also using other python libraries.\n\nPlease be aware that neither the PTBs user group on Telegram nor the issue tracker on PTBs GitHub repository are the right place to ask those questions.\n\n## Design Questions\n\nMany questions are not about how to use a specific method/class of PTB, but more along the lines \"If a users does this, I want my bot to react like that. What can I use for that?\".\nWhen asking how to build a specific functionality with PTB, please try to describe it precisely and include all relevant information. Answering the following questions usually is a good starting point:\n\n1. What kind of event should trigger the functionality? Possible triggers are e.g.\n    * User sends a message containing a command/specific expression/an image/…\n    * A new member joins the group\n    * A user presses an `InlineKeyboardButton`\n    * A specific time of the day\n    * Bot starts running\n2. What kind of chat is the functionality supposed to work in? A private chat with the bot? A group/supergroup? Or a channel?\n3. Is your Bot an Admin in that Chat?\n4. How do you want your bot to react?\n\n### A Bad Example:\n\n> How do I verify a user?\n\n### A Good Example:\n\n> When a new user enters a group, where my bot is an admin, I would like to verify that they are not spam bots by having them fill out some kind of captcha, preferably in the private chat with the bot. If the captcha is not filled out correctly within one day, they should be banned.\nI can already send a captcha message and also check if it was filled out correctly. What I can't figure out is how to catch users joining the group and how I can set up a delayed ban.\n\n## Questions on PTB\n\nYou have set up your bot - but something doesn't work. An update is not processed as you would expect it to be or you're encountering an error.\nAgain, please try to be precise and include all relevant information. This means:\n\n1. What would you expect to happen? Usually this includes\n  * What kind of update are you processing? Message, InlineQuery, CallbackQuery, …?\n  * What kind of handler did you set up to handle this? What is it supposed to do?\n2. What is actually happening?\n  * If you're encountering an exception, please provide the full [traceback](https://realpython.com/python-traceback/)\n  * Make sure that you activate [logging](https://github.com/python-telegram-bot/python-telegram-bot/#logging) or an [[error handler|Exceptions,-Warnings-and-Logging]] so that you can actually see the traceback!\n3. Where exactly are things going south? If you can locate the line/s of code that are misbehaving, please include them in your question.\n  \nIf you have a hard time laying your finger on where exactly things go south, it might be helpful to provide a [minimal working example](https://telegra.ph/Minimal-Working-Example-for-PTB-07-18).\n\n### A Bad Example:\n\n> The bot does not work and the messages do not connect to me.\n\n### A Good Example:\n\n> When using my bot in private it responds to all messages as expected. When I add it to a group, it doesn't, although I don't see any error messages in the log. How can I fix this?\n"
    },
    {
        "name": "Ask-Support.md",
        "description": "If you still have problems with *this* library, the preferred way to get help is to join the [official group chat on Telegram](https://t.me/pythontelegrambotgroup).\n\nAlternatively, you can also ask a question in the [Discussions section](https://github.com/python-telegram-bot/python-telegram-bot/discussions) on GitHub.\n\nFinally, there is also a `python-telegram-bot` tag on [StackOverflow](https://stackoverflow.com/questions/tagged/python-telegram-bot), though the development team of this library doesn't actively follow those questions."
    },
    {
        "name": "Avoiding-flood-limits.md",
        "description": "# Flood Limits & Why to Avoid Them\n\nConsidering [Telegram's Bot documentation](https://core.telegram.org/bots/faq#my-bot-is-hitting-limits-how-do-i-avoid-this), currently the maximum amount of messages being sent by bots is limited to ~30 messages/second for all ordinary messages and ~20 messages/minute for group messages.\nAccording to [@BotSupport](https://t.me/BotSupport) the limit for group also applies to channels (this is not confirmed by Telegram in their documentation however).\nWe emphasize that Telegram does *not* document the precise limits, neither for sending messages nor for other kinds of API requests.\nMoreover, the limits may differ between bots and also over time. \n\nWhen your bot hits spam limits, it starts to get `RetryAfter` errors from Telegram API.\nIf you want to make sure that the message is actually sent and hence just try again on every `RetryAfter` error, your code would spend a significant amount resources just on those retries.\nMoreover, constantly retrying to send messages while ignoring API errors could result in your bot being banned for some time.\n\nThat means, if you're making a production-ready bot that is expected to have a large number of users, it's a good idea to use throughput limiting mechanism for messages being sent/requests being made to the Bot API.\nThis way you can ensure that all messages would be delivered to end-users as soon as possible in ordered way.\n\n> [!Tip]\n> With [Bot API 7.1](https://core.telegram.org/bots/api-changelog#october-31-2024) ([PTB v27.1](https://docs.python-telegram-bot.org/en/v21.7/changelog.html#version-21-7)), Telegram introduced the parameter [`allow_paid_broadcast`](https://docs.python-telegram-bot.org/en/v21.7/telegram.bot.html#telegram.Bot.send_message.params.allow_paid_broadcast).\n> This allows bots to send up to 1000 messages per second by paying a fee in Telegram Stars.\n\n> [!Caution]\n> PTBs rate limiting mechanism doesn't take `allow_paid_broadcast` into account automatically.\n> If you want to use that parameter, make sure to implement the corresponding logic, so that the effect doesn't get lost.\n\n# PTBs Rate Limiting Mechanism\n\nSince v20 (v20.0a3, to be precise), PTB comes with a built-in mechanism to throttle the number of API requests that your bot makes per time interval.\nThis mechanism is exposed through the `telegram.ext.BaseRateLimiter` interface class.\nThis class has basically one important abstract coroutine method, called `BaseRateLimiter.process_request`.\nThis method is called every time when your bot makes an API request and it's purpose is to delay the request such that your bot doesn't hit the rate limits.\nAny implementation of `BaseRateLimiter` can implement its own logic on how this should be done.\nIf you observe a particular pattern in how your bot receives `RetryAfter` errors (e.g. messages to one particular group trigger `RetryAfter` errors quickly), you can implement a logic that addresses these specific patterns.\n\nThe `BaseRateLimiter` setup can be used only with `telegram.ext.ExtBot`, not with `telegram.Bot`.\nIt's easy to set up and use.\nAssume that `MyLimiter` implements `BaseRateLimiter`.\nThen we use like this:\n\n```python\nfrom telegram import Update\nfrom telegram.ext import ApplicationBuilder, ContextTypes, CommandHandler\n\napplication = ApplicationBuilder().token(\"TOKEN\").rate_limiter(MyLimiter()).build()\n\n\nasync def start(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    # This is automatically passed through `MyLimiter.process_request`!\n    await update.message.reply_text(text=\"Hello World!\")\n\n\napplication.add_handler(CommandHandler('start', start))\n```\n\nYou may also pass additional information to `MyLimiter.process_request`.\nImagine that you want to broadcast a message to all the users of your bot.\nYou might want to give those messages a lower priority, answering requests of your users should be faster.\nThis could look like this:\n\n```python\nimport asyncio\nfrom telegram import Update\nfrom telegram.ext import ApplicationBuilder, ContextTypes, CommandHandler\n\napplication = ApplicationBuilder().token(\"TOKEN\").rate_limiter(MyLimiter()).build()\nuser_ids = [1, 2, 3]\n\nasync def broadcast(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    await update.message.reply_text(text=\"Starting the broadcast...\")\n    context.application.create_task(\n        asyncio.gather(\n            *(\n                context.bot.send_message(\n                    chat_id=user_id, text=\"Hello World!\", rate_limit_args={'priority': -1}\n                )\n                for user_id in user_ids\n            )\n        )\n    )\n\n\napplication.add_handler(CommandHandler('broadcast', broadcast))\n```\n\nWhat kind of input is allowed for the `rate_limit_args` argument is up to the implementation of `BaseRateLimiter`.\n\n# Built-in Rate Limiter\n\nPTB comes with a built-in implementation of `BaseRatelimiter`: The class `telegram.ext.AIORateLimiter` uses the library [aiolimiter](https://aiolimiter.readthedocs.io/).\nPlease consult the documentation of `AIORateLimiter` for details on how it applies rate limits to API requests and how it should be used.\n\n⚠️  We emphasize that `AIORateLimiter` is to be understood as minimal effort reference implementation.\nIf you would like to handle rate limiting in a more sophisticated, fine-tuned way, we\nwelcome you to implement your own subclass of `telegram.ext.BaseRateLimiter`.\nFeel free to check out the [source code of `AIORateLimiter`](https://github.com/python-telegram-bot/python-telegram-bot/blob/master/telegram/ext/_aioratelimiter.py#L51) class for inspiration.\n\n"
    },
    {
        "name": "Bot-API-Forward-Compatibility.md",
        "description": "The `telegram` package contains PTBs Python implementation of the classes and methods defined in the [Bot API](https://core.telegram.org/bots/api).\nThis implementation is manually updated whenever Telegram releases a new version of the API.\nDue to the nature of this open-source library, the implementation work usually takes some time, depending on how much changed.\nHowever, users of PTB might want to immediately use the new functionality provided by Telegram.\nPTB therefore provides mechanism that make exactly this possible, i.e. accessing information from the Bot API that has no native PTB implementation yet.\nBelow, we will describe the mechanisms in detail.\n\n> [!Warning]\n> It is important to note that all these mechanism are intended to be used as temporary solutions only. \n> If you use these mechanisms in your code and then upgrade to a PTB version that adds native support for the new Bot API functionality, you'll have to adapt your code to use PTBs native interfaces instead.\n\n# Object Attributes\n\n## Receiving Objects\n\nTelegram sends data in the form of JSON objects either for updates that your bot receives or as return value of methods.\nWhen Telegram adds new attributes (\"fields\") to these objects that, the corresponding attributes in PTBs classes will be missing.\nHowever, any additional data that is not yet covered by the native Python attributes will be gathered in the [`TelegramObject.api_kwargs`](https://docs.python-telegram-bot.org/en/stable/telegram.telegramobject.html#telegram.TelegramObject.api_kwargs) attribute (note that `TelegramObject` is the base class of (almost) all other classes in the `telegram` package).\n\nFor example, imagine that Telegram adds a new field called `read_date` to the `Message` class. Then accessing `update.message.read_date` is possible only after PTB was updated, however accessing `update.message.api_kwargs[\"read_date\"]` would give the value provided by Telegram.\n\n> [!Important]\n> `TelegramObject.api_kwargs` will always contain the raw JSON data received from Telegram. For example, a date will be a simple unix timestamp instead of a timezone aware `datetime.datetime` object. These kinds of conversions are available only once PTB is updated to the new API version.\n\nAs another example, imagine that Telegram adds a new filed called `user_online_status_updated` to the `Update` class. Then accessing `update.user_online_status_updated` is again not immediately possible. Moreover, there is not yet a handler in `telegram.ext` to handle these new kinds of updates. However, in this case you can e.g. use [`TypeHandler`](https://docs.python-telegram-bot.org/en/stable/telegram.ext.typehandler.html) to catch these updates, like this\n\n```python\nfrom telegram import Update\nfrom telegram.ext import TypeHandler\n\nasync def callback(update, context):\n    if status_updated := update.api_kwargs.get(\"user_online_status_updated\"):\n        print(status_updated)\n\napplication.add_handler(TypeHandler(Update, callback))\n```\n\nOf course you can also implement your own subclass of [`BaseHandler`](https://docs.python-telegram-bot.org/en/stable/telegram.ext.basehandler.html) that checks for the presence of the key `user_online_status_updated` in `update.api_kwargs`. See also [[this page|Types-of-Handlers]].\n\n## Sending Objects\n\nThe Bot API also receives objects from you, namely as input arguments for the different Bot methods. For example, [`Bot.set_my_command`](https://docs.python-telegram-bot.org/en/stable/telegram.bot.html#telegram.Bot.set_my_commands) expects an array of [`BotCommand`](https://docs.python-telegram-bot.org/en/stable/telegram.botcommand.html#telegram.BotCommand) objects.\nIf Telegram adds new fields to objects that you send as input to Telegram, the corresponding arguments in PTBs classes will be missing.\nHowever, any additional data that is not yet covered by the native Python attributes can be passed via the argument [`api_kwargs`](https://docs.python-telegram-bot.org/en/stable/telegram.telegramobject.html#telegram.TelegramObject.params.api_kwargs) of `TelegramObject` (note that `TelegramObject` is the base class of (almost) all other classes in the `telegram` package).\n\nFor example, imagine that Telegram adds a new field called `emoji` to the `BotCommand` class such that this emoji is shown somewhere in the chat when the command is selected by the user. Then passing the argument via `BotCommand(\"command\", \"description\", emoji=\"💥\")` is possible only after PTB was updated. However, you can already do\n\n```python\nBotCommand(\"command\", \"description\", api_kwargs={\"emoji\": \"💥\"})\n```\n\nand PTB will pass the data along to Telegram.\n\n> [!Important]\n> The argument `api_kwargs` of `TelegramObject` has the same limitations as the argument `api_kwargs` of `Bot.do_api_request` - see [below](#new-methods).\n\n# Using Bot Methods\n\n## New Parameters\n\nAll bot methods have a number of parameters defined by Telegram.\nIf Telegram adds new parameters to methods that you can specify, the corresponding arguments in PTBs the methods of `telegram.Bot` (and the corresponding shortcuts) will be missing.\nHowever, any additional data that is not yet covered by the native Python arguments can be passed via the argument [`api_kwargs`](https://docs.python-telegram-bot.org/en/stable/telegram.bot.html#telegram.Bot.send_message.params.api_kwargs) of the respective method.\n\nFor example, imagine that Telegram adds a new parameter called `delete_after` to the `send_message` method such that the message is deleted automatically after the specified time. Then passing the argument via `await bot.send_message(chat_id=123, text=\"Hello!\", delete_after=42)` is possible only after PTB was updated. However, you can already do\n\n```python\nawait bot.send_message(chat_id=123, text=\"Hello!\", api_kwargs={\"delete_after\": 42})\n```\n\nand PTB will pass the data along to Telegram.\n\n> [!Important]\n> The argument `api_kwargs` of bot methods has the same limitations as the argument `api_kwargs` of `Bot.do_api_request` - see [below](#new-methods).\n\n## New Methods\n\nSometimes, Telegram adds entirely new methods to the API that you can use to trigger novel functionality.\nIf Telegram adds such a new method, the corresponding method of PTBs class `telegram.Bot` will be missing.\nHowever, PTB provides the method `Bot.do_api_request` that allows you to make any API call to Telegram.\n\nFor example, imagine that Telegram adds a new method called `get_message` allowing your bot to fetch information about a specific method. Then calling that method via `await bot.get_message(chat_id=123, message_id=456)` is possible only after PTB was updated. However, you can already do\n\n```python\nawait bot.do_api_request(\n    endpoint=\"get_message\",\n    api_kwargs={\"message_id\": 456, \"chat_id\": 123},\n    return_type=Message\n)\n```\n\nand PTB will call the corresponding Bot API method with the given parameters and return the result as a `Message` object.\n\n> [!Important]\n> The argument `api_kwargs` will always accept a dictionary with string keys. Note that the type of the values should in general be either \n>\n> * JSON serializable (e.g. `str`, `int`, `list`/`tuple` or `dict` is `str` keys) or\n> * a object of type `TelegramObject` (or a subclass) or\n> * a `datetime.datetime` object or\n> * an [`InputFile`](https://docs.python-telegram-bot.org/en/stable/telegram.inputfile.html) object\n> \n> Otherwise, PTB will not be able to correctly pass `api_kwargs` along to Telegram, or Telegram by not be able to parse the input.\n> For more details on the limitations of `api_kwargs`, see [here](https://docs.python-telegram-bot.org/en/stable/telegram.bot.html#telegram.Bot.do_api_request)."
    },
    {
        "name": "Bots-built-with-PTB.md",
        "description": "A non-exhaustive list of open-source bots built on `python-telegram-bot` in the wild. You are welcome to add your bot in alphabetical order. Please include a link to the source code and optionally a link to a running instance of that bot.\n\n# `Application` (v20+)\nBots built using the `telegram.ext.Application` class (>=v20):\n\n| Name | Description | PTB version | Year Updated | Try it Out | \n| --- | --- | --- | --- | --- |\n| [Akinator-Bot](https://github.com/codewarnab/akinatorbot) | Play guessing game Akinator on Telegram. | 20.6 | 2023 |  [Link](https://t.me/Akinatorq_bot) |\n| [ChatControlCenter](https://github.com/ChatControlCenter/chatcontrolcenter) | Open source bot to administer a telegram group with different functionalities and blacklist | 21.1.1 | 2024 | [Link](https://t.me/chatcontrolcenter_bot) | \n| [Eval Bot](https://github.com/shin-yue/eval-bot) | A simple bot to evaluates Python code asynchronously. | 21.6 | 2024 | [Link](https://t.me/runpytgbot) |\n| [PlaylistLinkExtractor](https://github.com/codewarnab/youtubePlaylistExtractorBot) | Extracts video links from a youtube  playlist  | 20.7 | 2023 |  [Link](https://t.me/PlaylistlinkextractorBot) |\n| [Engeybot](https://github.com/fauzaanu/engeybot) | A telegram bot that uses OPENAI Completions end point to give answers for questions along with a text to speech answer as audio file | 20.1 | 2023 | [@Engeybot](https://t.me/engeybot) |\n| [Feederbot](https://github.com/Dextroz/RSS_Feederbot) | A Telegram bot for reading RSS feeds. | 20.0a0 | 2022 | - |\n| [ForwardsCoverBot](https://github.com/91DarioDev/ForwardsCoverBot) | Echoes any message and any kind of media to anonymize the forward. | 20.0 | 2023 | [Link](https://t.me/forwardscoverbot) |\n| [GuardianVPN](https://github.com/mearashadowfax/GuardianVPN) | A Telegram bot that simplifies VPN configuration by providing users with configuration files on-demand | 20.1 | 2023 | [@GuardianVPNBot](https://t.me/GuardianVPNBot) |\n| [Instagram Assistant](https://github.com/rzashakeri/Instagram-Assistant) | Instagram Assistant on Telegram with download, upload and Lottery and Insights 💡 | 20.1 | 2023 | [Link](https://t.me/InstagramAssistantRobot) |\n| [kmua](https://github.com/krau/kmua-bot) | A bot with multiple group entertainment functions | 20.7 | 2024 | [@kmuav2bot](https://t.me/kmuav2bot) |\n| [jackett2telegram](https://github.com/danimart1991/jackett2telegram) | Jackett Indexers RSS Feed to Telegram Bot | 21.1 | 2024 | - |\n| [microw](https://github.com/sickmz/microw)  |A telegram bot designed to track expenses. | 21.1.1 | 2024 |  - |\n| [Rules Bot](https://github.com/python-telegram-bot/rules-bot) | A bot built by the PTB team that helps manage the PTB groups on Telegram | 20.2 | 2023 | [Link](https://t.me/roolsbot) |\n| [Shorts To Telegram](https://github.com/fauzaanu/Shorts_To_Telegram) | On receiving a YouTube Shorts Link this bot will send you back a telegram video | >=20.0a0 | 2022 | [Link](https://t.me/ShortsInTGBot) |\n| [Telegram Youtube DL](https://github.com/Kyryh/telegram-youtube-dl) | Bot that lets you download videos from Youtube and many other websites | 21.0 | 2024 | - |\n| [Tiktok To Telegram](https://github.com/fauzaanu/Tiktok_To_Telegram) | On receiving a tiktok link this bot will send you back a watermark removed video back | 20.0a4 | 2022 | [Link](https://t.me/TokInTgBot) |\n| [Torrent Telegram Bot](https://github.com/fauzaanu/torrent_telegram_bot) | A bot that generates direct links from torrent magnet links, along with searching torrents from a search query | Unknown | 2022 | - |\n| [Twitter Status Bot](https://github.com/Bibo-Joshi/twitter-status-bot) | A simple Telegram Bot that let’s you create stickers looking like Tweets on the fly. | 20.1 | 2023 | [Link](https://t.me/TwitterStatusBot) |\n\n\n# Web Apps (v20+)\nBots using Telegram Web Apps (>=v20):\n| Name | Description | PTB version | Year Updated | Try it Out | \n| --- | --- | --- | --- | --- |\n| [TGDates](https://github.com/harshil21/TGDates) | A Telegram Web App which allows the user to pick a date or time easily and is configurable via an API. | >20.0 | 2023 | - |\n\n\n# Raw API (v20+)\nBots using the raw API (>=v20). These bots either use the (deprecated) library `python-telegram-bot-raw` explicitly, or don't use the `telegram.ext` module at all:\n\n| Name | Description | PTB version | Year Updated | Try it Out | \n| --- | --- | --- | --- | --- |\n\n\n# `Updater` (v13-):\nBots built using the `telegram.ext.Updater` class (<=v20):\n\n| Name | Description | PTB version | Year Updated | Try it Out | \n| --- | --- | --- | --- | --- |\n| [AlarmBot](https://github.com/guysoft/AlarmBot) | This bot uses [crontab](https://en.wikipedia.org/wiki/Cron) to schedule audio alarms. The alarm command can be edited to schedule any kind of cron job for an IOT device. | >7.0.1 | 2019 | [Link](https://t.me/alarmbot)\n| [AmbroBot](https://github.com/Ambro17/AmbroBot) | This bot can search series or movies by name and lets you download them, it can also list latest yts movies, lets you set reminders, solve linear equations and a few other neat things | 11.0.0 | 2023 | [Link](https://t.me/CuervoBot) | \n| [aws-lambda-telegram-bot](https://github.com/aprezcuba24/aws-lambda-telegram-bot) | This repository is a base project to create telegram bots. In the project, you can create a bot using **AWS Lambda** and the data will be stored in **dynamodb** | 13.11 | 2022 | - |\n| [BibTeXBot](https://gitlab.com/-/snippets/2069000) | This bot can convert bibliography identifiers to BibTeX entries | 13.1 | 2021 | [Link](https://t.me/BibTexBot) |\n| [BlackJackBot](https://github.com/d-Rickyy-b/Python-BlackJackBot) | for a nice round of BlackJack - alone or in a group. | >13.5 | 2022 | [Link](https://t.me/blackjackbot) | \n| [BotAgainstHumanity](https://gitlab.com/OctoNezd/bot_against_humanity) | a clone of \"Cards Against Humanity\" for telegram | Unknown | 2019 | [Link](https://t.me/humanity_against_bot) | \n| [Botline](https://github.com/beothorn/botline) | A bot that can run command line commands, print documents and browse the file system using the inline keyboard. | Unknown | 2021 | - |\n| [BotListBot](https://github.com/JosXa/BotListBot) | Large project, maintains the [@BotList channel](https://t.me/botlist). Simplifies navigation, allows submitting and editing bots by the [@BotListChat community](https://t.me/botlistchat) community. | 10.1.0 | 2021 | [Link](https://t.me/botlistbot) | \n| [CatifyMyFaceBot](https://github.com/Gondolav/catify-my-face-bot) | A bot that replaces human faces with cats. | 12.8 | 2021 | [Link](https://t.me/CatifyMyFaceBot) | \n| [CMSysBot](https://github.com/oddworldng/cmsysbot-telegram) | A bot for managing computers on a local network in a centralized way, allowing to, for example, send and execute custom scripts to all the computers in parallel. | 11.1.0 | 2022 | - |\n| [Coronatracker](https://github.com/tmslads/Coronatracker) | This bot gives you coronavirus information for any country in the world! Includes beautiful graphs made in matplotlib. | >13.1 | 2021 | [Link](https://t.me/uaecoronabot) |\n| [CryptoCoinsInfoBot](https://github.com/lytves/crypto-coins-info-bot-v2) | This bot sends you actual prices of cryptocoins using info from CoinMarketCap and CryptoCompare APIs. | Unknown | 2020 | [Link](https://t.me/cryptocoinsinfobot) |\n| [CryptoKitty](https://github.com/xlanor/CryptoKitties) | Source code for a broadcast bot that scans [CryptoKitties](https://www.cryptokitties.co/) API and returns cats that match the input parameters | 8.0 | 2018 | [Link](https://t.me/cryptokittybot) |\n| [Cryptora](https://github.com/izanmubarak/Cryptora) | gets all kinds of cryptocurrency-related data, including up-to-the-minute information from CoinMarketCap for thousands of cryptocurrencies and the latest headlines from CoinDesk | 8.1.1 | 2020 | [Link](https://t.me/cryptorabot) |\n| [DCLavoroFvg](https://github.com/marcotessarotto/dclavorofvg-bot) | a telegram bot with a Django backoffice which provides users with information about job offers, events, courses; bot shares Django models with administrative web applications | Unknown | 2021 | - |\n| [DrinkMixerBot](https://github.com/jac08h/DrinkMixerBot) | find a drink by ingredients available | 11.1.0 | 2021 | [Link](https://t.me/drinkmixerbot) |\n| [EFB Telegram Master Channel](https://github.com/blueset/efb-telegram-master) | A master channel for EH Forwarder Bot: an extensible chat tunneling framework that gathers your IMs at one place. | 13.11 | 2022 | - |\n| [ETHdroidBot](https://github.com/lytves/ETHdroidBot) | A telegram bot to control the balance of Ethereum and ERC tokens on your wallets | Unknown | 2019 | [Link](https://t.me/ETHdroidBot) |\n| [EtherTokenMonitor](https://github.com/zzzzlzzzz/EtherTokenMonitor) | A telegram bot (and simple example usage library [jackfruit + python-telegram-bot](https://github.com/zzzzlzzzz/jackfruit)) to control balance of Ethereum Tokens on many wallets | >12.1.1 | 2020 | - |\n| [Event Info Bot](https://bitbucket.org/rgambra/event-info-bot/) | A bot for Telegram and Twitter that informs your subscribers about the date when an event is due. It can reply to subscriber queries not only by providing the event date but also by calculating the date and time difference between now and the event date (i.e. how many years, months, days, hours, minutes, or seconds are left). For Telegram, it uses CommandHandlers, not inline text. For Twitter, it detects those keywords in any tweet addressed to your bot account. It's designed mostly to run in the GAE platform, but the TG bot can also run on a generic server (either remote or in your local development environment) using webhooks. | 12.0.0b1 | 2021 | - |\n| [Friendship Quiz](https://github.com/alistvt/friendship-quiz-bot) | A friendship quiz bot trying to simulate friendsquiz.site/quiz website! It also has suggested some new ideas in developing Bots to make it like Django! | 11.1.0 | 2019 | - |\n| [GatekeeperRobot](https://github.com/Juhannuspukki/gatekeeper-bot) | Auto-silences everyone who joins a group and then uses a simple inline-keyboard captcha to ensure that the newly-joined user is not a spambot | 12.0.0b1 | 2021 | - |\n| [GIFMAKER](https://github.com/sjfbo/video-to-gif-telegram-bot) | This Telegram bot transforms your videos into GIFs! | Unknown | 2023 | - |\n| [GoIP Configurator](https://github.com/dangoriaynov/goip-configurator) | A specialised telegram bot and application to monitor and adjust the GoIP-1 VoIP gateway | Unknown | 2021 | - |\n| [Hera](https://github.com/xlanor/SIM-UoW-Timetable-bot) | A specialised telegram bot to scrape students' timetables from the SIMConnect portal. | 11.1.0 | 2019 | - |\n| [herokumeet](https://github.com/koteshrv/herokumeet) | A telegram bot that uses selenium to attend your google meet classes. It can be easily deployed to heroku or local machine. You can schedule all the classes and it will join automatically. It has some features like alert when someone called, auto respond when alert comes, joins and leaves the class according to the members count, reply and many more. For more details see features and usage. | 13.7 | 2021 | - |\n| [HomeworkHelp](https://github.com/leeweiminsg/homework-help-bot) | A telegram bot to facilitate communication between tutors and their students! | 12.0.0b1 | 2019 | - |\n| [Hey bot](https://github.com/HassanHeydariNasab/heybot) | I'm Hey and I repeat what I learn. You can teach me in Regex! | 13.4.1 | 2021 | [Link](https://t.me/hooybot) | \n| [italy_coviddata](https://github.com/MCilento93/italy_coviddata) | A telegram bot providing data, plots and news about COVID-19 diffusion in Italy. Fully-written with python-telegram-bot wrapper | 13.0 | 2022 | [Link](https://t.me/italycoviddataBot) | \n| [Library Genesis Bot](https://github.com/adenosinetp10/Library-Genesis-Bot) | Search for Books and Articles from Library Genesis within Telegram | 13.13 | 2023 | [Link](https://t.me/Lib_Genesis_bot) | \n| [Lugodev Example Bot](https://github.com/lugodev/lugodev-example-bot) | YouTube video series teaching how to make a Telegram bot in Spanish | 13.3 | 2021 | - | \n| [LogBot](https://github.com/apiad/logbot) | A simple bot that accepts messages through a REST API and redirects them to Telegram, with optional actionable buttons | 11.1.0 | 2021 | [Link](https://t.me/apiad_demo_logbot) | \n| [Marie](https://github.com/PaulSonOfLars/tgbot) | A sassy group administration bot, with some fun extra features | 11.1.0 | 2022 | - |\n| [MasterBot](https://github.com/GauthamramRavichandran/MasterBot)| A bot to control other bots in the server | 13.2 | 2023 | - |\n| [Matilda](https://github.com/xlanor/matilda) | A news scraping bot for Straits Times and ChannelNewsAsia. | Unknown | 2017 | - |\n| [Mau Mau bot](https://github.com/jh0ker/mau_mau_bot) | Allows you to play the popular card game UNO via inline queries | 13.11 | 2023 | [Link](https://t.me/unobot) |\n| [memes-reposter](https://github.com/vaniakosmos/memes-reposter) | Bot for automatic broadcasting content from different sources (such as reddit or imgur) into telegram channels. | 11.1.0 | 2020 | - |\n| [ML monitoring helper](https://github.com/snk4tr/ML-monitoring-helper) | Bot for convenient management of learning process on one or more remote machines. | Unknown | 2018 | - |\n| [moodify](https://github.com/samsontmr/moodify) | Takes your selfie and recommends a playlist for your mood. | 5.3.0 | 2017 | [Link](https://t.me/moodifybot) |\n| [Motivational Quotes Bot](https://github.com/SumitAgr/MotivationalQuotes-Bot) | A simple Telegram bot that generates a new motivational quote with a single command. | Unknown | 2019 | [Link](http://t.me/MotivationalQuotes_Bot) |\n| [Motivator bot](https://github.com/SabaunT/bot-motivator) | Telegram bot (with celery engine) that will motivate you to do something good or stop doing something bad. | 12.2.0 | 2021 | [Link](https://t.me/PersuaderBot) |\n| [MusicToolBot](https://github.com/amirhoseinsalimi/music-tool-bot) | A bot to edit, convert, and cut music files and MP3s. | 13.15 | 2023 | [Link](https://t.me/MusicToolBot) |\n| [MVC sample](https://github.com/mmdaz/mvc_model_bot_developing) | This is a great sample for bot developing using python-telegram-bot and based on MVC model. | 11.1.0 | 2020 | - | \n| [Natalia](https://github.com/Whalepool/Natalia) | An administrative assistant bot. Lots of useful commands and functions for helping admins moderate multiple groups with large users | Unknown | 2018 | - |\n| [Nebula](https://github.com/Squirrel-Network/nebula8) | Open source bot to administer a telegram group with different functionalities and blacklist | 13.14 | 2023 | - |\n| [Needs more JPEG Bot](https://github.com/zeroone2numeral2/nmjpeg-bot) | Lowers the quality of photos | Unknown | 2019 | [Link](https://t.me/nmjpegbot) |\n| [OpenCryptoBot](https://github.com/Endogen/OpenCryptoBot) | The Swiss Army knife for crypto-currencies | 11.1.0 | 2020 | [Link](https://t.me/opencryptobot) |\n| [Picture of The Day Bot](https://github.com/SumitAgr/PictureofTheDay-Bot) | A simple bot that retrieves NASA's Picture of the Day with a single command. | Unknown | 2020 | [Link](https://github.com/SumitAgr/PictureofTheDay-Bot) |\n| [Pokemon Go bot](https://github.com/eugenio412/PogomBOT) | Notifications for pogom scanner | 5.0.0 | 2016 | - |\n| [PriceBot](https://github.com/lytves/pricebot) | Bot for group chats to receive CoinmarketCap crypto prices | 12.0 | 2020 | [Link](https://t.me/iamcryptobot) |\n| [privibot](https://github.com/pawamoy/privibot) | A Python library to add a privilege/permission system to your Telegram bot. | 12.0.0b1 | 2020 | - |\n| [reactor](https://github.com/vanyakosmos/reactor) | like @like but with a dynamic number of buttons. Users can add their own reactions to messages, similarly to slack/discord reactions | 12.0.0b1 | 2020 | [Link](https://t.me/emojinator_bot) |\n| [RemindMeBot](https://github.com/dmakeienko/remind_me_bot) | create reminders, check it's statuses, update/delete them. | 11.1.0 | 2020 | [Link](https://t.me/how_to_find_name_for_bot) |\n| [RRemindersBot](https://github.com/Ambro17/RemindersBot) | Set reminders for your tasks. With support for custom timezones and smart date parsing. Never forget your tasks again | 12.3.0 | 2023 | [Link](https://t.me/RRemindersBot) | \n| [Sierra Death Generator](https://github.com/skhaz/telegram-sierradeathgenerator) | Generate images using https://deathgenerator.com/ | 11.1.0 | 2020 | [Link](https://t.me/deathgenerator_bot) |\n| [Simple Stock Bot](https://gitlab.com/simple-stock-bots/simple-telegram-stock-bot) | A simple bot for getting stock market information. | 13.5 | 2022 | [Link](https://t.me/SimpleStockBot) |\n| [Slovodel Bot](https://github.com/weiss-d/slovodel-bot) | Generates non-existent Russian words of different types. Another example of the MVC approach. | 13.1 | 2022 | [Link](http://t.me/slovodel_bot) |\n| [Smokey Bot](https://github.com/udit-001/smokey-bot) | A telegram bot that provides real-time worldwide air pollution data | 9.0.0 | 2020 | [Link](https://t.me/smokey_bot) |\n| [SphinxDocBot](https://gitlab.com/HirschHeissIch/sphinx-doc-bot/) | A Telegram bot that lets your search Sphinx based documentation. The instance at [@PythonDocBot](https://t.me/PythonDocBot) lets you search the docs of Python 3 | 13.4.1 | 2022 | [Link](https://t.me/PythonDocBot) |\n| [SplitwizeBot](https://github.com/krnbatra/SplitwiseTelegramBot)| A telegram bot for managing expenses in Splitwise application. | 12.7 | 2020 | [Link](https://t.me/SplitwizeBot) | \n| [Sticker thief](https://github.com/zeroone2numeral2/sticker-thief) | Let people create custom sticker packs from existing stickers | 13.14 | 2022 | [Link](https://t.me/stickersthiefbot) |\n| [Subscription bot](https://github.com/AlexLoushkin/TelegramSubscriptionBot) | Helps organize a subscription for a news web site | <12.0 | 2016 | - |\n| [sudobot](https://github.com/bvanrijn/sudobot) | Runs commands on your server and lets you easily share the output | Unknown | 2016 | - |\n| [SUMS MD 1400 Bot](https://github.com/AlirezaChinian/SUMS-1400-Telegram-Bot) | Official telegram bot of SUMS MD 1400 | Unknown | 2022 | - |\n| [SurfSpot Bot](https://github.com/ereid7/surfspot-bot-telegram) | Bot which retrieves the surf report for a given surf spot | Unknown | 2021 | - |\n| [teleGit Bot](https://github.com/HeavenH/teleGit) | A bot to list the GitHub repositories, show users information. | 5.0.0 | 2018 | - |\n| [TimeZone Bot](https://gist.github.com/guysoft/4f220fe407a9bff37e3feff9f60f83a7) | Lets you pick a timezone. This bot also uses a class for its design pattern. | Unknown | 2017 | - |\n| [Telegram Bot Terminator](https://github.com/thematrixdev/Telegram-Bot-Terminator) | Telegram CAPTCHA bot. Fight SPAM in Telegram groups. | Unknown | 2022 | [Link](https://t.me/bot_terminator_bot) | \n| [Telegram-Facebook-bot](https://github.com/MorenK1/telegram-facebook-bot) | a bot to load content from Facebok pages and send it to Telegram channels | Unknown | 2019 | - | \n| [Telegram-Kraken-Bot](https://github.com/Endogen/Telegram-Kraken-Bot) | Trade crypto-currencies on the Kraken marketplace | 9.0.0 | 2021 | - |\n| [TelegramSSH](https://github.com/wwilliamcook/TelegramSSH) | Enables virtual SSH on bot machine without port forwarding. | 12.1.1 | 2019 | - |\n| [thornode-telegram-bot](https://github.com/block42-blockchain-company/thornode-telegram-bot) | A telegram bot to monitor the status of THORNodes of the THORChain Blockchain. | 13.2 | 2021 | - | [Link](https://t.me/thornode_chaosnet_bot) |\n| [toptracksbot](https://github.com/pltnk/toptracksbot) | This bot fetches videos from YouTube for the top three tracks of a specified artist according to Last.fm overall charts. | 13.7 | 2022 | [Link](https://t.me/toptracksbot) |\n| [Travis CI Telegram Notification](https://github.com/vanyakosmos/travis-tg-notifier) | helps to setup notifications about builds. | 12.0.0b1 | 2020 | [Link](https://t.me/TravisCINotifierBot) |\n| [TwitterForwarderBot](https://github.com/franciscod/telegram-twitter-forwarder-bot) | Forwards you tweets from people that you have subscribed to. | 5.0.0 | 2021 | - | \n| [Twitter-lists-bot](https://github.com/lytves/twitter-lists-bot) | a bot to resend your twitter list notifications | Unknown | 2020 | - |\n| [Url-Shortener-Bot](https://github.com/paradox70/url-shortener-goo.gl) | Shortens any URL and reports the total number of clicks on shortened link. | Unknown | 2016 | [Link](http://t.me/shortenMyUrlBot) |\n| [UseTGxBot](https://github.com/SpEcHiDe/MyTelegramOrgRoBot) | scraps telegram.org and get the api id associated with a phone number. | 13.1 | 2021 | [Link](https://t.me/UseTGxBot) | \n| [Vocaloid Bot](https://github.com/bomjacob/VocaBot) | Uses data from VocaDB.net to find all your favourite Vocaloid songs, artists and albums. | 11.1.0 | 2018 | [Link](https://telegram.me/VocaDBBot) |\n| [VorpalRobot](https://github.com/Tronikart/VorpalRobot) | an inline dice rolling bot | Unknown | 2018 | [Link](https://t.me/VorpalRobot) |\n| [Watermaker-bot](https://github.com/alistvt/watermarker-bot) | A bot to watermark your files by your logo. | Unknown | 2022 | - |\n| [Word Bot](https://github.com/bluec/telegram-word-bot) | A simple Telegram bot that analyses a given word. | 13.11 | 2022 | - | \n| [WordArtBot](https://github.com/mrfelipenoronha/WordArtBot) | Generate WordArts in Telegram. | <12.8 | 2021 | [Link](https://t.me/bestWordArtBot) |\n| [XiaomiVacuumCleanerTelegramBot](https://github.com/Matze693/XiaomiVacuumCleanerTelegramBot) | A useful telegram bot to control Xiaomi Vacuum Cleaner V2. | Unknown | 2019 | - |\n| [YATAB](https://github.com/Nhoya/YATAB/) | Modular administration helper bot | Unknown | 2017 | - |\n| [YOURLS Bot](https://gitlab.com/HirschHeissIch/yourls-bot) | A Telegram bot that acts as GUI front end for the [YOURLS](https://yourls.org/) link shortener. You can host it for your own YOURLS instance. | 13.1 | 2021 | - |\n| [Youtrack-Time-Tracking-Bot](https://github.com/MgCoders/tt-bot) | Allows easy time tracking on youtrack issues. | Unknown | 2017 | - |\n\n# Web Apps (v20-)\nBots using Telegram Web Apps (<=v20):\n| Name | Description | PTB version | Year Updated | Try it Out | \n| --- | --- | --- | --- | --- |\n\n# Raw API (v13-)\nBots using the raw API (<=v20). These bots either use the (deprecated) library `python-telegram-bot-raw` explicitly, or don't use the `telegram.ext` module at all:\n\n| Name | Description | PTB version | Year Updated | Try it Out | \n| --- | --- | --- | --- | --- |\n| [BismillahBot](https://github.com/rahiel/BismillahBot) | Shows the Noble Qur'an in English, Audio, and Arabic. | Unknown | 2017 | [Link](https://telegram.me/BismillahBot) |\n| [DevOps Reaction Bot](https://github.com/leandrotoledo/gae-devops-reaction-telegram-bot) | Sends latest or random posts from [DevOps Reaction](http://devopsreactions.tumblr.com/). Running on [Google App Engine](https://cloud.google.com/appengine) (billing has to be enabled for full Socket API support). | Unknown | 2015 | - | \n| [OiWA](https://github.com/416d72/oiwa) | Normally you'd have to save a person's phone number in your contact list to be able to chat with them over WhatsApp, but sometimes you just want a one-time chat, You can send said phone number to this bot and receives a link that directly opens a new WhatsApp chat with that person. | 13.15 | 2023 | [Link](https://t.me/OiWA_bot)\n| [python-telegram-bot-GAE](https://github.com/FollonSaxBass/python-telegram-bot-GAE) | Little project to upload and run Telegram Bot on Google App Engine using python-telegram-bot library and webhooks | 5.0.0 | 2016 | - | \n| [Simple-Echo-Telegram-Bot](https://github.com/sooyhwang/Simple-Echo-Telegram-Bot) | Simple Python Telegram bot that echoes your input with Flask microframework, setWebhook method, and Google App Engine (optional). | >=2.5 | 2017 | - |\n\n\n---\nIs your open source bot also using `python-telegram-bot`? Then you may add it to the right section, but be sure to keep the names sorted alphabetically\n***\n\n***\n\n***\n\n***\n\n***\n\n***\n\n***\n\n***\n\n***\n"
    },
    {
        "name": "Builder-Pattern.md",
        "description": "# The Builder Pattern in `telegram.ext`\n\nIn this library, there are roughly four important components that make up everything:\n\n1. The `Updater` is responsible for fetching updates that Telegram sent to your bot\n2. The `Bot` provides high-level access to the methods of the Bot API\n3. The `BaseRequest` is responsible to handle the actual networking stuff, i.e. sending the requests to the Bot API\n4. The `Application` binds everything together and is responsible for handling the updates fetched by the `Updater`.\n\nIn addition to those four, there are several other components, which are not as significant for the structure of a `python-telegram-bot` program.\n\nAll of those components have different parameters. Some of them are optional. Some are required. Some are mutually exclusive.\nThat's a lot to take in and when coding your bot and setting this all up by yourself would be tiresome.\n\nThat's why `python-telegram-bot` makes an effort to make the setup easy with reasonable defaults.\nFor example, after running\n\n```python\nfrom telegram.ext import Application\napplication = Application.builder().token('TOKEN').build()\n```\n\nyou will automatically have\n\n* the `Updater` available as `application.updater`\n* the `Bot` available as `application.bot` or `application.updater.bot` (both are the same object)\n* a `BaseRequest` object initialized and ready to be used by the `application.bot`\n* several other components & sane default values set up. \n\nBut what if you want to customize some arguments that `Application`, `Updater`, `Bot`, `BaseRequest` or other components accept? Do you have to build all those objects yourself and glue them together? No! (Well, you can, but you don't have to.)\n\nThis is where the [builder pattern](https://en.wikipedia.org/wiki/Builder_pattern) comes into play. The idea is roughly as follows: You went shopping and have all the ingredients for a nice stew, but you don't want to cook yourself. So you hand everything to a chef. The chef will tell you that some of your ingredients don't match and will discard them. Afterwards, he'll cook a nice stew for you and you never need to worry about how exactly that's done.\n\nLet's get a bit more technical. First, we need the cook:\n\n```python\nfrom telegram.ext import Application\nbuilder = Application.builder()\n```\n\nNow, we hand over the ingredients:\n\n```python\nbuilder.token(token)  # the bot token is the main ingredient\nbuilder.context_types(context_types)  # In case you want to use custom context types for your `Application`\nbuilder.read_timeout(read_timeout)  # In case you want to fine tune the networking backend\n...\n```\n\nFinally, we have the chef cook the stew:\n\n```python\napplication = builder.build()\n```\n\nAll this can also be chained into a single line:\n\n```python\nfrom telegram.ext import Application\napplication = Application.builder().token(token).context_types(context_types).read_timeout(read_timeout).build()\n```\n\nAnd that's already it!\n\nThe docs of [`ApplicationBuilder`](https://python-telegram-bot.readthedocs.io/telegram.ext.applicationbuilder.html) have all the info about which \"ingredients\" it can handle, i.e. which methods it has. Each method will tell you\n\n* how the parameters will be used (e.g. the token passed to `ApplicationBuilder.token` will be used for the `Bot` available as `Application.bot`)\n* What happens if you don't call this method. For most things, PTB will use reasonable defaults.\n"
    },
    {
        "name": "Code-snippets.md",
        "description": "This page can be read on its own to find the code snippet you need right now. \n\nIt is also a follow-up to the page [[Introduction to the API|Introduction-to-the-API]]. If you come from there, you can leave your command line open and just try out a few of these snippets.\n\n- [Pure API](#pure-api)\n    + [Fetch updates](#fetch-updates)\n    + [Fetch images sent to your Bot](#fetch-images-sent-to-your-bot)\n    + [Reply to messages](#reply-to-messages)\n- [General code snippets](#general-code-snippets)\n    + [Post a text message](#post-a-text-message)\n    + [Reply to a message](#reply-to-a-message)\n    + [Send a chat action](#send-a-chat-action)\n    + [Requesting location and contact from user](#requesting-location-and-contact-from-user)\n  * [Message Formatting (bold, italic, code, ...)](#message-formatting-bold-italic-code-)\n    + [Post a text message with Markdown formatting](#post-a-text-message-with-markdown-formatting)\n    + [Post a text message with HTML formatting](#post-a-text-message-with-html-formatting)\n    + [Message entities](#message-entities)\n    + [Telegram formatting to BBCode](#telegram-formatting-to-bbcode)\n  * [Keyboard Menus](#keyboard-menus)\n    + [Custom Keyboards](#custom-keyboards)\n    + [Remove a custom keyboard](#remove-a-custom-keyboard)\n  * [Other useful stuff](#other-useful-stuff)\n    + [Generate flag emojis from country codes](#generate-flag-emojis-from-country-codes)\n    + [Map a Slot Machine Dice value to the corresponding symbols](#map-a-slot-machine-dice-value-to-the-corresponding-symbols)\n    + [Get the new members group message](#get-the-new-members-message)\n    + [Exclude forwarded channel posts in discussion groups from MessageHandlers](#exclude-forwarded-channel-posts-in-discussion-groups-from-messagehandlers)\n    + [Exclude messages from anonymous admins](#exclude-messages-from-anonymous-admins)\n- [Advanced snippets](#advanced-snippets)\n    + [Register a function as a command handler (decorator)](#register-a-function-as-a-command-handler-decorator)\n      - [Usage](#usage)\n    + [Restrict access to a handler (decorator)](#restrict-access-to-a-handler-decorator)\n      - [Usage](#usage-1)\n    + [Send action while handling command (decorator)](#send-action-while-handling-command-decorator)\n      - [Usage](#usage-2)\n    + [Build a menu with Buttons](#build-a-menu-with-buttons)\n      - [Usage](#usage-3)\n    + [Telegram web login widget](#verify-data-from-telegram-web-login-widget)\n    + [Simple way of restarting the bot](#simple-way-of-restarting-the-bot)\n\n## Pure API\n\n#### Fetch updates\nTo fetch messages sent to your Bot, you can use the [getUpdates](https://core.telegram.org/bots/api#getupdates) API method.\n\n**Note:** You don't have to use `get_updates` if you are writing your bot with the `telegram.ext` submodule, since `telegram.ext.Updater` takes care of fetching all updates for you. Read more about that [[here|Extensions---Your-first-Bot]].\n\n```python\nupdates = await bot.get_updates()\nprint([u.message.text for u in updates])\n```\n\n---\n#### Fetch images sent to your Bot\n\n```python\nupdates = await bot.get_updates()\nprint([u.message.photo for u in updates if u.message.photo])\n```\n\n---\n#### Reply to messages\nYou'll always need the `chat_id`\n\n```python\nchat_id = (await bot.get_updates())[-1].message.chat_id\n```\n\n---\n## General code snippets\nThese snippets usually apply to both ways of fetching updates. If you're using `telegram.ext`, you can get the `chat_id` in your handler callback with `update.message.chat_id`.\n\n**Note:** In general, you can send messages to users by passing their user id as the `chat_id`. \nIf the bot has a chat with the user, it will send the message to that chat.\n\n---\n#### Post a text message\n[ᵀᴱᴸᴱᴳᴿᴬᴹ](https://core.telegram.org/bots/api#sendmessage)\n\n```python\nawait bot.send_message(chat_id=chat_id, text=\"I'm sorry Dave I'm afraid I can't do that.\")\n```\n\n**Note:** `send_message` method (as any of `send_*` methods of `Bot` class) returns the instance of `Message` class, so it can be used in code later.\n\n---\n#### Reply to a message\n\nThis is a shortcut to `bot.send_message` with same defaults. Read more about it [in the docs](https://docs.python-telegram-bot.org/telegram.message.html#telegram.Message.reply_text). \n\n```python\nawait update.message.reply_text(\"I'm sorry Dave I'm afraid I can't do that.\")\n```\n\n**Note:** There are equivalents of this method for replying with photos, audio etc., and similar shortcuts exist throughout the library.\n\n---\n#### Send a chat action\n[ᵀᴱᴸᴱᴳᴿᴬᴹ](https://core.telegram.org/bots/api#sendchataction)\nUse this to tell the user that something is happening on the bot's side:\n\n```python\nawait bot.send_chat_action(chat_id=chat_id, action=telegram.constants.ChatAction.TYPING)\n```\nAlternatively, if you have several commands and don't want to repeat the above code snippet inside all commands see [this wiki section](#send-action-while-handling-command-decorator) on how to do that.\n\n---\n#### Requesting location and contact from user\n\n```python\nlocation_keyboard = telegram.KeyboardButton(text=\"send_location\", request_location=True)\ncontact_keyboard = telegram.KeyboardButton(text=\"send_contact\", request_contact=True)\ncustom_keyboard = [[ location_keyboard, contact_keyboard ]]\nreply_markup = telegram.ReplyKeyboardMarkup(custom_keyboard)\nawait bot.send_message(chat_id=chat_id, \n...                  text=\"Would you mind sharing your location and contact with me?\", \n...                  reply_markup=reply_markup)\n```\n\nTo catch the incoming message with the location/contact, use `MessageHandler` with `filters.LOCATION` and `filters.CONTACT`, respectively.\n\n---\n### Message Formatting (bold, italic, code, ...)\n\nTelegram supports some formatting options for text. All the details about what is supported can be found [here](https://core.telegram.org/bots/api#formatting-options). Please keep in mind that you will have to escape the special characters as detailed in the documentation. PTB also offers a [helper function](https://docs.python-telegram-bot.org/telegram.helpers.html#telegram.helpers.escape_markdown) for escaping of Markdown text. For escaping of HTML text, you can use [`html.escape`](https://docs.python.org/3/library/html.html?#html.escape) from the standard library.\n\nYou can format text with every API method/type that has a `parse_mode` parameter. In addition to editing your text as described in the link above, pass one of the parse modes available through [`telegram.constants.ParseMode`](https://python-telegram-bot.readthedocs.io/telegram.constants.html#telegram.constants.ParseMode) to the `parse_mode` parameter. Since the `5.0` update of the Bot API (version `13.1+` of PTB), you can alternatively pass a list of [`telegram.MessageEntities`](https://python-telegram-bot.readthedocs.io/telegram.messageentity.html) to the `entities` parameter.\n\n*Note:* In the API 4.5 update, Telegram introduced MarkdownV2, which supports nested entities and needs other escaping than v1. Markdown V1 is referred as legacy mode by the official API docs, and you should prefer MarkdownV2. Make sure to also use `reply_markdown_v2` instead of `reply_markdown` etc.\n\n#### Post a text message with Markdown formatting\n[ᵀᴱᴸᴱᴳᴿᴬᴹ](https://core.telegram.org/bots/api#sendmessage)\n\n```python\nawait bot.send_message(chat_id=chat_id, \n                 text=\"*bold* _italic_ `fixed width font` [link](http://google.com)\\.\", \n                 parse_mode=telegram.constants.ParseMode.MARKDOWN_V2)\n```\n\n---\n#### Post a text message with HTML formatting\n[ᵀᴱᴸᴱᴳᴿᴬᴹ](https://core.telegram.org/bots/api#sendmessage)\n\n```python\nawait bot.send_message(chat_id=chat_id, \n                 text='<b>bold</b> <i>italic</i> <a href=\"http://google.com\">link</a>.', \n                 parse_mode=telegram.constants.ParseMode.HTML)\n```\n\n---\n#### Message entities\n[ᵀᴱᴸᴱᴳᴿᴬᴹ](https://core.telegram.org/bots/api#messageentity)\nTo use `MessageEntity`, extract the entities and their respective text from a `Message` object using [`parse_entities`](https://python-telegram-bot.readthedocs.io/telegram.message.html#telegram.Message.parse_entities).  \n\n**Note:** This method should always be used instead of the ``entities`` attribute, since it calculates the correct substring from the message text based on UTF-16 codepoints - that is, it extracts the correct string even on when working with weird characters such as Emojis.\n\nConsider this example which checks for presence of URLs in a message and prints them on screen.\n\n```python\n# A dictionary that maps entity to text\nentities = message.parse_entities()\nfor ent in entities:\n    txt = entities[ent]\n    if ent.type == ent.TEXT_LINK:\n        # Text with embedded URL  \n        print(f\"{txt} - {ent.url}\")\n    elif ent.type == ent.URL:\n        # Plain URL\n        print(txt)\n```\nFor more narrowed use cases like extracting only Telegram message links, you might be better using [ptbcontrib/extract_urls](https://github.com/python-telegram-bot/ptbcontrib/tree/main/ptbcontrib/extract_urls).\n\n---\n#### Telegram formatting to BBCode\nThis is an example how to use entities to convert Telegram formatting to BBCode. In the current version it does *not* support nested entities.\n\nDefine parsing function:\n\n<details><summary>Click to expand</summary><p>\n\n```python\nimport sys\n\ndef parse_bbcode(message_text, entities, urled=False):\n    \"\"\"BBCode parsing function\"\"\"\n    if message_text is None:\n        return None\n\n    if not sys.maxunicode == 0xffff:\n        message_text = message_text.encode('utf-16-le')\n\n    bbcode_text = ''\n    last_offset = 0\n\n    for entity, text in sorted(entities.items(), key=(lambda item: item[0].offset)):\n\n        if entity.type == 'text_link':\n            insert = '[url={}]{}[/url]'.format(entity.url, text)\n        elif entity.type == 'mention':\n            insert = '[url=https://t.me/{0}]{1}[/url]'.format(text.strip('@'),text)\n        elif entity.type == 'url' and urled:\n            insert = '[url={0}]{0}[/url]'.format(text)\n        elif entity.type == 'bold':\n            insert = '[b]' + text + '[/b]'\n        elif entity.type == 'italic':\n            insert = '[i]' + text + '[/i]'\n        elif entity.type == 'underline':\n            insert = '[u]' + text + '[/u]'\n        elif entity.type == 'strikethrough':\n            insert = '[s]' + text + '[/s]'\n        elif entity.type == 'code':\n            insert = '[code]' + text + '[/code]'\n        elif entity.type == 'pre':\n            insert = '[pre]' + text + '[/pre]'\n        else:\n            insert = text\n        if sys.maxunicode == 0xffff:\n            bbcode_text += message_text[last_offset:entity.offset] + insert\n        else:\n            bbcode_text += message_text[last_offset * 2:entity.offset * 2].decode('utf-16-le') + insert\n\n        last_offset = entity.offset + entity.length\n\n    if sys.maxunicode == 0xffff:\n        bbcode_text += message_text[last_offset:]\n    else:\n        bbcode_text += message_text[last_offset * 2:].decode('utf-16-le')\n    return bbcode_text\n\n```\n\n</p></details>\n\n\nCall it with:\n```python\nentities = update.message.parse_entities()\nbbcode = parse_bbcode(update.message.text, entities, urled=True)\n```\n\n...or for photo captions:\n```python\nentities = update.message.parse_caption_entities()\nbbcode = parse_bbcode(caption, entities, urled=True)\n```\n`bbcode` will contain message/caption text formatted in BBCode. `urled` parameter determines if URLs in text are to be processed as links or left as text.\n\n---\n### Keyboard Menus\n\n#### Custom Keyboards\n[ᵀᴱᴸᴱᴳᴿᴬᴹ](https://core.telegram.org/bots#keyboards)\n\n```python\ncustom_keyboard = [['top-left', 'top-right'], \n                   ['bottom-left', 'bottom-right']]\nreply_markup = telegram.ReplyKeyboardMarkup(custom_keyboard)\nawait bot.send_message(\n    chat_id=chat_id, \n    text=\"Custom Keyboard Test\", \n    reply_markup=reply_markup\n)\n```\n\nSee also: [Build a menu with Buttons](#build-a-menu-with-buttons)\n\n\n---\n#### Remove a custom keyboard\n\n```python\nreply_markup = telegram.ReplyKeyboardRemove()\nawait bot.send_message(\n    chat_id=chat_id, text=\"I'm back.\", reply_markup=reply_markup\n)\n```\n\n---\n### Other useful stuff\n\n#### Generate flag emojis from country codes\n\nThe Unicode flag emoji for any country can by definition be calculated from the countries [2 letter country code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). The following snippet only works in Python 3.\n\n```python\nOFFSET = 127462 - ord('A')\n\ndef flag(code):\n    code = code.upper()\n    return chr(ord(code[0]) + OFFSET) + chr(ord(code[1]) + OFFSET)\n\n>>> flag('un')\n'🇺🇳'\n>>> flag('eu')\n'🇪🇺'\n```\n\n---\n#### Map a Slot Machine Dice value to the corresponding symbols\n\nThe 🎰 dice can take the values 1-64. Here is a dictionary that maps each value to the unique combination of symbols that produce that value:\n\n(Source: This [Gist](https://gist.github.com/Chase22/300bad79154ffd5d8fbf0aedd5ddc4d4) by [@Chase22](https://github.com/Chase22))\n\n<details><summary>Click to expand</summary><p>\n\n```python\nslot_machine_value = {\n    1: (\"bar\", \"bar\", \"bar\"),\n    2: (\"grape\", \"bar\", \"bar\"),\n    3: (\"lemon\", \"bar\", \"bar\"),\n    4: (\"seven\", \"bar\", \"bar\"),\n    5: (\"bar\", \"grape\", \"bar\"),\n    6: (\"grape\", \"grape\", \"bar\"),\n    7: (\"lemon\", \"grape\", \"bar\"),\n    8: (\"seven\", \"grape\", \"bar\"),\n    9: (\"bar\", \"lemon\", \"bar\"),\n    10: (\"grape\", \"lemon\", \"bar\"),\n    11: (\"lemon\", \"lemon\", \"bar\"),\n    12: (\"seven\", \"lemon\", \"bar\"),\n    13: (\"bar\", \"seven\", \"bar\"),\n    14: (\"grape\", \"seven\", \"bar\"),\n    15: (\"lemon\", \"seven\", \"bar\"),\n    16: (\"seven\", \"seven\", \"bar\"),\n    17: (\"bar\", \"bar\", \"grape\"),\n    18: (\"grape\", \"bar\", \"grape\"),\n    19: (\"lemon\", \"bar\", \"grape\"),\n    20: (\"seven\", \"bar\", \"grape\"),\n    21: (\"bar\", \"grape\", \"grape\"),\n    22: (\"grape\", \"grape\", \"grape\"),\n    23: (\"lemon\", \"grape\", \"grape\"),\n    24: (\"seven\", \"grape\", \"grape\"),\n    25: (\"bar\", \"lemon\", \"grape\"),\n    26: (\"grape\", \"lemon\", \"grape\"),\n    27: (\"lemon\", \"lemon\", \"grape\"),\n    28: (\"seven\", \"lemon\", \"grape\"),\n    29: (\"bar\", \"seven\", \"grape\"),\n    30: (\"grape\", \"seven\", \"grape\"),\n    31: (\"lemon\", \"seven\", \"grape\"),\n    32: (\"seven\", \"seven\", \"grape\"),\n    33: (\"bar\", \"bar\", \"lemon\"),\n    34: (\"grape\", \"bar\", \"lemon\"),\n    35: (\"lemon\", \"bar\", \"lemon\"),\n    36: (\"seven\", \"bar\", \"lemon\"),\n    37: (\"bar\", \"grape\", \"lemon\"),\n    38: (\"grape\", \"grape\", \"lemon\"),\n    39: (\"lemon\", \"grape\", \"lemon\"),\n    40: (\"seven\", \"grape\", \"lemon\"),\n    41: (\"bar\", \"lemon\", \"lemon\"),\n    42: (\"grape\", \"lemon\", \"lemon\"),\n    43: (\"lemon\", \"lemon\", \"lemon\"),\n    44: (\"seven\", \"lemon\", \"lemon\"),\n    45: (\"bar\", \"seven\", \"lemon\"),\n    46: (\"grape\", \"seven\", \"lemon\"),\n    47: (\"lemon\", \"seven\", \"lemon\"),\n    48: (\"seven\", \"seven\", \"lemon\"),\n    49: (\"bar\", \"bar\", \"seven\"),\n    50: (\"grape\", \"bar\", \"seven\"),\n    51: (\"lemon\", \"bar\", \"seven\"),\n    52: (\"seven\", \"bar\", \"seven\"),\n    53: (\"bar\", \"grape\", \"seven\"),\n    54: (\"grape\", \"grape\", \"seven\"),\n    55: (\"lemon\", \"grape\", \"seven\"),\n    56: (\"seven\", \"grape\", \"seven\"),\n    57: (\"bar\", \"lemon\", \"seven\"),\n    58: (\"grape\", \"lemon\", \"seven\"),\n    59: (\"lemon\", \"lemon\", \"seven\"),\n    60: (\"seven\", \"lemon\", \"seven\"),\n    61: (\"bar\", \"seven\", \"seven\"),\n    62: (\"grape\", \"seven\", \"seven\"),\n    63: (\"lemon\", \"seven\", \"seven\"),\n    64: (\"seven\", \"seven\", \"seven\"),\n}\n```\n\n</p></details>\n\n---\n#### Get the new members message\n```python\nimport asyncio\n\nfrom telegram import Update\nfrom telegram.ext import ContextTypes\n\nasync def add_group(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    await asyncio.gather(\n        update.message.reply_text(f\"{member.full_name} just joined the group\")\n        for member in update.message.new_chat_members\n    )\n\nadd_group_handle = MessageHandler(filters.StatusUpdate.NEW_CHAT_MEMBERS, add_group)\napplication.add_handler(add_group_handle)\n```\nNote that service messages about non-bot users joining the chat are removed from large groups. You can get the new members message by following the [chatmemberbot.py example](https://github.com/python-telegram-bot/python-telegram-bot/tree/master/examples#chatmemberbotpy).\n\n---\n#### Exclude forwarded channel posts in discussion groups from MessageHandlers\t\nIf you're using `MessageHandlers` and do not want them to respond to the channel posts automatically forwarded to the discussion group linked to your channel, you can use this filter in your `MessageHandler` (requires PTB v13.9+):\n```python\t\n~ filters.IS_AUTOMATIC_FORWARD \n```\n\n---\n#### Exclude Messages from anonymous Admins\t\nIf you're using `MessageHandlers` and do not want them to respond to messages from anonymous admins, you can use this filter in your `MessageHandler`:\n```python\t\n~ filters.SenderChat.SUPER_GROUP\n```\n\n---\n## Advanced snippets\n\n#### Register a function as a command handler (decorator)\n\nThis decorator allows you to register a function as a command handler in a _Flask_ like manner.\n\n```python\ndef command_handler(command):\n    def decorator(func):\n        handler = CommandHandler(command, func)\n        application.add_handler(handler)\n        return func\n    return decorator\n```\n\n##### Usage\n\nAdd the `@command_handler(command)` decorator on top of your handler function:\n\n```python\n@command_handler(\"hello\")\nasync def hello(update, context):\n    await context.bot.send_message(chat_id=update.effective_chat.id, text=\"Hello world!\")\n```\n\n**Note**: You can modify this decorator in order to register any type of handler (see [[Types Of Handlers|Types-Of-Handlers]]). Please also note that PTB deliberately does not provide such functionality out of the box due to the reasons mentioned in [#899](https://github.com/python-telegram-bot/python-telegram-bot/issues/899).\n\n---\n#### Restrict access to a handler (decorator)\n\nThis decorator allows you to restrict the access of a handler to only the `user_ids` specified in `LIST_OF_ADMINS`.\n\n```python\nfrom functools import wraps\n\nLIST_OF_ADMINS = [12345678, 87654321]\n\ndef restricted(func):\n    @wraps(func)\n    async def wrapped(update, context, *args, **kwargs):\n        user_id = update.effective_user.id\n        if user_id not in LIST_OF_ADMINS:\n            print(f\"Unauthorized access denied for {user_id}.\")\n            return\n        return await func(update, context, *args, **kwargs)\n    return wrapped\n```\n\n##### Usage\n\nAdd a `@restricted` decorator on top of your handler declaration:\n\n```python\n@restricted\nasync def my_handler(update, context):\n    pass  # only accessible if `user_id` is in `LIST_OF_ADMINS`.\n```\n\n---\n#### Send action while handling command (decorator)\nThis parametrized decorator allows you to signal different actions depending on the type of response of your bot. This way users will have similar feedback from your bot as they would from a real human. \n```python\nfrom functools import wraps\n\ndef send_action(action):\n    \"\"\"Sends `action` while processing func command.\"\"\"\n\n    def decorator(func):\n        @wraps(func)\n        async def command_func(update, context, *args, **kwargs):\n            await context.bot.send_chat_action(chat_id=update.effective_message.chat_id, action=action)\n            return await func(update, context,  *args, **kwargs)\n        return command_func\n    \n    return decorator\n```\n\n##### Usage\n![Result](https://i.imgur.com/ErBKSS4.png)\n\nYou can decorate handler callbacks directly with `@send_action(ChatAction.<Action>)` or create aliases and decorate with them (more readable) .\n```python\nsend_typing_action = send_action(ChatAction.TYPING)\nsend_upload_video_action = send_action(ChatAction.UPLOAD_VIDEO)\nsend_upload_photo_action = send_action(ChatAction.UPLOAD_PHOTO)\n```\nWith the above aliases, the following decorators are equivalent\n```python\n@send_typing_action\nasync def my_handler(update, context):\n    pass  # user will see 'typing' while your bot is handling the request.\n    \n@send_action(ChatAction.TYPING)\nasync def my_handler(update, context):\n    pass  # user will see 'typing' while your bot is handling the request.\n```\nAll possible actions are documented [here](https://core.telegram.org/bots/api#sendchataction).\n\n---\n#### Build a menu with Buttons\n\nOften times you will find yourself in need for a menu with dynamic content. Use the following `build_menu` method to create a button layout with `n_cols` columns out of a list of `buttons`.\n\n```python\nfrom typing import Union, List\nfrom telegram import InlineKeyboardButton\n\ndef build_menu(\n    buttons: List[InlineKeyboardButton],\n    n_cols: int,\n    header_buttons: Union[InlineKeyboardButton, List[InlineKeyboardButton]]=None,\n    footer_buttons: Union[InlineKeyboardButton, List[InlineKeyboardButton]]=None\n) -> List[List[InlineKeyboardButton]]:\n    menu = [buttons[i:i + n_cols] for i in range(0, len(buttons), n_cols)]\n    if header_buttons:\n        menu.insert(0, header_buttons if isinstance(header_buttons, list) else [header_buttons])\n    if footer_buttons:\n        menu.append(footer_buttons if isinstance(footer_buttons, list) else [footer_buttons])\n    return menu\n```\n\nYou can use the `header_buttons` and `footer_buttons` lists to put buttons in the first or last row respectively.\n\n##### Usage\n\n![Output](http://i.imgur.com/susvvR7.png)\n\nReplace the `...` in below snippet by an appropriate argument, as indicated in the [InlineKeyboardButton documentation](https:/docs.python-telegram-bot.org/telegram.inlinekeyboardbutton.html). If you want to use `KeyboardButtons`, use `ReplyKeyboardMarkup` instead of `InlineKeyboardMarkup`.\n\n```python\nbutton_list = [\n    InlineKeyboardButton(\"col1\", callback_data=...),\n    InlineKeyboardButton(\"col2\", callback_data=...),\n    InlineKeyboardButton(\"row 2\", callback_data=...)\n]\nreply_markup = InlineKeyboardMarkup(util.build_menu(button_list, n_cols=2))\nawait bot.send_message(..., \"A two-column menu\", reply_markup=reply_markup)\n```\n\nOr, if you need a dynamic version, use list comprehension to generate your `button_list` dynamically from a list of strings:\n\n```python\nsome_strings = [\"col1\", \"col2\", \"row2\"]\nbutton_list = [[KeyboardButton(s)] for s in some_strings]\n```\n\nThis is especially useful if put inside a helper method like `get_data_buttons` to work on dynamic data and updating the menu according to user input.\n\nTo handle the `callback_data`, you need to set a `CallbackQueryHandler`.\n\n---\n#### Verify data from [Telegram Web Login Widget](https://core.telegram.org/widgets/login). \n\nWhen using a [`LoginUrl`](https://core.telegram.org/bots/api#loginurl) in an [`InlineKeyboardButton`](https://core.telegram.org/bots/api#inlinekeyboardbutton) to authorize a user on your website via Telegram, you'll have to to check the hash of the received data to verify the data of the integrity as described [here](https://core.telegram.org/widgets/login#checking-authorization)\n\nThe data JSON data will have the following form:\n```python\n{\n    \"id\": XXXXXXXXX\n    \"first_name\": \"XXX\"\n    \"last_name\": \"XXX\"\n    \"username\": \"XXXXX\"\n    \"photo_url\": \"https://t.meXXXXXX.jpg\"\n    \"auth_date\": XXXXXXXXXX\n    \"hash\": \"XXXXXXXXXXXXXXXXXXXXXX.....\"\n}\n ```    \nThe following is an example implementation in Python:\n\n<details><summary>Click to expand</summary><p>\n\n```python\nimport hashlib\nimport hmac\n\nBOT_TOKEN = 'YOUR BOT TOKEN'\n\ndef verify(request_data):\n    request_data = request_data.copy()\n    tg_hash = request_data['hash']\n    request_data.pop('hash', None)\n    request_data_alphabetical_order = sorted(request_data.items(), key=lambda x: x[0])\n\n    data_check_string = []\n    for data_pair in request_data_alphabetical_order:\n        key, value = data_pair[0], data_pair[1]\n        data_check_string.append(f\"{key}={value}\")\n    data_check_string = '\\n'.join(data_check_string)\n\n    secret_key = hashlib.sha256(BOT_TOKEN.encode()).digest()\n    received_hash = hmac.new(secret_key, msg=data_check_string.encode(), digestmod=hashlib.sha256).hexdigest()\n\n    if received_hash == tg_hash:\n        # The user clicked to the Auth Button and data is verified.\n        print('User Logged in.')\n        return True\n    else:\n        # The data is not valid\n        print('User data mis-matched.')\n        return False\n\n    # Optionally use another if-else block to check the auth_date in order to prevent outdated data from being verified.\n```\n\n</p></details>\n\nA sample of Flask app can be found [here.](https://gist.github.com/jainamoswal/279e5259a5c24f37cd44ea446c373ac4)\n\n---\n#### Simple way of restarting the bot\n\nThe following example allows you to restart the bot from within a handler.\nIt goes without saying that you should protect this method from access by unauthorized users - see [[here|Frequently-requested-design-patterns#how-do-i-limit-who-can-use-my-bot]] for some tips on this.\nThe main magic consists of calling [`Application.stop_running`](https://docs.python-telegram-bot.org/en/stable/telegram.ext.application.html#telegram.ext.Application.stop_running) from within a handler callback to allow for a graceful shutdown.\nActually restarting the python script can then be achieved by different means.\n\n<details><summary>Click to expand</summary><p>\n\n```python\nimport os\nimport sys\n\nfrom telegram import Update\nfrom telegram.ext import ContextTypes, Application, CommandHandler\n\n\nasync def restart(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    context.bot_data[\"restart\"] = True\n    context.application.stop_running()\n\n\ndef main() -> None:\n    application = Application.builder().token(\"TOKEN\").build()\n    application.bot_data[\"restart\"] = False\n    application.add_handler(CommandHandler(\"restart\", restart))\n    application.run_polling(allowed_updates=Update.ALL_TYPES)\n\n    if application.bot_data[\"restart\"]:\n        os.execl(sys.executable, sys.executable, *sys.argv)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n</p></details>"
    },
    {
        "name": "Concurrency.md",
        "description": "# Concurrency in PTB\n\n## Table of contents\n\n- [Default behavior](#default-behavior)\n- [Using concurrency](#using-concurrency)\n  - [`Handler.block`](#handlerblock)\n  - [`Application.concurrent_updates`](#applicationconcurrent_updates)\n  - [`Application.create_task`](#applicationcreate_task)\n- [Tailor-made Concurrency](#tailor-made-concurrency)\n\n> ⚠️ Please make sure to read this page in its entirety and in particular the section on [tailor-made concurrency](#tailor-made-concurrency)\n\nPTB is built on top of Python's [`asyncio`](https://docs.python.org/3/library/asyncio.html), which allows writing concurrent code using the `async`/`await` syntax.\nThis greatly helps to design code that efficiently uses the wait time during I/O operations like network communication (e.g. sending a message to a user) or reading/writing on the hard drive.\n\n**Note:**\n`asyncio` code is usually single-threaded and hence PTB currently does not aim to be thread safe (see the readme for more info.)\n\n## Default behavior\n\nBy default, incoming updates and handler callbacks are processed sequentially, i.e. one after the other.\nSo, if one callback function takes some time to execute, all other updates have to wait for it.\n\n**Example:**\nYou're running the [Echobot](https://github.com/python-telegram-bot/python-telegram-bot/blob/master/examples/echobot.py) and two users (*User A* and *User B*) send a message to the bot at the same time.\nMaybe *User A* was a bit quicker, so their request arrives first, in the form of an `Update` object (*Update A*).\nThe `Application` checks the `Update` and decides it should be handled by the handler with the callback function named `echo`.\nAt the same time, the `Update` of *User B* arrives (*Update B*).\nBut the `Application` is not finished with *Update A*.\nIt calls the `echo` function with *Update A*, which sends a reply to *User A*. Sending a reply takes some time, and *Update B* remains untouched during that time.\nOnly after the `echo` function finishes for *Update A*, the `Application` repeats the same process for *Update B*.\n\nIf you have handlers in multiple groups, it gets a tiny bit more complicated.\nThe following pseudocode explains how `Application.process_update` roughly works in the default case, i.e. sequential processing (we simplified a bit by e.g. skipping some arguments of the involved methods):\n\n```python\nasync def process_update(self, update):\n    # self is the `Application` instance\n    for group_number, handlers in self.handlers.items():\n        # `handlers` is the list of handlers in group `group_number`\n        for handler in handlers:\n            if handler.check_update(update):\n                # Here we `await`, i.e. we only continue after the callback is done!\n                await handler.handle_update(update)\n                break  # at most one handler per group handles the update\n```\n\n## Using concurrency\n\nWe want to reply to both *User A* and *User B* as fast as possible and while sending the reply to user *User A* we'd like to already get started on handling *Update B*.\nPTB comes with three built-in mechanisms that can help with that.\n\n### `Handler.block`\n\nVia the `block` parameter of `Handler` you can specify that `Application.process_update` should not wait for the callback to finish:\n\n```python\napplication.add_handler(\n  MessageHandler(filters.TEXT & ~filters.COMMAND, echo, block=False)\n)\n```\n\nInstead, it will run the callback as [`asyncio.Task`](https://docs.python.org/3/library/asyncio-task.html#asyncio.Task) via [`asyncio.create_task`](https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task).\nNow, when the `Application` determined that the `echo` function should handle *Update A*, it creates a new task from `echo(Update A)`.\nImmediately after that, it calls `Application.process_update(Update B)` and repeats the process for *Update B* without any further delay.\nBoth replies are sent **concurrently**.\n\nAgain, let's have a look at pseudocode:\n\n```python\nasync def process_update(self, update):\n    # self is the `Application` instance\n    for group_number, handlers in self.handlers.items():\n        # `handlers` is the list of handlers in group `group_number`\n        for handler in handlers:\n            if handler.check_update(update):\n                # Here we *don't* `await`, such that the loop immediately continues\n                asyncio.create_task(handler.handle_update(update))\n                break  # at most one handler per group handles the update\n```\n\nThis already helps for many use cases.\nHowever, by using `block=False` in a handler, you can no longer rely on handlers in different groups being called one after the other.\nDepending on your use case, this can be an issue.\nHence, PTB comes with a second option.\n\n### `Application.concurrent_updates`\n\nInstead of running single handlers in a non-blocking way, we can tell the `Application` to run the whole call of `Application.process_update` concurrently:\n\n```python\nApplication.builder().token('TOKEN').concurrent_updates(True).build()\n```\n\nNow the `Application` will start `Application.process_update(Update A)` via `asyncio.create_task` and immediately afterwards do the same with *Update B*.\nAgain, pseudocode:\n\n```python\nwhile not application.update_queue.empty():\n  update = await application.update_queue.get()\n  asyncio.create_task(application.process_update(update))\n```\nThis setting is *independent* of the `block` parameter of `Handler` and within `application.process_update` concurrency still works as explained above.\n\nYou can further customize concurrent handling `Application.process_update` also implement your own custom update processor by subclassing the [`BaseUpdateProcessor`](https://docs.python-telegram-bot.org/telegram.ext.baseupdateprocessor.html) interface class. Let's have a look at an example:\n```python\nclass MyUpdateProcessor(BaseUpdateProcessor):\n    async def do_process_update(self, update, coroutine) -> None:\n        # This method is called for every update\n        if update.callback_query:\n            await asyncio.sleep(5)\n        await coroutine\n\n    async def initialize(self) -> None:\n      pass\n\n    async def shutdown(self) -> None:\n      pass\n\nApplication.builder().token('TOKEN').concurrent_updates(MyUpdateProcessor(10)).build()\n```\nThe above code processes every `callback_query` update with a delay of 5 seconds for up to 10 updates simultaneously. \nThe psuedocode for this now looks something like this:\n```python\nwhile not application.update_queue.empty():\n  update = await application.update_queue.get()\n  coroutine = application.process_update(update)\n  asyncio.create_task(my_update_processor.do_process_update(update, coroutine))\n```\nThis is just an example of how to use the `BaseUpdateProcessor` class to handle updates in the way you want, there are endless possibilities to this.\nFor example, you can throttle update processing for specific users or ensure that inline queries are always processed sequentially.\nSee the [documentation](https://docs.python-telegram-bot.org/telegram.ext.baseupdateprocessor.html#telegram.ext.BaseUpdateProcessor) for more information.\n\n**Note:** The number of concurrently processed updates is limited (the limit defaults to 4096 updates at a time).\nThis is a simple measure to avoid e.g. DDOS attacks\n\n### `Application.create_task`\n\n`Handler.block` and `Application.concurrent_updates` allow running handler callbacks or the entirety of handling an update concurrently.\nIn addition to that, PTB offers `Application.create_task` to run specific coroutine function concurrently.\n`Application.create_task` is a very thin wrapper around [`asyncio.create_task`](https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task) that adds some book-keeping that comes in handy for using it in PTB.\nPlease consult the documentation of [`Application.create_task`](https://python-telegram-bot.readthedocs.io/en/latest/telegram.ext.application.html#telegram.ext.Application.create_task) for more details.\n\nThis wrapper gives you fine-grained control about how you use concurrency in PTB.\nThe next section gives you an idea about why that is helpful.\n\n## Tailor-made Concurrency\n\nEven though `asyncio` is usually single-threaded, concurrent programming comes with a number of traps to fall into, and we'll try to give you a few hints on how to spot them.\nHowever, this wiki article does not replace ~~your psychiatrist~~ a university lecture on concurrency.\n\nProbably the biggest cause of issues of concurrency are shared states, and those issues are hard to fix.\nSo instead of showing you how to fix them, we'll show you how to avoid them altogether. More about that later.\n\n**A fair warning:** In this section, we'll try to give you a simple talk (if that's possible) on a very complex topic.\nMany have written about it before, and we're certainly less qualified than most.\nAs usual, we'll use an example to complement the text, and try to stay in the realm of what's important to you.\n\nAn example that is often used to illustrate this is that of a bank.\nLet's say you have been hired by a bank to write a Telegram bot to manage bank accounts. The bot has the command `/transaction <amount> <recipient>`, and because many people will be using this command, you think it's a good idea to make this command run concurrently.\n~~You~~ Some unpaid intern wrote the following (**BAD AND DANGEROUS**) callback function:\n\n```python\nasync def transaction(update, context):\n  bot = context.bot\n  chat_id = update.effective_user.id\n  source_id, target_id, amount = parse_update(update)\n\n  await bot.send_message(chat_id, 'Preparing...')\n  bank.log(BEGINNING_TRANSACTION, amount, source_id, target_id)\n\n  source = bank.read_account(source_id)\n  target = bank.read_account(target_mehdi.khodadadehid)\n\n  source.balance -= amount\n  target.balance += amount\n\n  await bot.send_message(chat_id, 'Transferring money...')\n  bank.log(CALCULATED_TRANSACTION, amount, source_id, target_id)\n\n  bank.write_account(source)\n  await bot.send_message(chat_id, 'Source account updated...')\n  await bot.send_message(chat_id, 'Target account updated...')\n  bank.write_account(target)\n\n  await bot.send_message(chat_id, 'Done!')\n  bank.log(FINISHED_TRANSACTION, amount, source_id, target_id)\n\napplication.add_handler(CommandHandler('transaction', transaction, block=False))\n```\n\nWe skipped some of the implementation details, so here's a short explanation:\n\n- `parse_update` extracts the user id's of the sender (`source_id`) and receiver (`target_id`) from the message\n- `bank` is a globally accessible object that exposes the Python API of the banks operations\n  - `bank.read_account` reads a bank account from the bank's database into a Python object\n  - `bank.write_account` writes a bank account back to the bank's database\n  - `bank.log` must be used to keep a log of all changes to make sure no money is lost\n\nSadly, ~~you~~ that damn intern fell right into the trap.\nLet's say there are two morally corrupt customers, *Customer A* with *Account A* and *Customer B* with *Account B*, who both make a transaction simultaneously.\n*Customer A* sends *Transaction AB* of *$10* to *Customer B*.\nAt the same time, *Customer B* sends a *Transaction BA* of *$100* to *Customer A*.\n\nNow the `Application` starts two tasks, *Task AB* and *Task BA*, almost simultaneously.\nBoth tasks read the accounts from the database with the **same** balance and calculate a new balance for both of them.\nIn most cases, one of the two transactions will simply overwrite the other.\nThat's not too bad, but will at least be confusing to the customers.\nHowever, each `await` gives control back to the event loop which may then continue another task.\nHence, the following may occur:\n\n1. *Task AB* executes `bank.write_account(source)` and updates *Account A* with *-$10*\n2. Before updating *Account B*, *Task AB* sends two messages and during that time, the event loop continues *Task BA*\n3. *Task BA* executes `bank.write_account(source)` and updates *Account B* with *-$100*\n4. Before updating *Account A*, *Task BA* sends two messages and during that time, the event loop continues *Task AB*\n5. *Task AB* executes `bank.write_account(target)` and updates *Account B* with *+$10*\n6. When *Task BA* is resumed again, it executes `bank.write_account(target)` and updates *Account A* with *+$100*\n\nIn the end, *Account A* is at *+$100* and *Account B* is at *+$10*.\nOf course, this won't happen very often.\nAnd that's what makes this bug so critical.\nIt will probably be missed by your tests and end up in production, potentially causing a lot of financial damage.\n\n**Note:** This kind of bug is called a [race condition](https://en.wikipedia.org/wiki/Race_condition) and has been the source of many, many security vulnerabilities.\nIt's also one of the reasons why banking software is not written by unpaid interns.\n\nTo be fair, you probably don't write software for banks (if you do, you should already know about this), but this kind of bug can occur in much simpler situations.\nWhile in this case, the shared state is the `bank` object, it can take many forms.\nA database, a `dict`, a `list` or any other kind of object that is modified by more than one task.\nDepending on the situation, race conditions are more or less likely to occur, and the damage they do is bigger or smaller, but as a rule of thumb, they're bad.\n\nAs promised in the first paragraph, let's discuss how to avoid such situations.\nThat's not always as easy as it is in this case, but we're lucky:\n\n1. Our set of tools is very limited - `Application.create_task` is the only `asyncio` tool we're using\n2. Our goals are not very ambitious - we only want to speed up our I/O\n\nThere are two relatively simple steps you have to follow.\nFirst, identify those parts of the code that **must** run sequentially (the opposite of *in parallel* or *concurrently*).\nUsually, that is code that fits **at least one** of these criteria:\n\n1. *Modifies* shared state\n2. *Reads* shared state and *relies on* it being correct\n3. *Modifies* local state (e.g. a variable used later in the same function)\n\nMake sure you have a good idea what *shared state* means\nDon't hesitate to do a quick Google search on it.\n\nLet's go through our bank example line by line and note which of the criteria it matches:\n\n```python\nasync def transaction(update, context):\n  bot = context.bot\n  chat_id = update.effective_user.id  # 3\n  source_id, target_id, amount = parse_update(update)  # 3\n\n  await bot.send_message(chat_id, 'Preparing...')  # None\n  bank.log(BEGINNING_TRANSACTION, amount, source_id, target_id)  # None\n\n  source = bank.read_account(source_id)  # 2, 3\n  target = bank.read_account(target_id)  # 2, 3\n\n  source.balance -= amount  # 3\n  target.balance += amount  # 3\n\n  await bot.send_message(chat_id, 'Transferring money...')  # None\n  bank.log(CALCULATED_TRANSACTION, amount, source_id, target_id)  # None\n\n  bank.write_account(source)  # 1\n  await bot.send_message(chat_id, 'Source account updated...')  # None\n  await bot.send_message(chat_id, 'Target account updated...')  # None\n  bank.write_account(target)  # 1\n\n  await bot.send_message(chat_id, 'Done!')  # None\n  bank.log(FINISHED_TRANSACTION, amount, source_id, target_id)  # None\n\napplication.add_handler(CommandHandler('transaction', transaction, block=False))\n```\n\n**Note:**\nOne could argue that `bank.log` modifies shared state.\nHowever, logging libraries are usually thread-safe and it's unlikely that the log has a critical functional role.\nIt's not being read from in this function, and let's assume it's not being read from anywhere else in the code, so maybe consider this an exception to the rule.\nAlso, for the sake of this example, it'd be boring if only `bot.sendMessage` would be safe to run in parallel.\nHowever, we will keep this in mind for the next step.\n\nAs you can see, there's a pretty obvious pattern here:\n`bot.send_message` and `bank.log` are not matching any criteria we have set for strictly sequential code.\nThat means we can run this code asynchronously without risk.\nTherefore, the second step is to extract that code to separate functions and run only them concurrently.\nSince our async code parts are all very similar, they can be replaced by a single function.\nWe could have done that before, but then this moment would've been less cool.\n\n```python\nasync def log_and_notify(action, amount, source_id, target_id, chat_id, message):\n  bank.log(action, amount, source_id, target_id)\n  await bot.send_message(chat_id, message)\n\nasync def transaction(update, context):\n  chat_id = update.message.chat_id  # 3\n  source_id, target_id, amount = parse_update(update)  # 3\n\n  context.application.create_task(\n    log_and_notify(\n      BEGINNING_TRANSACTION,\n      amount,\n      source_id,\n      target_id,\n      chat_id,\n      'Preparing...',\n    ),\n    update=update\n  )\n\n  source = bank.read_account(source_id)  # 2, 3\n  target = bank.read_account(target_id)  # 2, 3\n\n  source.balance -= amount  # 3\n  target.balance += amount  # 3\n\n  context.application.create_task(\n    log_and_notify(\n      CALCULATED_TRANSACTION,\n      amount,\n      source_id,\n      target_id,\n      chat_id,\n      'Transferring money...'\n    ),\n    update=update\n  )\n\n  bank.write_account(source)  # 1\n  bank.write_account(target)  # 1\n\n\n  context.application.create_task(\n    log_and_notify(\n      FINISHED_TRANSACTION,\n      amount,\n      source_id,\n      target_id,\n      chat_id,\n      'Done!',\n    ),\n    update=update\n  )\n\napplication.add_handler(CommandHandler('transaction', transaction, block=True))\n```\n\n**Note:** You might have noticed that we moved `bank.log` before `bot.send_message`, so the log entries will be in order *most of the time*, assuming the database operations take long enough for the log to complete.\n\n**Note:** It's likely that `bank.read_account` and `bank.write_account` require some I/O operations to interact with the banks database.\nYou see that it's not always possible to write code concurrently, at least with this simplified method. Read about [Transactions](https://en.wikipedia.org/wiki/Database_transaction) to learn how databases solve this in \"real life\".\n\nBy separating the strictly sequential code from the concurrent code, we made sure that no race conditions can occur.\nThe `transaction` function won't be executed concurrently anymore, but we still managed to gain some substantial performance boost over completely sequential code, because the logging and user notification is now run in parallel.\n\nThat's basically it for now.\nFor the very end, here are a few helpful guidelines for writing concurrent code:\n\n- Avoid using shared state whenever possible\n- Write self-contained ([pure](https://en.wikipedia.org/wiki/Pure_function)) functions\n- When in doubt, make it sequential\n"
    },
    {
        "name": "Emoji.md",
        "description": "You've now made a cool bot, but it's lacking personality? Add some emoji!\n\n# Direct Method\n\nThe easiest way to use emoji is to directly put them in your strings. The Unicode website has a chart with [all the emoji](http://www.unicode.org/emoji/charts/full-emoji-list.html). Simply select any emoji you want, this works with both the images and the raw characters in the \"Browser\" column, and paste it in your string.\n\n```python\ntext = \"🌈⛈🎉🌹🐧😊\"\n```\n\nIn the code you may see squares with numbers in them instead of the emoji themself. This means the font in your text editor does not have an image for that character, but it is still there.\n\nFinally, test your emoji by sending it to yourself over Telegram. Know that Telegram does not support all the emoji.\n\n# The emoji module\n\nWith the [emoji module](https://github.com/carpedm20/emoji) you don't have to copy paste emoji, you can use their names or aliases as on GitHub:\n```python\nfrom emoji import emojize\nbot.send_message(emojize(\"yummy :cake:\", use_aliases=True))\n```\n\nNote: the `emojize` function uses regular expressions and takes on the order of microseconds to complete. If your bot handles billions of messages per second, put the emoji in reusable variables to micro-optimize:\n```python\ncake = emojize(\":cake:\", use_aliases=True)\n```"
    },
    {
        "name": "Examples.md",
        "description": "This page has been moved to [Bots built with PTB](Bots-built-with-PTB)."
    },
    {
        "name": "Exception-Handling.md",
        "description": "This page is now over at [[Exceptions, Warnings and Logging|Exceptions,-Warnings-and-Logging]]"
    },
    {
        "name": "Exceptions,-Warnings-and-Logging.md",
        "description": "While you program your bot and while the bot is running there can be several things that can go wrong. This page gives an overview on how you can handle those situations.\n\n# Exceptions\n\nIn `python-telegram-bot`, all Telegram-related errors are encapsulated in the `TelegramError` exception class and its subclasses, located in [`telegram.error`](https://python-telegram-bot.readthedocs.io/telegram.error.html) module.\n\nAny error, including `TelegramError`, that is raised in one of your handler or job callbacks (or while calling `get_updates` in the `Updater`), is forwarded to all registered error handlers, so you can react to them. You can register an error handler by calling `Application.add_error_handler(callback)`, where `callback` is a coroutine function that takes the `update` and `context`. `update` will be the update that caused the error (or `None` if the error wasn't caused by an update, e.g. for [[Jobs|Extensions---JobQueue]]) and `context.error` the error that was raised.\n\nThe good news is that exceptions that are handled by the error handlers don't stop your python process - your bot will just keep running!\n\n**Example:** You're trying to send a message, but the user blocked the bot. An `Forbidden` exception, a subclass of `TelegramError`, will be raised and delivered to your error handler, so you can delete it from your conversation list, if you keep one.\n\n> [!NOTE]\n>  The error handler might be only your last resort - of course you can also handle exceptions as they occur. Only uncaught exceptions are forwarded to the error handler.\n\nOther common approaches for more fine-grained error handling are using `try-except` in crucial places or by implementing a custom retry-mechanism by subclassing [`BaseRequest`](https://docs.python-telegram-bot.org/en/stable/telegram.request.baserequest.html) or [`HTTPXRequest`](https://docs.python-telegram-bot.org/en/stable/telegram.request.httpxrequest.html).\n\n## Example\n\nFor an example on how an error handler might look like, please head over to the [examples directory](https://docs.python-telegram-bot.org/examples.html).\n\n# Logging\n\nIn case you don't have an error handler registered, PTB will *log* any unhandled exception.\nFor logging, PTB uses Python's [`logging` module](https://docs.python.org/3/library/logging.html).\nTo set up logging to standard output, you can write something like\n```python\nimport logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\n```\nat the beginning of your script. If you want debug logs instead, use `level=logging.DEBUG`.\n`python-telegram-bot` makes some more verbose log entries on the `logging.DEBUG` level that might be helpful when you're trying to debug your bot.\n\nNote that also some third-party libraries that `python-telegram-bot` uses, make log entries in the same manner. If you are using the `basicConfig` from the example above, you will see that your log is cluttered with entries by `httpx`: starting with [v.0.24.1](https://github.com/encode/httpx/releases/tag/0.24.1), `httpx` logs all requests at `INFO` level, which makes sense for `httpx` but could annoy you as a PTB user. \n\nIn this case, you can set logging level specifically for `httpx` and `httpcore` (used by `httpx`:\n\n```py\nimport logging\n\nlogging.getLogger('httpx').setLevel(logging.WARNING)\nlogging.getLogger('httpcore').setLevel(logging.WARNING)\n```\n\n> If you set logging level to `DEBUG` for your application, you might want to set it to `INFO` for `httpx` (so you can see the requests that are made).\n\nAnother example: if you don't want to see the logs of the `APScheduler` library about your `JobQueue` jobs being scheduled, you can specify the logging level of `APScheduler` as follows:\n\n```python\nimport logging\n\nlogging.getLogger('apscheduler').setLevel(logging.WARNING)\n```\n\n# Warnings\n\nIn contrast to exceptions, warnings usually don't indicate that something already did go wrong, but rather that something *could* go wrong or at least could be improved.\nWarnings issued by `python-telegram-bot` are encapsulated in `PTBUserWarning` or one of the subclasses, located in the [`telegram.warnings` module](https://python-telegram-bot.readthedocs.io/telegram.warnings.html).\nThis allows you to easily handle the warnings using Pythons [`warnings` library](https://docs.python.org/3/library/warnings.html).\nFor example, if you don't want to miss any deprecation warning during development, you can tell Python to turn every such warning issued by PTB into an exception via\n\n```python\nimport warnings\nfrom telegram.warnings import PTBDeprecationWarning\n\nwarnings.filterwarnings(\"error\", category=PTBDeprecationWarning)\n```"
    },
    {
        "name": "Extensions---Advanced-Filters.md",
        "description": "This page describes advanced use cases for the filters used with `MessageHandler` (also with `CommandHandler` and `PrefixHandler`) from `telegram.ext`.\n\n# Combining filters\nWhen using `MessageHandler` it is sometimes useful to have more than one filter. This can be done using so called bit-wise operators. In Python those operators are `&`, `|` and `~` meaning AND, OR and NOT respectively. Since version 13.1 filters support `^` for XOR.\n## Examples\n#### Message is either video, photo, or document (generic file)\n``` python\nfrom telegram.ext import MessageHandler, filters\n\nhandler = MessageHandler(\n   filters.VIDEO | filters.PHOTO | filters.Document.ALL, \n   callback\n)\n```\n\n#### Message is a forwarded photo\n``` python\nhandler = MessageHandler(filters.FORWARDED & filters.PHOTO, callback)\n```\n\n#### Message is text and contains a link\n``` python\nfrom telegram import MessageEntity\n\nhandler = MessageHandler(\n   filters.TEXT & (\n      filters.Entity(MessageEntity.URL) |\n      filters.Entity(MessageEntity.TEXT_LINK)\n   ),\n   callback\n)\n```\n\n#### Message is a photo and it's not forwarded\n``` python\nhandler = MessageHandler(\n   filters.PHOTO & (~ filters.FORWARDED),\n   callback\n)\n```\n\n# Custom filters\nIt is also possible to write our own filters. In essence, a filter is simply a function that receives either a `Message` instance or a `Update` instance and returns either `True` or `False`. This function has to be implemented in a new class that inherits from either `MessageFilter` or `UpdateFilter`, which allows it to be combined with other filters. If the combination of all filters evaluates to `True`, the message will be handled.\n\nThe difference between `UpdateFilter` and `MessageFilter` is that the `filter` function of the former will receive the `update`, allowing e.g. to differentiate between channel post updates and message updates, while the `filter` function of the latter will receive the `update.effective_message`.\n\nSay we wanted to allow only those messages that contain the text \"python-telegram-bot is awesome\", we could write a custom filter as so:\n\n```python\nfrom telegram.ext.filters import MessageFilter\n\nclass FilterAwesome(MessageFilter):\n    def filter(self, message):\n        return 'python-telegram-bot is awesome' in message.text\n\n# Remember to initialize the class.\nfilter_awesome = FilterAwesome()\n```\n\nThe class can of course be named however you want, the only important things are:\n- The class has to inherit from `MessageFilter` or `UpdateFilter`\n- It has to implement a `filter` method\n- You have to create an instance of the class\n\nThe filter can then be used as:\n```python\nawesome_handler = MessageHandler(filter_awesome, callback)\napplication.add_handler(awesome_handler)\n```\n\n## `Filters` and `CallbackContext`\n\nYou may have noticed that when using [`filters.Regex`](https://python-telegram-bot.readthedocs.io/telegram.ext.filters.html#telegram.ext.filters.Regex), the attributes [`context.matches`](https://python-telegram-bot.readthedocs.io/telegram.ext.callbackcontext.html#telegram.ext.CallbackContext.matches) and [`context.match`](https://python-telegram-bot.readthedocs.io/telegram.ext.callbackcontext.html#telegram.ext.CallbackContext.match) are set to the corresponding matches. To achieve something like this for your custom filter, you can do the following:\n\n1. Set `self.data_filter=True` for your filter.\n2. If the update should be handled, return a dictionary of the form `{attribute_name: [values]}`. This dict will be merged with the internal dict of the `context` argument making `value` available as `context.attribute_name`. This currently works with `MessageHandler`, `CommandHandler` and `PrefixHandler`, which are the only handlers that accept filters.\n\n> [!IMPORTANT] \n> The values of the returned dict must be *lists*. This is necessary to make sure that multiple data filters can be merged meaningfully.\n\nIf you want this to work with your custom handler, make sure that `YourHandler.collect_additional_context` does something like\n\n```python\nif isinstance(check_result, dict):\n    context.update(check_result)\n```\n"
    },
    {
        "name": "Extensions---JobQueue.md",
        "description": "# Introduction\nThe extension class [`telegram.ext.JobQueue`](https://docs.python-telegram-bot.org/telegram.ext.jobqueue.html#telegram.ext.JobQueue) allows you to perform tasks with a delay or even periodically, at a set interval. Among many other things, you can use it to send regular updates to your subscribers.\n\n## When working with `JobQueue`, please keep in mind:\n\n* PTBs `JobQueue` provides an easy to use and ready to use way of scheduling tasks in a way that ties in with the PTB architecture\n* Managing scheduling logic is not the main intend of PTB and hence as of v13 a third party library is used\n* If you need highly customized scheduling thingies, you *can* use advanced features of the third party library\n* We can't guarantee that the backend will stay the same forever. For example, if the third party library is discontinued, we will have to look for alternatives.\n\n## Example\n\nIn addition to the tutorial below, there is also the `timerbot.py` example at the [examples directory](https://github.com/python-telegram-bot/python-telegram-bot/tree/master/examples).\n\n# Usage\n> [!WARNING] \n> Since v20, you must install PTB with the optional requirement `job-queue`, i.e. \n>\n> ```sh\n> pip install python-telegram-bot[job-queue]\n> ```\n\nThe `JobQueue` class is tightly integrated with other `telegram.ext` classes.\n\nTo use the `JobQueue`, you don't have to do much. When you build the `Application`, it will create a `JobQueue` for you:\n\n```python\nfrom telegram.ext import Application\n\napplication = Application.builder().token('TOKEN').build()\njob_queue = application.job_queue\n```\n\nJust know that unless you have a good reason to do so, you should not instantiate `JobQueue` yourself.\n\nTasks in the job queue are encapsulated by the [`Job`](https://python-telegram-bot.readthedocs.io/telegram.ext.job.html#telegram-ext-job) class. It takes a [callback function as a parameter](https://python-telegram-bot.readthedocs.io/telegram.ext.job.html#telegram.ext.Job.params.callback), which will be executed when the time comes. This callback function always takes exactly one parameter: `context`, a [`telegram.ext.CallbackContext`](https://python-telegram-bot.readthedocs.io/telegram.ext.callbackcontext.html). Like in the case of handler callbacks used by the `Application`, through this object you can access \n* `context.bot`, the `Application`'s `telegram.Bot` instance\n* `context.job_queue`, the same object as `application.job_queue` above\n* and for this particular case you can also access `context.job`, which is the `Job` instance of the task that triggered the callback (more on that later). \n\nYou can use the following methods to create jobs with different frequency and time: `job_queue.run_once`, `job_queue.run_repeating`, `job_queue.run_daily` and `job_queue.run_monthly`. (As before, you do not usually need to instantiate the `Job` class directly.)\n\n## Tutorial\n\nAdd your first job to the queue by defining a callback function and adding it to the job queue. For this tutorial, you can replace `'@examplechannel'` with a channel where your bot is an admin, or by your user id (use [@userinfobot](https://telegram.me/userinfobot) to find out your user id):\n\n```python\nfrom telegram.ext import ContextTypes, Application\n\nasync def callback_minute(context: ContextTypes.DEFAULT_TYPE):\n    await context.bot.send_message(chat_id='@examplechannel', text='One message every minute')\n\napplication = Application.builder().token('TOKEN').build()\njob_queue = application.job_queue\n\njob_minute = job_queue.run_repeating(callback_minute, interval=60, first=10)\n\napplication.run_polling()\n```\n\nThe `callback_minute` function will be executed every `60.0` seconds, the first time being after 10 seconds (because of `first=10`). The `interval` and `first` parameters are in seconds if they are `int` or `float`. They can also be `datetime` objects. See the [docs](http://python-telegram-bot.readthedocs.io/telegram.ext.jobqueue.html) for detailed explanation.\nThe return value of these functions are the `Job` objects being created. You don't need to store the result of `run_repeating` (which is the newly instantiated `Job`) if you don't need it; we will make use of it later in this tutorial.\n\nYou can also add a job that will be executed only once, with a delay:\n\n```python\nfrom telegram.ext import ContextTypes, Application\n\nasync def callback_30(context: ContextTypes.DEFAULT_TYPE):\n    await context.bot.send_message(chat_id='@examplechannel', text='A single message with 30s delay')\n\napplication = Application.builder().token('TOKEN').build()\njob_queue = application.job_queue\n\njob_queue.run_once(callback_30, 30)\n\napplication.run_polling()\n```\n\nIn thirty seconds, you should receive the message from `callback_30`. \n\nIf you are tired of receiving a message every minute, you can temporarily disable a job or even completely remove it from the queue:\n\n```python\njob_minute.enabled = False  # Temporarily disable this job\njob_minute.schedule_removal()  # Remove this job completely\n```\n\n> [!CAUTION]\n> [`schedule_removal`](https://python-telegram-bot.readthedocs.io/telegram.ext.job.html#telegram.ext.Job.schedule_removal) does not immediately remove the job from the queue. Instead, it is marked for removal and will be removed as soon as its current interval is over (it will not run again after being marked for removal).\n\nYou might want to add jobs in response to certain user input, and there is a convenient way to do that. The `context` argument of your `Handler` callbacks has the `JobQueue` attached as `context.job_queue` ready to be used. Another feature you can use here are the [`data`](https://python-telegram-bot.readthedocs.io/telegram.ext.job.html#telegram.ext.Job.params.data), [`chat_id`](https://python-telegram-bot.readthedocs.io/telegram.ext.job.html#telegram.ext.Job.params.chat_id) or [`user_id`](https://python-telegram-bot.readthedocs.io/telegram.ext.job.html#telegram.ext.Job.params.user_id) keyword arguments of `Job`. You can pass any object as a `data` parameter when you launch a `Job` and retrieve it at a later stage as long as the `Job` exists. The `chat_id`/`user_id` parameter allows for an easy way to let the `Job` know which chat we're talking about. This way, we can access `context.chat_data`/`context.user_data` in the job's `callback`. Let's see how it looks in code:\n\n```python\nfrom telegram import Update\nfrom telegram.ext import CommandHandler, Application, ContextTypes\n \nasync def callback_alarm(context: ContextTypes.DEFAULT_TYPE):\n    # Beep the person who called this alarm:\n    await context.bot.send_message(chat_id=context.job.chat_id, text=f'BEEP {context.job.data}!')\n \n \nasync def callback_timer(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    chat_id = update.message.chat_id\n    name = update.effective_chat.full_name\n    await context.bot.send_message(chat_id=chat_id, text='Setting a timer for 1 minute!')\n    # Set the alarm:\n    context.job_queue.run_once(callback_alarm, 60, data=name, chat_id=chat_id)\n \napplication = Application.builder().token('TOKEN').build()\ntimer_handler = CommandHandler('timer', callback_timer)\napplication.add_handler(timer_handler)\napplication.run_polling()\n```\n\nBy placing the `chat_id` in the `Job` object, the callback function knows where it should send the message.\n\n\nAll good things must come to an end, so when you stop the Application, the related job queue will be stopped as well.\n\n## Persistent Job Queues\n\nPTBs [[Persistence Setup|Making-your-bot-persistent]] currently does not support serialization of jobs.\nHowever, the current backend of the `JobQueue`, namely the `APScheduler` library has a mechanism for that, which you can leverage.\nCheck out e.g. [ptbcontrib/ptb_jobstores](https://github.com/python-telegram-bot/ptbcontrib/tree/main/ptbcontrib/ptb_jobstores) for an example implementation.\n"
    },
    {
        "name": "Extensions---Your-first-Bot.md",
        "description": "## Introduction\nThe `telegram.ext` submodule is built on top of the pure API implementation. It provides an easy-to-use interface and takes some work off the programmer, so you [don't have to repeat yourself](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself).\n\nIt consists of several classes, but the most important one is [`telegram.ext.Application`](https://docs.python-telegram-bot.org/telegram.ext.application.html#telegram-ext-application).\n\nThe `Application` class is responsible for fetching updates from the `update_queue`, which is where the [`Updater`](https://docs.python-telegram-bot.org/telegram.ext.updater.html#telegram-ext-updater) class continuously fetches new updates from Telegram and adds them to this queue.\nIf you create an `Application` object, using [`ApplicationBuilder`](https://docs.python-telegram-bot.org/telegram.ext.applicationbuilder.html#telegram-ext-applicationbuilder), it will automatically create an `Updater` for you and link them together with an [`asyncio.Queue`](https://docs.python.org/3/library/asyncio-queue.html#asyncio.Queue). \nYou can then register handlers of different types in the `Application`, which will sort the updates fetched by the `Updater` according to the handlers you registered, and deliver them to a callback function that you defined.\n\nEvery handler is an instance of any subclass of the [`telegram.ext.BaseHandler`](https://docs.python-telegram-bot.org/telegram.ext.basehandler.html#telegram.ext.BaseHandler) class. The library provides [[handler classes for almost all use cases|Types-of-Handlers]], but if you need something very specific, you can also subclass `Handler` yourself.\n\n> [!TIP]\n> To begin, you'll need an Access Token. If you have already read and followed [[Introduction to the API|Introduction-to-the-API]], you can use the one you generated then. If not: To generate an Access Token, you have to talk to [@BotFather](https://telegram.me/botfather) and follow a few simple steps (described [here](https://core.telegram.org/bots/features#botfather)). You should really read the introduction first, though.\n\n\n## Your first Bot, step-by-step\n\nPlease create a new file if you want to follow this tutorial.\nWe will add new content to the file several times during the tutorial.\nFor the sake of brevity, we will not repeat everything every time we add something.\n\nSo, *let's get started!*.\nPaste the following into your file:\n\n```python\nimport logging\nfrom telegram import Update\nfrom telegram.ext import ApplicationBuilder, ContextTypes, CommandHandler\n\nlogging.basicConfig(\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    level=logging.INFO\n)\n\nasync def start(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    await context.bot.send_message(chat_id=update.effective_chat.id, text=\"I'm a bot, please talk to me!\")\n\nif __name__ == '__main__':\n    application = ApplicationBuilder().token('TOKEN').build()\n    \n    start_handler = CommandHandler('start', start)\n    application.add_handler(start_handler)\n    \n    application.run_polling()\n```\n\nNow this is a lot to digest, so let's go through it step by step.\n\n```python\nimport logging\nlogging.basicConfig(\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    level=logging.INFO\n)\n```\n\nThis part is for setting up `logging` module, so you will know when (and why) things don't work as expected:\n\n**Note:** Read the article on [[Exceptions, Warnings and Logging|Exceptions,-Warnings-and-Logging]] if you want to learn more.\n\n```python\napplication = ApplicationBuilder().token('TOKEN').build()\n```\n\nHere the first real magic happens: You have to create an `Application` object. Replace `'TOKEN'` with your Bot's API token.\nFor more details on how this works, see [[this page|Builder-Pattern]].\n\n**Related docs:** [`telegram.ext.ApplicationBuilder`](https://docs.python-telegram-bot.org/telegram.ext.applicationbuilder.html#telegram-ext-applicationbuilder), [`telegram.ext.Application`](https://docs.python-telegram-bot.org/telegram.ext.application.html#telegram.ext.Application)\n\nThe application alone doesn't do anything.\nTo add functionality, we do two things.\nFirst, we define a function that should process a specific type of update:\n\n```python\nasync def start(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    await context.bot.send_message(\n        chat_id=update.effective_chat.id,\n        text=\"I'm a bot, please talk to me!\"\n    )\n```\n\n\nThe goal is to have this function called every time the Bot receives a Telegram message that contains the `/start` command. \n\nAs you can see, this function will receive two parameters: an `update`, which is an object that contains all the information and data that are coming from Telegram itself (like the message, the user who issued the command, etc) and a `context`, which is another object that contains information and data about the status of the library itself (like the `Bot`, the `Application`, the `job_queue`, etc).\n\n**Related docs:** [`send_message`](https://docs.python-telegram-bot.org/telegram.bot.html#telegram.Bot.send_message), [`telegram.ext.CallbackContext` (the type of the context argument)](https://docs.python-telegram-bot.org/telegram.ext.callbackcontext.html), [`telegram.Update` (the type of update argument)](https://docs.python-telegram-bot.org/telegram.update.html)\n\nTo tell your bot to listen to `/start` commands, you can use a `CommandHandler` (one of the provided `Handler` subclasses) and register it in the application:\n\n```python\nfrom telegram.ext import CommandHandler\nstart_handler = CommandHandler('start', start)\napplication.add_handler(start_handler)\n```\n\n**Related docs:** [`telegram.ext.CommandHandler`](http://docs.python-telegram-bot.org/telegram.ext.commandhandler.html), [`telegram.ext.Application.add_handler`](http://docs.python-telegram-bot.org/telegram.ext.application.html#telegram.ext.Application.add_handler)\n\nAnd that's all you need.\n\nFinally, the line `application.run_polling()` runs the bot until you hit `CTRL+C`.\n\n**Related docs:** [`telegram.ext.Application.run_polling`](http://docs.python-telegram-bot.org/telegram.ext.application.html#telegram.ext.Application.run_polling)\n\nGive it a try! Start a chat with your bot and issue the `/start` command - if all went right, it will reply.\n\nBut our Bot can now only answer to the `/start` command.\nLet's add another handler that listens for regular messages. Use the `MessageHandler`, another `Handler` subclass, to echo all text messages.\nFirst, stop your bot by hitting `CTRL+C`.\nNow define a new function and add a corresponding handler:\n\n```python\nfrom telegram import Update\nfrom telegram.ext import filters, MessageHandler, ApplicationBuilder, CommandHandler, ContextTypes\n\n...\n\nasync def echo(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    await context.bot.send_message(chat_id=update.effective_chat.id, text=update.message.text)\n\n    \nif __name__ == '__main__':\n    ...\n    echo_handler = MessageHandler(filters.TEXT & (~filters.COMMAND), echo)\n    \n    application.add_handler(start_handler)\n    application.add_handler(echo_handler)\n\n    application.run_polling()\n```\n**Related docs:** [`telegram.ext.MessageHandler`](http://docs.python-telegram-bot.org/telegram.ext.messagehandler.html), [`telegram.ext.filters`](https://docs.python-telegram-bot.org/telegram.ext.filters.html)\n\nFrom now on, your bot should echo all non-command messages it receives.\n\n> [!NOTE]\n> The `filters` module contains a number of so-called filters that filter incoming messages for text, images, status updates and more. Any message that returns `True` for at least one of the filters passed to `MessageHandler` will be accepted. You can also write your own filters if you want. See more in [[Advanced Filters|Extensions---Advanced-Filters]].\n\nLet's add some actual functionality to your bot. We want to implement a `/caps` command that will take some text as an argument (e.g. `/caps argument`) and reply to it in CAPS. To make things easy, you will receive the arguments (as a `list`, split on spaces) that were passed to a command in the callback function:\n\n```python\nasync def caps(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    text_caps = ' '.join(context.args).upper()\n    await context.bot.send_message(chat_id=update.effective_chat.id, text=text_caps)\n    \nif __name__ == '__main__':\n    ...\n    caps_handler = CommandHandler('caps', caps)\n    \n    application.add_handler(start_handler)\n    application.add_handler(echo_handler)\n    application.add_handler(caps_handler)\n\n    application.run_polling()\n```\n\n> [!NOTE]\n> Take a look at the usage of [`context.args`](https://docs.python-telegram-bot.org/telegram.ext.callbackcontext.html#telegram.ext.CallbackContext.args). The `CallbackContext` will have several attributes, depending on which handler is used.\n\nAnother cool feature of the Telegram Bot API is the [inline mode](https://core.telegram.org/bots/inline). If you want to implement inline functionality for your bot, please first talk to [@BotFather](https://telegram.me/botfather) and enable inline mode using `/setinline`. It sometimes takes a while until your Bot registers as an inline bot on your client. You might be able to speed up the process by restarting your Telegram App (or sometimes, you just have to wait for a while).\n\nAs your bot is obviously a very loud one, let's continue with this theme for inline. You probably know the process by now, but there are a number of new types used here, so pay some attention:\n\n```python\nfrom telegram import InlineQueryResultArticle, InputTextMessageContent\nfrom telegram.ext import InlineQueryHandler\n\nfrom uuid import uuid4\n\n...\n\nasync def inline_caps(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    query = update.inline_query.query\n    if not query:\n        return\n    results = []\n    results.append(\n        InlineQueryResultArticle(\n            id=str(uuid4()),\n            title='Caps',\n            input_message_content=InputTextMessageContent(query.upper())\n        )\n    )\n    await context.bot.answer_inline_query(update.inline_query.id, results)\n\nif __name__ == '__main__':\n    ...\n    inline_caps_handler = InlineQueryHandler(inline_caps)\n    application.add_handler(inline_caps_handler)\n\n    application.run_polling()\n```\n**Related docs:** [telegram.ext.InlineQueryHandler](http://docs.python-telegram-bot.org/telegram.ext.inlinequeryhandler.html), [answer_inline_query](https://docs.python-telegram-bot.org/telegram.bot.html#telegram.Bot.answer_inline_query)\n\nNot bad! Your Bot can now yell on command (ha!) and via inline mode. \n\nSome confused users might try to send commands to the bot that it doesn't understand, so you can use a `MessageHandler` with a `COMMAND` filter to reply to all commands that were not recognized by the previous handlers. \n\n```python\n...\n\nasync def unknown(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    await context.bot.send_message(chat_id=update.effective_chat.id, text=\"Sorry, I didn't understand that command.\")\n\nif __name__ == '__main__':\n    ...\n    \n    # Other handlers\n    unknown_handler = MessageHandler(filters.COMMAND, unknown)\n    application.add_handler(unknown_handler)\n\n    application.run_polling()\n```\n\n> [!IMPORTANT]\n> This handler *must* be added last.\n> If you added it before the other handlers, it would be triggered before the `CommandHandlers` had a chance to look at the update.\n> Once an update is handled, all further handlers are ignored.\n> To circumvent this, you can pass the keyword argument `group (int)` to `add_handler` with a value other than 0.\n> See [`telegram.ext.Application.add_handler`](https://docs.python-telegram-bot.org/telegram.ext.application.html#telegram.ext.Application.add_handler) and [[this wiki page|Frequently-requested-design-patterns#how-to-handle-updates-in-several-handlers]] for details.\n\nIf you're done playing around, stop the bot by pressing `CTRL+C`.\n\n#### What to read next?\nHave a look at the ready-to-run [examples](https://github.com/python-telegram-bot/python-telegram-bot/tree/master/examples).\n\nLearn about the library exceptions and best practices in [[Exceptions, Warnings and Logging|Exceptions,-Warnings-and-Logging]].\n\nYou want *more features*? Check out [[Extensions - JobQueue|Extensions---JobQueue]]!"
    },
    {
        "name": "Extensions-–-Advanced-Filters.md",
        "description": "This page is now over at [[Extensions---Advanced-Filters|Extensions---Advanced-Filters]]"
    },
    {
        "name": "Extensions-–-JobQueue.md",
        "description": "This page is now over at [[Extensions---JobQueue|Extensions---JobQueue]]"
    },
    {
        "name": "Extensions-–-Your-first-Bot.md",
        "description": "This page is now over at [[Your first Bot|Extensions---Your-first-Bot]]"
    },
    {
        "name": "Frequently-Asked-Questions.md",
        "description": "# Frequently Asked Questions\n\n*Note:* You may also want to check the official [Telegram Bot FAQ](https://core.telegram.org/bots/faq#what-messages-will-my-bot-get).\n\n- [What messages can my Bot see?](#what-messages-can-my-bot-see)\n- [What about messages from other Bots?](#what-about-messages-from-other-bots)\n- [Can my bot delete messages from the user in a private chat?](#can-my-bot-delete-messages-from-the-user-in-a-private-chat)\n- [How can I get a list of all chats/users/channels my bot is interacting with?](#how-can-i-get-a-list-of-all-chatsuserschannels-my-bot-is-interacting-with)\n- [Does my bot get an update, when someone joins my channel?](#does-my-bot-get-an-update-when-someone-joins-my-channel)\n- [My bot doesn't receive messages from groups. Why?](#my-bot-doesnt-receive-messages-from-groups-why)\n- [Can you add [feature] to PTB? Can I do [thing] with my bot?](#can-you-add-feature-to-ptb-can-i-do-thing-with-my-bot)\n- [I'm using `ConversationHandler` and want one handler to be run multiple times. How do I do that?](#im-using-conversationhandler-and-want-one-handler-to-be-run-multiple-times-how-do-i-do-that)\n- [I want to handle updates from an external service in addition to the Telegram updates. How do I do that?](#i-want-to-handle-updates-from-an-external-service-in-addition-to-the-telegram-updates-how-do-i-do-that)\n- [Why am I getting `ImportError: cannot import name 'XY' from 'telegram'`?](#why-am-i-getting-importerror-cannot-import-name-xy-from-telegram)\n- [What do the `per_*` settings in `ConversationHandler` do?](#what-do-the-per_-settings-in-conversationhandler-do)\n- [Can I check, if a `ConversationHandler` is currently active for a user?](#can-i-check-if-a-conversationhandler-is-currently-active-for-a-user)\n- [How can I list all messages of a particular chat or search through them based on a search query?](#how-can-i-list-all-messages-of-a-particular-chat-or-search-through-them-based-on-a-search-query)\n- [Why am I getting an error `The following arguments have not been supplied`?](#why-am-i-getting-an-error-the-following-arguments-have-not-been-supplied)\n- [How can I check the version of PTB I am using?](#how-can-i-check-the-version-of-ptb-i-am-using)\n- [How do I access info about the message my bot sent?](#how-do-I-access-info-about-the-message-my-bot-sent)\n- [How can I print a table in a Telegram message? Is it a lost cause?](#how-can-i-print-a-table-in-a-telegram-message-is-it-a-lost-cause)\n- [Can an `InlineKeyboardButton` have both a URL and `callback-data`?](#can-an-inlinekeyboardbutton-have-both-a-url-and-callback-data)\n- [Why am I suddenly getting so many log entries from `httpx`?](#why-am-i-suddenly-getting-so-many-log-entries-from-httpx)\n- [How can my bot use premium features?](#how-can-my-bot-use-premium-features)\n\n### What messages can my Bot see?\n\nFrom the official [Telegram Bot FAQ](https://core.telegram.org/bots/faq#what-messages-will-my-bot-get):\n\n> **All bots, regardless of settings, will receive:**\n>\n> * All service messages.\n> * All messages from private chats with users.\n> * All messages from channels where they are a member.\n>\n> **Bot admins and bots with privacy mode disabled will receive all messages except messages sent by other bots.**\n> \n> **Bots with privacy mode enabled will receive:**\n> \n> * Commands explicitly meant for them (e.g., /command@this_bot).\n> * General commands from users (e.g. /start) if the bot was the last bot to send a message to the group.\n> * Messages sent via this bot.\n> * Replies to any messages implicitly or explicitly meant for this bot.\n> \n> **Note that each particular message can only be available to one privacy-enabled bot at a time, i.e., a reply to bot A containing an explicit command for bot B or sent via bot C will only be available to bot A. Replies have the highest priority.**\n\n# ⚠️🚨 **Note:** 🚨⚠️\n\nTurning off the privacy mode has no effect for groups the bot is already in (because obviously that would be a security issue). You need to re-add your bot to those groups.\n\n### What about messages from other Bots?\n\nFrom the official [Telegram Bot FAQ](https://core.telegram.org/bots/faq#why-doesn-39t-my-bot-see-messages-from-other-bots):\n> Bots talking to each other could potentially get stuck in unwelcome loops. To avoid this, we decided that bots will not be able to see messages from other bots regardless of mode.\n>\nAlthough, It is still possible to see a bot message if bot is replied to, with `reply_to_message` but you can't do any actions(forward etc) except delete on this message.\n\n### Can my bot delete messages from the user in a private chat?\n\nYes, but only within the first 48 hours.\n\n### How can I get a list of all chats/users/channels my bot is interacting with?\n\nThere is no method for that. You'll need to keep track. See e.g. the [`chatmemberbot.py`](https://docs.python-telegram-bot.org/en/stable/examples.html#examples-chatmemberbot) example.\n\n### Does my bot get an update, when someone joins my channel?\n\nYes. We receive ChatMemberUpdated update.\n\n### My bot doesn't receive messages from groups. Why?\n\nSee [here](#what-messages-can-my-bot-see). TL;DR: Disable group privacy with [@BotFather](https://t.me/BotFather) ⚠️🚨 *and re-add your bot to the group* 🚨⚠️\n\n### Can you add [feature] to PTB? Can I do [thing] with my bot?\n\nPlease note that python-telegram-bot is only a *wrapper* for the Telegram Bot API, i.e. PTB can only provide methods that are available through the API.\nYou can find a full list of all available methods in the [official docs](https://core.telegram.org/bots/api#available-methods).\nAnything *not* listed there can not be done with bots. Here is a short list of frequently requested tasks, that can *not* be done with the Bot API:\n\n* Getting a list of all members of a group. You'll need to keep track, e.g. using approaches displayed in [chatmemberbot.py](https://docs.python-telegram-bot.org/en/stable/examples.html#examples-chatmemberbot)\n* Adding members to a group/channel (note that you can just send an invite link, which is also less likely to be seen as spam)\n* Clearing the chat history for a user\n* Getting a message by its `message_id` (For the interested reader: see [here](https://github.com/tdlib/telegram-bot-api/issues/62))\n* Getting the last sent message in a chat (you can keep track of that by using [`chat_data`](Storing-bot,-user-and-chat-related-data))\n* Getting a users `user_id` via their `@username` (only userbots can do that - you may be interested in [`ptbcontrib/username_to_chat_api`](https://github.com/python-telegram-bot/ptbcontrib/tree/main/ptbcontrib/username_to_chat_api))\n\nIn some cases, using a userbot can help overcome restrictions of the Bot API. Please have a look at this [article](http://telegra.ph/How-a-Userbot-superacharges-your-Telegram-Bot-07-09) about userbots.\nNote that userbots are *not* what python-telegram-bot is for.\n\nPlease also note that some methods marked in the Telegram API (aka MTProto) are marked as \"usable for bots\". This does *not* necessarily mean that they can be used directly via the Bot API.\nSee [this GitHub thread](https://github.com/tdlib/telegram-bot-api/issues/1#issuecomment-721873231) and [this discussion](https://github.com/tdlib/telegram-bot-api/issues/62) for more info on that.\n\n### I'm using `ConversationHandler` and want one handler to be run multiple times. How do I do that?\n\nIf your handlers callback returns `None` instead of the next state, you will stay in the current state. That means the next incoming update can be handled by the same callback.\n\n### I want to handle updates from an external service in addition to the Telegram updates. How do I do that?\n\nReceiving updates from an external service, e.g. updates about your GitHub repo, is a common use case.\nOnce you have such an update, you can put them in your bots update queue via `await application.update_queue.put(your_update)`. The `update_queue` is also available as `context.update_queue`.\nNote that `your_update` should *not* need to be an instance of `telegram.Update`, as it does not represent an update sent by Telegram. On the contrary, `your_update` can be any type of a Python object. You can e.g. write your own custom class to represent an update from your external service.\nTo actually do something with the update, you can register a [`TypeHandler`](https://python-telegram-bot.readthedocs.io/telegram.ext.typehandler.html). [`StringCommandHandler`](https://python-telegram-bot.readthedocs.io/telegram.ext.stringcommandhandler.html) and [`StringRegexHandler`](https://python-telegram-bot.readthedocs.io/telegram.ext.stringregexhandler.html) might also be interesting for some use cases.\n\nBut how to get the updates into your bot process?\nFor many cases a simple approach is to check for updates every x seconds. You can use the [`JobQueue`](Extensions---JobQueue) for that.\nIf you can get the updates via a webhook, you can implement a custom webhook that handles both the Telegram and your custom updates. Please have a look at [`customwebhookbot.py`](https://docs.python-telegram-bot.org/en/stable/examples.html#examples-customwebhookbot) example that showcases how that can be done.\nIf your third-party service requires some other setup for fetching updates, that surely also be combined with PTB. Keep in mind that you basically only need access to the `(application/context).update_queue`.\n\n### Why am I getting `ImportError: cannot import name 'XY' from 'telegram'`?\n\nThere are three common reasons for this kind of exception:\n\n1. You installed `pip install telegram` instead of `pip install python-telegram-bot`. Run `pip uninstall telegram` to uninstall the [telegram library](https://pypi.org/project/telegram/) and then run `pip install python-telegram-bot` again.\n2. You have a file named `telegram.py` or a directory/module named `telegram` in your working directory. This leads to namespace issues.\nRename them to something else.\n3. You have misconfigured your python path/environment. Please check that the location listed in `pip show python-telegram-bot` is in your [`PYTHONPATH`](https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH), or your [`sys.path`](https://docs.python.org/3/library/sys.html#sys.path). If not, then you may for e.g. append it to `PYTHONPATH` with `export PYTHONPATH=$PYTHONPATH:/path/to/python-telegram-bot`, or append it to `sys.path` with `sys.path.append('/path/to/python-telegram-bot')`.\n\n### What do the `per_*` settings in `ConversationHandler` do?\n\n`ConversationHandler` needs to decide somehow to which conversation an update belongs.\nThe default setting (`per_user=True` and `per_chat=True`) means that in each chat each user can have its own conversation - even in groups.\nIf you set `per_user=False` and you start a conversation in a group chat, the `ConversationHandler` will also accept input from other users.\nConversely, if `per_user=True`, but `per_chat=False`, its possible to start a conversation in one chat and continue with it in another.\n\n`per_message` is slightly more complicated: Imagine two different conversations, in each of which the user is presented with an inline keyboard with the buttons yes and no.\nThe user now starts *both* conversations and sees *two* such keyboards. Now, which conversation should handle the update?\nIn order to clear this issue up, if you set `per_message=True`, the `ConversationHandler` will use the `message_id` of the message with the keyboard.\nNote that this approach can only work, if all the handlers in the conversation are `CallbackQueryHandler`s. This is useful for building interactive menus.\n\n**Note:** If you have a `CallbackQueryHandler` in your `ConversationHandler`, you will see a warning `If 'per_message=True/False', …`. It is a *warning*, not an error. If you're sure that you set `per_message` to the correct value, you can just ignore it.\nIf you like it better, you can even mute with something like\n\n```python\nfrom warnings import filterwarnings\nfrom telegram.warnings import PTBUserWarning\n\nfilterwarnings(action=\"ignore\", message=r\".*CallbackQueryHandler\", category=PTBUserWarning)\n```\nSee [[this page|Exceptions,-Warnings-and-Logging]] for more info.\n\n### Can I check, if a `ConversationHandler` is currently active for a user?\n\nThere is no built-in way to do that. You can however easily set a flag as e.g. `context.user_data['in_conversation'] = True` in your `entry_points`s and set it to `False` before returning `ConversationHandler.END`.\n\n### How can I list all messages of a particular chat or search through them based on a search query?\n\nThere is no API method for that (see [here](#can-you-add-feature-to-ptb-can-i-do-thing-with-my-bot)). If you really need this functionality, you'll need to save all the messages send to the chat manually. Keep in mind that\n\n1. In group chats your bot doesn't receive all messages, if privacy mode is enabled (see [here](#what-messages-can-my-bot-see))\n2. Messages may be edited (in which case your bot will receive a corresponding update)\n3. Messages may be deleted (and there are no updates for \"message deleted\"!)\n\n### Why am I getting an error `The following arguments have not been supplied`?\n\nThe `callback` method you pass to `JobQueue.run_*` takes exactly *one* argument, which is of type [`CallbackContext`](https://python-telegram-bot.readthedocs.io/en/latest/telegram.ext.callbackcontext.html#telegram-ext-callbackcontext). This is, because jobs are triggered by a schedule and not by an update from Telegram. If you want to access data in the callback that changes at runtime (e.g. because you schedule jobs on demand), you can:\n\n1. Access `context.bot_data`.\n2. Pass [`{user, chat}_id`](https://python-telegram-bot.readthedocs.io/en/latest/telegram.ext.jobqueue.html#telegram.ext.JobQueue.run_once.params.chat_id) to any of the `run_*(...)` methods so you can access them in your `callback` as `context.{user, chat}_data`\n3. Use `run_*(…, data=additional_data)`. It can then be accessed within the `callback` as `context.job.data`. \n\nNote that `context.{user, chat}_data` will be `None`, if you don't pass the arguments `{user, chat}_id` to any of the `run_*(...)` methods.\n\n### How can I check the version of PTB I am using?\n\nThere are three easy ways to do this. Two work from the command line: `pip show python-telegram-bot` or `python -m telegram`. One you run inside a python script (or the python console): `import telegram`, then call `print(telegram.__version__)`.\n\n\n### How do I access info about the message my bot sent?\n\nAll bot methods have a return value. For example to get the `message_id` of a text message sent by your bot, you can do\n\n```python\nmessage = await bot.send_message(…)\nmessage_id = message.message_id\n```\n\nPlease check the docs for details about the return value of each bot method.\n\n### How can I print a table in a Telegram message? Is it a lost cause?\n\nLong story short: yes, it's a lost cause.\nTelegram formatting doesn't support tables and even if you try to get everything aligned with whitespaces and tabs, there WILL be a client that has a different max-widths for the text bubbles or a different font/font size and everything will be messed up. \nIf it's important to you to send a nicely formatted table, send a picture or a pdf.\n\n### Can an `InlineKeyboardButton` have both a URL and `callback-data`?\n\nNo, exactly *one* of the optional arguments of `InlineKeyboardButton` must be set.\nThe closest that you can get to having both a URL and `callback_data` in the button is:\n\n1. have a custom server (e.g. `my.tld`) where you can create redirect-links on the fly - something similar to bitly or all the other link shortening services\n2. each time you want to have both a URL and a `callback_data`, create a new link `my.tld/some_token`\n    1. Make `my.tld/some_token` redirect to the actual URL\n    2. Configure your server such that it sends a notification to your bot telling it that the `my.tld/some_token` was accessed\n3. Make your bot process that information similar to how you'd process a `CallbackQuery`. See also [this FAQ entry](#i-want-to-handle-updates-from-an-external-service-in-addition-to-the-telegram-updates-how-do-i-do-that)\n\n### Why am I suddenly getting so many log entries from `httpx`?\n\nStarting with [v.0.24.1](https://github.com/encode/httpx/releases/tag/0.24.1), `httpx` logs all async requests at `INFO` level, which may be annoying for you as a PTB user.\n\nYou can explicitly set logging level for `httpx` to `WARNING` to get rid of these messages:\n```py\nimport logging\n\nlogging.getLogger(\"httpx\").setLevel(logging.WARNING)\n```\n\n### How can my bot use premium features?\n\nCurrently, Bot API allows only limited premium features to be used by bots, particularly sending custom emojis.\nCustom emoji entities can only be used by bots that purchased additional usernames on [Fragment](https://fragment.com/) in any chat.\nAdditionally, bots can send custom emojis in specific groups without buying additional usernames if that group has sufficient amount of boosts to allow non premium members to send custom emojis from the groups emoji pack. See [formatting options](https://core.telegram.org/bots/api#formatting-options) to know how to send custom emojis if your bot fulfills the necessary conditions."
    },
    {
        "name": "Frequently-requested-design-patterns.md",
        "description": "This page is a collection of sorts, dedicated to showcase design patterns we get asked about often in our support group.\n\n- [Requirements](#requirements)\n- [How to handle updates in several handlers](#how-to-handle-updates-in-several-handlers)\n  - [Type Handler and Groups](#type-handler-and-groups)\n  - [Boilerplate Code](#boilerplate-code)\n    - [But I do not want a handler to stop other handlers](#but-i-do-not-want-a-handler-to-stop-other-handlers)\n  - [How do I limit who can use my bot?](#how-do-i-limit-who-can-use-my-bot)\n  - [How do I rate limit users of my bot?](#how-do-i-rate-limit-users-of-my-bot)\n  - [Conclusion](#conclusion)\n- [How do I enforce users joining a specific channel before using my bot?](#how-do-i-enforce-users-joining-a-specific-channel-before-using-my-bot)\n- [How do I send a message to all users of the bot?](#how-do-i-send-a-message-to-all-users-of-the-bot)\n- [How do I deal with a media group?](#how-do-i-deal-with-a-media-group)\n  - [Timer based approach](#timer-based-approach)\n  - [Manual approach](#manual-approach)\n- [Running PTB alongside other `asyncio` frameworks](#running-ptb-alongside-other-asyncio-frameworks)\n- [How to deal with multiple CBQ from one button](#how-to-deal-with-multiple-CBQ-from-one-button)\n\n## Requirements\n\nKnowing how to make bots with PTB is enough. That means you should be familiar with Python and with PTB.\nIf you haven't worked on anything with PTB, then please check [Introduction to the API](../Introduction-to-the-API) as well as the [Tutorial: Your first Bot](https://github.com/python-telegram-bot/python-telegram-bot/wiki/Extensions---Your-first-Bot).\n\n## How to handle updates in several handlers\n\nAt some point developing one's bots, most of us face the following question\n\n> How do I handle an update _before_ other handlers?\n\n<!-- Im sorry, I love the section, but I don't think it fits in the wiki site, because it is designed a bit more dense. Sorry!\nThis guide is written as a kick-starter to help you in tackling the above mentioned and similar use cases.\nIf you are looking an answer for:\n\n- How to prevent a set of users/groups from accessing my bot?\n- How to control flooding of my bot?\n- I want my bot to process every update in addition to other handlers. How can I do it?\nThen this guide will hint you a possible solution.\n-->\n\nThe following sections will give you an idea how to tackle this problem, based on frequent scenarios where this problem arises.\n\n### Type Handler and Groups\n\nPTB comes with a powerful handler known as [TypeHandler](https://python-telegram-bot.readthedocs.io/telegram.ext.typehandler.html).\nYou can understand it as a generic handler. You can use it to handle any class put through the Updater.\nFor example, Type Handlers are used in bots to handle \"updates\" from Github or other external services.\n\nTo add any handler, we use [Application.add_handler](https://python-telegram-bot.readthedocs.io/telegram.ext.application.html#telegram.ext.Application.add_handler). Apart from the handler itself, it takes an optional argument called `group`. We can understand groups as numbers which indicate the priority of handlers. A lower group means a higher priority. An update can be processed by (at most) one handler in each group.\n\nStopping handlers in higher groups from processing an update is achieved using [ApplicationHandlerStop](https://python-telegram-bot.readthedocs.io/telegram.ext.ApplicationHandlerStop.html#telegram.ext.ApplicationHandlerStop). When raising this exception, the Application is asked to stop sending the updates to handlers in higher groups. Depending on your use case, you may not need to raise it. But it is useful if you want to enable flood handling or limit who can use the bot.\n\nThat's it. With these three knowledge nuggets, we can solve the question given in the introduction.\n\n### Boilerplate Code\n\nBefore working on the problems, we will provide you with a template of code that you can use. All you need to do to follow this guide is change the internals of your `callback` and `group` as required by the problem you face.\n\n```python\nfrom telegram import Update\nfrom telegram.ext import ContextTypes, ApplicationHandlerStop, TypeHandler, Application\n\n\nasync def callback(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Handle the update\"\"\"\n    await do_something_with_this_update(update, context)\n    raise ApplicationHandlerStop # Only if you DON'T want other handlers to handle this update\n\n\napp = Application.builder().token(\"TOKEN\").build()\nhandler = TypeHandler(Update, callback) # Making a handler for the type Update\napp.add_handler(handler, -1) # Default is 0, so we are giving it a number below 0\n# Add other handlers and start your bot.\n```\n\nThe code above should be self-explanatory, provided you read the previous section along with the respective documentation. We made a handler for `telegram.Update` and added it to a lower group.\n\n#### But I do not want a handler to stop other handlers\n\nIn case you don't want to stop other handlers from processing the update, then you should modify your `callback` to not raise the exception.\nThis is a generic use case often used for analytics purpose. For example, if you need to add every user who uses your bot to a database, you can use this method. Simply put, this sort of approach is used to keep track of every update.\n\n```python\nasync def callback(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    add_message_to_my_analytics(update.effective_message)\n    add_user_to_my_database(update.effective_user)\n```\n\nNote the difference in this example compared to the previous ones. Here we don't raise `ApplicationHandlerStop`. These type of handlers are known as _shallow handlers_ or _silent handlers_. These type of handlers handle the update and also allow it to be handled by other common handlers like `CommandHandler` or `MessageHandler`. In other words, they don't block the other handlers.\n\nNow let us solve the specific use cases. All you need to do is modify your `callback` as required. 😉\n\n### How do I limit who can use my bot?\n\n> Please be sure to start reading this section from the [top](#how-to-handle-updates-in-several-handlers).\n\nTo restrict your bot to a set of users or if you don't want it to be available for a specific group of people, you can use a `callback` similar to the following. Remember, the process is same if you want to enable/disable the bot for groups or channels.\n\n```python\nSPECIAL_USERS = [127376448, 172380183, 1827979793]  # Allows users\n\nasync def callback(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    if update.effective_user.id in SPECIAL_USERS:\n        pass\n    else:\n        await update.effective_message.reply_text(\"Hey! You are not allowed to use me!\")\n        raise ApplicationHandlerStop\n```\n\n> [!TIP]\n> Here, it should be noted that this approach blocks your bot entirely for a set of users. If all you need is to block a specific functionality, like a special command or privilege, then it will be wise to use [filters.Chat](https://python-telegram-bot.readthedocs.io/telegram.ext.filters.html#telegram.ext.filters.Chat), [filters.User](https://python-telegram-bot.readthedocs.io/telegram.ext.filters.html#telegram.ext.filters.User).\nDon't forget that you can also use [decorators](https://github.com/python-telegram-bot/python-telegram-bot/wiki/Code-snippets#restrict-access-to-a-handler-decorator) or a simple `if-else` check.\nIf you want a more streamlined style of managing permissions (like superuser, admin, users) then [ptbcontrib/roles](https://github.com/python-telegram-bot/ptbcontrib/tree/main/ptbcontrib/roles) is worth checking out.\n\n### How do I rate limit users of my bot?\n\n> Please be sure to start reading this section from the [top](#how-to-handle-updates-in-several-handlers).\n\nThe exact definition of _rate limit_ depends on your point of view. You typically should keep record of previous usage of the user and warn them when they cross a limit. Here, for demonstration, we use a method that restricts the usage of the bot for 5 minutes.\n\n```python\nfrom time import time\n\nMAX_USAGE = 5\n\n\nasync def callback(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    count = context.user_data.get(\"usageCount\", 0)\n    restrict_since = context.user_data.get(\"restrictSince\", 0)\n\n    if restrict_since:\n        if (time() - restrict_since) >= 60 * 5: # 5 minutes\n            del context.user_data[\"restrictSince\"]\n            del context.user_data[\"usageCount\"]\n            await update.effective_message.reply_text(\"I have unrestricted you. Please behave well.\")\n        else:\n            await update.effective_message.reply_text(\"Back off! Wait for your restriction to expire...\")\n            raise ApplicationHandlerStop\n    else:\n        if count == MAX_USAGE:\n            context.user_data[\"restrictSince\"] = time()\n            await update.effective_message.reply_text(\"Stop flooding! Don't bother me for 5 minutes...\")\n            raise ApplicationHandlerStop\n        else:\n            context.user_data[\"usageCount\"] = count + 1\n```\n\nThe approach we used is dead lazy. We keep a count of updates from the user and when it reaches maximum limit, we note the time. We proceed to stop handling the updates of that user for 5 minutes. Your effective flood limit strategy and punishment may vary. But the logic remains same.\n\n> [!TIP]\n> If you don't need to reply to the update directly and/or only want to delay the updates before being processed, you can also do that *before* any of the handlers are triggered. PTB allows customizing how the `Application` processes updates via the [`BaseUpdateProcessor`](https://docs.python-telegram-bot.org/telegram.ext.baseupdateprocessor.html) class. Please also have a look at [this wiki page](https://github.com/python-telegram-bot/python-telegram-bot/wiki/Concurrency#applicationconcurrent_updates).\n\n### Conclusion\n\nWe have seen how `TypeHandler` can be used to give a fluent experience without messing up our code-base. Now you would be able to solve complex use cases from the given examples. But please note that `TypeHandler` **is not** the only option.\nIf you feel like this approach is too much of trouble, you can use Python's inbuilt [decorators](https://github.com/python-telegram-bot/python-telegram-bot/wiki/Code-snippets#restrict-access-to-a-handler-decorator).\n\n## How do I enforce users joining a specific channel before using my bot?\n\nAfter sending an (invite) link to the channel to the user, you can use [`Bot.get_chat_member`](https://python-telegram-bot.readthedocs.io/telegram.bot.html#telegram.Bot.get_chat_member) to check if the user is an that channel.\nNote that:\n\n- the bot needs to be admin in that channel\n- the user must have started the bot for this approach to work. If you try to run `get_chat_member` for a user that has not started the bot, the bot can not find the user in a chat, even if it is a member of it.\n\nOtherwise depending on whether the user in the channel, has joined and left again, has been banned, ... (there are multiple situations possible), the method may\n\n- raise an exception and in this case the error message will probably be helpful\n- return a [`ChatMember`](https://python-telegram-bot.readthedocs.io/telegram.chatmember.html#telegram.ChatMember) instance. In that case make sure to check the [`ChatMember.status`](https://python-telegram-bot.readthedocs.io/telegram.chatmember.html#telegram.ChatMember.status) attribute\n\nSince API 5.1 (PTB v13.4+) you can alternatively use the [`ChatMember`](https://python-telegram-bot.readthedocs.io/telegram.chatmemberupdated.html) updates to keep track of users in channels. See [`chatmemberbot.py`](https://docs.python-telegram-bot.org/examples.html#examples-chatmemberbot) for an example.\n\nIf the user has not yet joined the channel, you can ignore incoming updates from that user or reply to them with a corresponding warning. A convenient way to do that is by using [TypeHandler](https://python-telegram-bot.readthedocs.io/telegram.ext.typehandler.html). Read this [section](#how-do-i-limit-who-can-use-my-bot) to learn how to do it.\n\n## How do I send a message to all users of the bot?\n\nLet's first point out an easy alternative solution: Instead of sending the messages directly through your bot, you can instead set up a channel to publish the announcements. You can link your users to the channel in a welcome message.\n\nIf that doesn't work for you, here we go:\n\nTo send a message to all users, you of course need the IDs of all the users. You'll have to keep track of those yourself. The most reliable way for that are the [`my_chat_member`](https://python-telegram-bot.readthedocs.io/telegram.chatmemberupdated.html) updates. See [`chatmemberbot.py`](https://docs.python-telegram-bot.org/examples.html#examples-chatmemberbot) for an example on how to use them.\n\nIf you didn't keep track of your users from the beginning, you may have a chance to get the IDs anyway, if you're using persistence. Please have a look at [this issue](https://github.com/python-telegram-bot/python-telegram-bot/issues/1836) in that case.\n\nEven if you have all the IDs, you can't know if a user has blocked your bot in the meantime. Therefore, you should make sure to wrap your send request in a `try-except` clause checking for [`telegram.error.Forbidden`](https://python-telegram-bot.readthedocs.io/telegram.error.html#telegram.error.Forbidden) errors.\n\nFinally, note that Telegram imposes some limits that restrict you to send ~30 Messages per second. If you have a huge user base and try to notify them all at once, you will get flooding errors. To prevent that, try spreading the messages over a long time range. To achieve that you can use e.g.\n\n* the [`JobQueue`](https://github.com/python-telegram-bot/python-telegram-bot/wiki/Extensions---JobQueue)\n* PTBs mechanism to [avoid flood limits](https://github.com/python-telegram-bot/python-telegram-bot/wiki/Avoiding-flood-limits)\n\n> [!Tip]\n> With [Bot API 7.1](https://core.telegram.org/bots/api-changelog#october-31-2024) ([PTB v27.1](https://docs.python-telegram-bot.org/en/v21.7/changelog.html#version-21-7)), Telegram introduced the parameter [`allow_paid_broadcast`](https://docs.python-telegram-bot.org/en/v21.7/telegram.bot.html#telegram.Bot.send_message.params.allow_paid_broadcast).\n> This allows bots to send up to 1000 messages per second by paying a fee in Telegram Stars.\n\n## How do I deal with a media group?\n\nThe basic problem behind this question is simple. For the end user, it looks like one message, consisting of several medias, are sent to the receiver. For the bot API/bot developer, this is not the case however: Every media is send as one unique message, only linked via the unique [Message.media_group_id](https://python-telegram-bot.readthedocs.io/telegram.message.html#telegram.Message.media_group_id) attribute. So you need some way of determining when to start and to end collecting the media messages.\n\nThis basic problem has two basic approaches for handling it, without requiring a more elaborate setup involving databases. We details them below.\n\nThe good news is: Once you have all the media messages, forwarding them in a batch can simply done with [`Bot.forward_messages`](https://docs.python-telegram-bot.org/en/stable/telegram.bot.html#telegram.Bot.forward_messages).\n\n### Timer based approach\n\n[Real life code example.](https://github.com/Poolitzer/channelforwarder/blob/43086851e5a2274128cf8d82146b348cad78e647/main.py#L47C1-L91C14)\n\nThis approach has the upside of looking seamless to the user. The downside is that there is a (low) possibility that one part of the media group is missed.\n\nThe idea behind this approach is to start a timer (and an array with the message object/id in it) when receiving the first media_group message. Until the timer runs out, every incoming message with the same media id will be added to the array. Once the timer runs out, the media group is considered done and can be dealt with according to your situation.\n\nThere is a possibility that a part of the media group is received after the timer ran out. This could be because the network was too slow to deliver the updates to you (more likely with a webhook setup since long polling can receive multiple updates at once) or your server took to long to deal with the update (or a combination of both). The result of this happening need to be determined by you.\n\n### Manual approach\n\n```diff\n- Real life code example TBD\n```\n\nThis approach has two upsides: You don't force users to use media groups (so they can e.g. send more media then fits in one group) and you will not miss a media. The downside is that it requires manual interaction from users, and we all know how special users can be :)\n\nThe idea behind this approach is to start a upload segment in your code. Either in a `ConversationHandler` or with a `CommandHandler`. Ask the user then to send all medias. Once they send the first (or the first media group, this doesn't matter in your code), you store the information you need in an array. Then you ask them to send either more or send a command like `/finish` / a specific text message you intercept with a [MessageHandler + regex Filter](../Types-of-Handlers#pattern-matching-filtersregex). The point behind this is to have the user finish the addition of media on their own terms. Once they triggered the second handler, you can consider the array finished.\n\n## Running PTB alongside other `asyncio` frameworks\n\nThe [tutorial](https://github.com/python-telegram-bot/python-telegram-bot/wiki/Extensions---Your-first-Bot) as well (almost) all the [examples](https://docs.python-telegram-bot.org/examples.html#examples-chatmemberbot) make use of [`Application.run_polling`](https://docs.python-telegram-bot.org/telegram.ext.application.html#telegram.ext.Application.run_polling).\nThis method is blocking, which means that no other `asyncio` related code can be started while it is running.\nThis is okay as long your Python script runs only your bot.\nHowever, if you want to run multiple bots in the same Python script or other `asyncio` frameworks (e.g. a webserver) alongside your bot, this becomes an issue.\n\nThe `Application` class was designed with these use cases in mind and `Application.run_polling` can be understood as mainly a  convenience method for the important use case of running \"just\" a single bot.\nThe same holds for `Application.run_webhook.`\n\nWithout using `Application.run_{webhook, polling}`, the overall logic of startup and shutdown of the `Application` is as follows:\n\n```python\napplication = ApplicationBuilder().token(\"TOKEN\").build()\n\nasync def main():\n    await application.initialize()\n    await application.start()\n    await application.updater.start_{webhook, polling}()\n    # Start other asyncio frameworks here\n    # Add some logic that keeps the event loop running until you want to shutdown\n    # Stop the other asyncio frameworks here\n    await application.updater.stop()\n    await application.stop()\n    await application.shutdown()\n```\n\nSeveral things to note here:\n\n* Of course, the \"other `asyncio` framework\" could be another `Application`, i.e. a second bot that you want to run in the same Python script.\n* The important part is that `Application.initialize`, `Application.start`, `Updater.start_{webhook, polling}`, `Application.stop` and `Application.shutdown` are called in the shown order. How exactly this is done is up to you. E.g. it may be beneficial to use `loop.run_until_complete` instead of `await`-ing the coroutines.\n* Instead of calling `Application.{initialize, shutdown}`, you can also use the application as a context manager, i.e.\n  ```python\n  application = ApplicationBuilder().token(\"TOKEN\").build()\n  \n  async def main():\n      async with application:  # Calls `initialize` and `shutdown`\n          await application.start()\n          await application.updater.start_{webhook, polling}()\n          # Start other asyncio frameworks here\n          # Add some logic that keeps the event loop running until you want to shutdown\n          # Stop the other asyncio frameworks here\n          await application.updater.stop()\n          await application.stop()\n  ```\n* Clean startup, execution and shutdown of `asyncio` processes is not a trivial topic, there are many approaches to this and probably just as many opinions on which is the best.\n  Covering this topic is out of scope for this wiki.\n  The important point however is that there is not a single \"right\" way to do this - for PTB or in general.\n  In particular the part where you have to keep the event loop running can take differnt form depending on your use case, your personal preferences and the frameworks you use.\n  If you are interested, we invite you to have a look at the [source code](https://github.com/python-telegram-bot/python-telegram-bot/blob/master/telegram/ext/_application.py) of the `Application.run_{webhook, polling}` methods to see how PTB handles this.\n* Shutdown logic of `asyncio` processes may involve any pending `asyncio.Tasks` by cancelling all tasks returned by `asyncio.all_tasks`. This should be done only *after* `Application.stop` was called, since `Application.start` starts `asyncio.Tasks` in the background that should be allowed to finish.\n* Calling `application.updater.start_{webhook, polling}` is not mandatory.\n  In fact, using PTBs `Updater` for fetching updates from Telegram is optional, and you can use a custom implementation instead, if you like (see [[this wiki page|Architecture]] for details).\n  The [`customwebhookbot`](https://docs.python-telegram-bot.org/examples.html#examples-customwebhookbot) example showcases this use case, which also involves manually starting and stopping the application. Keeping the event loop running is covered by the `uvicorn` framework in this example.\n\n## How to deal with multiple CBQ from one button\nA common design is to have an inline keyboard and on pressing the button, edit the message to have this button vanish. Short example:\n\n```python\nimport asyncio\nfrom telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update\nfrom telegram.ext import Application, CallbackQueryHandler, CommandHandler, ContextTypes\n\n\nasync def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Sends a message with an inline buttons attached.\"\"\"\n    keyboard = [[InlineKeyboardButton(\"Button To Vanish\", callback_data=\"1\")]]\n    await update.message.reply_text(\n        \"Spam it\", reply_markup=InlineKeyboardMarkup(keyboard)\n    )\n\n\nasync def button(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Parses the CallbackQuery and updates the message text.\"\"\"\n    query = update.callback_query\n    await query.answer()\n    # long wait for something\n    await asyncio.sleep(5)\n    await query.edit_message_text(text=f\"You did it\")\n\n\ndef main() -> None:\n    \"\"\"Run the bot.\"\"\"\n    application = Application.builder().token(\"TOKEN\").build()\n    application.add_handler(CommandHandler(\"start\", start))\n    application.add_handler(CallbackQueryHandler(button))\n    application.run_polling()\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\nAs you can see, the button has to wait for 5 seconds, which allows impatient users to spam the button. This results in multiple callback query updates from this button, even though (without the sleep call) you might expect just one CBQ update from it. All \"duplicate\" updates from the button will result in a _BadRequest_, because the message content is the same one as the previous (it was already edit to \"You did it\" and the code tries to edit it to the same text again).\n\nThe solution to this problem is to keep track independently if the message was already edited. Thanks to user data, this is achieved quite easily:\n```python\n\nasync def button(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    \"\"\"Parses the CallbackQuery and updates the message text.\"\"\"\n    query = update.callback_query\n    unique_data = query.data + (\n        query.inline_message_id\n        if query.inline_message_id\n        else str(query.message.message_id)\n    )\n    if (\"last_cbq\" not in context.user_data or\n        context.user_data[\"last_cbq\"] != unique_data):\n        context.user_data[\"last_cbq\"] = unique_data\n    else:\n        # answer to other calls, even if you ignore them\n        await query.answer()\n        return\n    await query.answer()\n    # long wait for something\n    await asyncio.sleep(5)\n    await query.edit_message_text(text=f\"You did it\")\n```\nThis setup has two downsides:\n1. You have to write this in the beginning of each CBQ handler. You can either use a [decorators](https://github.com/python-telegram-bot/python-telegram-bot/wiki/Code-snippets#restrict-access-to-a-handler-decorator) or a [separate handler](#how-to-handle-updates-in-several-handlers) to avoid this.\n1. You can not edit in a button with the same callback data as the previous one in the same message.\n\nIf you remember the last point, you will not face any issues with this solution however."
    },
    {
        "name": "Handling-network-errors.md",
        "description": "# Background\nNetwork errors can happen at many levels, on the local side, on the remote or somewhere along the way.\n\nIt is hard for applications to identify when an error occurs as it is not always something that can be identified in real time but rather when an additional event happens.\n\nNetwork errors are a problem which each application have to deal with. Each application for its own use case and desired service level. \n\n# Where things can break?\n## Locally (in PTB)\nFor something to \"break\" locally we need to close the network socket. This is something that PTB doesn't do voluntarily and basically if you've encountered such a case, it's a bug.\n\n## Remotely on Telegram servers\nThere is a suspicion that Telegram are closing connections on some conditions. Whether it is true or not we can't really tell. The application should still be able to deal with it.\n\n## Somewhere along the way\n* A flaky network connection can cause connections to seem alive, although they are useless.\n* Datacenters or ISPs which cut (probably inactive) network connections.\n  * Azure drops inactive connections after 4 minutes by default (https://azure.microsoft.com/en-us/blog/new-configurable-idle-timeout-for-azure-load-balancer/).\n\n# How to mitigate?\n\n## Analysis\nThere is no one way to handle networking issues. Each bot has its own usage pattern and unique network behaviour.\n\nSome bots will require providing answer to user requests within a limited time, while others can take all the time they need.\nSome bots will be ok with \"losing\" a sent message once in a while, while others must ensure that the message was sent within a limited time frame.\nSome bots send big files, while others only receive small files. Etc., etc.\n\nIn addition, the network connection takes an important factor. Hosting your bot in a region with poor Internet (bandwidth / packet lost / disconnections) is the obvious example, but it is not the only problem.\nIn case the bot is hosted \"far\" from the Telegram Bot servers you'll experience greater latency and possibly more packet loss. TCP should be able to handle packet loss, however, there are side effects for that (when will TCP identify the loss of a packet? what will be the window size? etc.).\n\nHosting the bot on a slow server can also affect performance and may be observed as networking issues.\n\nOnce you've understood the usage pattern of your bot (that includes the QoS) you can go into fine-tuning the ptb library for your needs.\n\n## Tweaking PTB\n### Networking backend tweaks\n\nPTB performs HTTPS requests using the `telegram.request.BaseRequest` interface.\nThe method `BaseRequest.do_request` accepts four parameters for controlling timeouts:\n\n* `read_timeout` specifies the maximum amount of time (in seconds) to wait for a response from Telegram’s server\n* `write_timeout` specifies the maximum amount of time (in seconds) to wait for a write operation to complete (in terms of a network socket; i.e. POSTing a request or uploading a file)\n* `connect_timeout` specifies the maximum amount of time (in seconds) to wait for a connection attempt to a Telegram server\n* `pool_timeout` specifies the maximum amount of time (in seconds) to wait for a connection to become available from the connection pool\n\nThe built-in `request.HTTPXRequest` (which implements `BaseRequest`) uses a default of 5 seconds for `{read, write, connect}_timeout` and 1 second for `pool_timeout`.\n\nThe `write_timeout` is overwritten to 20 seconds when using send methods which attach files (`send_audio`, `send_document`, etc.).\nWhen sending big files, calling `Bot.send_*(write_timeout=BIGGER_VALUE)` might be a good idea.\n\nWhen using the standard `HTTPXRequest`, changing the defaults of `{read, write, connect, pool}_timeout` & `connect_timeout` is done when initializing the `Application`.\n\n```python\nApplication.builder().token(\"Token\").read_timeout(7).get_updates_read_timeout(42).build()\n```\n\nNote that there is both `ApplicationBuilder.read_timeout()` and `ApplicationBuilder.get_updates_read_timeout` (and similarly for the other timeouts) since PTB uses two different request objects for `Bot.get_updates` and all other bot methods.\n\nSee also the wiki page on the [[builder pattern|Builder-Pattern]].\n\n### `Bot.get_updates`\nWhen using `Application.run_polling()`/`Updater.start_polling()`, `getUpdates` is achieved using [Long Polling](https://en.wikipedia.org/wiki/Push_technology#Long_polling).\nThis means that the `get_updates` request is kept alive for  a [(Telegram defined) timeout](https://core.telegram.org/bots/api#getupdates) of X seconds to respond with new `Update`(s).\nOnly if updates are available before the X seconds have passed, the request is closed right away and `get_updates` is called again.\nThis also means that if a network error occurs during that timeout, it will be discovered only after the timeout has passed.\n\nTo be specific, when using the raw API (i.e. using `Bot` directly), the value you pass for `timeout` is added to the value of `read_timeout` and that is the exact timing when the error will be detected.\nIn that mode, the default value of `timeout` is 0 and the default value of `read_timeout` is 2.\n\nIf you're using `Updater.start_polling`/`Application.run_polling()` then the default value of `timeout` is overridden to 10. That means that the average time to identify network error is 6 seconds. \n\nDepending on the SLA you'd like to provide, if you suffer from frequent errors during `getUpdates` consider lowering the `timeout` value to catch the errors faster.\nPlease take in mind that too short polling intervals may have undesirable side effects:\n* Telegram servers might conceive it as abusive and block your bot.\n* Increase the load on your server and network connection.\n\n### Socket options\nDepending on your OS you may be able to set socket options to perform low level tweaks.\nIn the default networking backend, [`HTTPXRequest`](https://docs.python-telegram-bot.org/telegram.request.httpxrequest.html), there is a corresponding parameter for this.\n\n## Stabilizing your app\n\nWhen a network error occurs, be prepared to catch the [raised exception](https://python-telegram-bot.readthedocs.io/telegram.error.html) and handle it according to your policy (do you want to retry? ignore? other?) or use PTBs built-in mechanism for [[exception handling|Exceptions,-Warnings-and-Logging]]. Note that for (network) errors that happen as part of [`Application.run_polling`](https://docs.python-telegram-bot.org/en/stable/telegram.ext.application.html#telegram.ext.Application.run_polling)/[`Updater.start_polling`](https://docs.python-telegram-bot.org/en/stable/telegram.ext.updater.html#telegram.ext.Updater.start_polling) are *also* processed via [`Application.process_error`](https://docs.python-telegram-bot.org/en/stable/telegram.ext.application.html#telegram.ext.Application.process_error).\n\n## PTB\nIf you think of another way to improve stability from within ptb, please contact us (the maintainers)."
    },
    {
        "name": "Home.md",
        "description": "[![Logo](https://github.com/python-telegram-bot/logos/raw/master/logo-text/png/ptb-logo-text_768.png)](https://python-telegram-bot.org/)\n\n# Working with PTB\n\n## Quick Start\n\nOur Wiki (where you currently are) contains an [Introduction to the API](https://github.com/python-telegram-bot/python-telegram-bot/wiki/Introduction-to-the-API) explaining how the pure Bot API can be accessed via `python-telegram-bot`.\nMoreover, the [Tutorial: Your first Bot](https://github.com/python-telegram-bot/python-telegram-bot/wiki/Extensions---Your-first-Bot) gives an Introduction on how chatbots can be easily programmed with the help of the `telegram.ext` module.\n\n## Resources\n\n-   The [package documentation](https://docs.python-telegram-bot.org/) is the technical reference for `python-telegram-bot`.\n    It contains descriptions of all available classes, modules, methods and arguments as well as the [changelog](https://docs.python-telegram-bot.org/changelog.html).\n-   The [wiki](https://github.com/python-telegram-bot/python-telegram-bot/wiki/) is home to number of more elaborate introductions of the different features of `python-telegram-bot` and other useful resources that go beyond the technical documentation.\n    See [below](#structure-of-this-wiki) for more details on what this wiki contains.\n-   Our [examples section](https://docs.python-telegram-bot.org/examples.html) contains several examples that showcase the different features of both the Bot API and `python-telegram-bot`.\n    Even if it is not your approach for learning, please take a look at `echobot.py`.\n    It is the de facto base for most of the bots out there.\n    The code for these examples is released to the public domain, so you can start by grabbing the code and building on top of it.\n-   The [official Telegram Bot API documentation](https://core.telegram.org/bots/api) is of course always worth a read.\n\n## Getting help\n\nIf the resources mentioned above don't answer your questions or simply overwhelm you, there are several ways of getting help.\n\n1.  We have a vibrant community of developers helping each other in our [Telegram group](https://telegram.me/pythontelegrambotgroup).\n    Join us! Asking a question here is often the quickest way to get a pointer in the right direction.\n2.  Ask questions by opening [a discussion](https://github.com/python-telegram-bot/python-telegram-bot/discussions/new).\n3.  You can even ask for help on Stack Overflow using the [python-telegram-bot tag](https://stackoverflow.com/questions/tagged/python-telegram-bot).\n\n## Structure of this Wiki\n\nIn the sidebar to the right, you can find all important pages of this wiki. They are roughly organized by the following logic:\n\n* **Must read:** Introductory articles and frequently referenced pages.\n* **Concepts & Important Elements:** Introductions & explanations of how the components of `telegram.ext` work and interact with each other.\n* **Notable Features:** Elaborate explanation to more advanced features of `telegram.ext`.\n* **Code Resources:** Some other resources that are not exclusively PTB-specific.\n* **Examples Explained:** An effort to make the [examples](https://github.com/python-telegram-bot/python-telegram-bot/tree/master/examples) even more accessible.\n  *You are very welcome to extend this section!*\n* **Networking:** Articles about advanced networking questions.\n* **Other resources:** More interesting & helpful stuff that can't be found in any of the above sections.\n* **Transition Guides:** Major versions usually come with breaking changes, i.e. changes that lead to code failing after upgrading. Those guides help to ease the transition.\n* **Administration:** Interesting mostly for the maintainers. They, too, need a place to take notes 🙂\n\n## Contributing to this Wiki\nIf you stumble upon a part of the wiki that is unclear or missing important points, please go ahead and drop us a message in our [Telegram Group](https://t.me/pythontelegrambotgroup), or just edit the part yourself (anyone can contribute). We'd like our wiki to be as complete as possible 🙂"
    },
    {
        "name": "Hosting-your-bot.md",
        "description": "### Introduction\nYou will need a VPS (or dedicated server) first. Check out the list at [[Where to host Telegram Bots|Where-to-host-Telegram-Bots#vps]] if you don't have one already.\n\n### First login\nYour login details should contain\n- The IP address of your server\n- Your username (usually `root`)\n- Your password\n\nYou should also receive some information on the type of server you got, including Operating System, RAM, storage and monthly traffic.\n\nOnce you received that information, you can connect to the server via SSH. \n\n> Note that although the explanations below mention entering your password, it is strongly recommended to authenticate using a [SSH public key](https://www.ssh.com/academy/ssh/public-key-authentication) instead of the password. You can read [this explanation](https://www.ssh.com/academy/ssh/keygen) on how to generate keys and send the public key to the server, or check your VPS provider's documentation.\n\n#### Linux\nRun the following command in the terminal and replace `<user>` with your username and `<ip>` with your servers IP address:\n\n```\nssh <user>@<ip>\n```\n\nConfirm that you want to trust the host and enter the password if you are asked to do so.\n\n#### Windows\nInstall [puTTY](http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html) and start it. \n\nIn the field *Host Name (or IP address)* enter the IP address of your server. As the connection type, select *SSH* and set *Port* to *22*. You can save these settings my entering a name in the field below *Saved Sessions* and clicking *Save*. Then, click *Open* and enter your username and password when asked to do so.\n\n### Setup\n\nFirst, install the Python package manager `pip`.\n```\napt-get update && apt-get install python3-pip\n```\n\nNow, install the `python-telegram-bot` library:\n```\npip3 install python-telegram-bot\n```\n\nFinally, confirm the installation:\n```\npython3 -c \"import telegram;print(telegram.__version__)\"\n```\n\nOf course, this is the easy way; the correct way (especially if you have multiple Python projects on your server) is to install a **virtual environment** (like `pipenv` or `poetry`) first.\n\n### Upload your bot's files\nNow you can upload your bot to the server. There are multiple ways to do that, one way is to use [FileZilla](https://filezilla-project.org/download.php?type=client). Install it (if you're on Linux, chances are you already have it) and start it. Open the *Server Manager* and create a new server with the button on the left. Give it a nice name, then go to the right and fill in the fields:\n\n- *Server:* Your servers IP address\n- *Port:* 22\n- *Protocol:* SFTP\n- *Connection type:* Normal\n- *Username:* Your username\n- *Password:* Your password\n\nNow, click *Connect*. You will probably see the `/root` directory (your user's home directory) on the right and your local files on the left. Create a directory for your bot and upload all the files needed by your bot into that directory.\n\n### Start your bot\nTo run your bot, connect to your server again via SSH (or go back to the connection) and `cd` into the directory you created. You could now immediately start the bot, but then it would stop working once you disconnect from the server. There are again several ways to make sure that doesn't happen:\n\n1. Use a terminal multiplexer like `screen` or `tmux`.\n2. Run your bot as a systemd service.\n\n#### Running your bot in a terminal multiplexer\n\n`screen` is called a \"terminal multiplexer\". It creates *virtual terminals* that you can attach to and detach from and that can run processes without you being logged in.\n\nCreate a new *screen* and attach to it:\n```\nscreen -S mybot\n```\n\nStart the bot:\n```\npython3 bot.py\n```\n\nDetach from the *screen* by holding <kbd>CTRL</kbd> and pressing <kbd>A</kbd>, then <kbd>D</kbd>. You can now disconnect from the server by typing `exit` if you want. \n\nTo re-attach to the *screen* after you logged back in:\n```\nscreen -r mybot\n```\nor\n```\nscreen -d -r mybot\n```\n\nA known alternative to `screen` is [`tmux`](https://github.com/tmux/tmux/wiki).\n\n#### Running your bot as a systemd service\n\nChoosing this option will mean that your Python program will be running in the background. Another upside to this option is that you can set it up to start at system boot, which means that if you reboot your server (e.g. to apply system upgrades), your bot will start automatically afterwards.\n\n1. Install [`python-dotenv`](https://pypi.org/project/python-dotenv/).\n2. Create the `.env` file and put your bot-related environment variables in there (you didn't put your bot token right into your code, hopefully!). If you're using Git, make sure `.env` is in `.gitignore` so it doesn't get checked in.\n3. Follow e.g. [this tutorial](https://blog.abhinandb.com/run-any-executable-as-systemd-service/) to run your Python script as a service. If you're using a virtual environment (see [this external article](https://docs.python-guide.org/dev/virtualenvs/) for details), you have to locate the Python executable first. To do that, activate the virtual environment on the remote server and enter `which python` in your bash console. You will get a path to the Python instance you will need to use when configuring systemd.\n\nSteps 1 and 2 are optional if you're not using any virtual environment, but it's better to go through them anyway because if you set the environment variables manually, they will be lost after system reboot.\n\n## What to read next?\nIf you plan on hosting multiple bots on your server, it's recommended to use `virtualenv`. It allows you to install and upgrade Python modules via `pip` for one project, without worrying how it affects other projects on the server. Read [this external article](http://docs.python-guide.org/dev/virtualenvs/) for more information.\n\nLearn about how to use a webhook for your bot in [[this article|Webhooks]].\n\nYou might also read the article on [[Performance Optimizations|Performance-Optimizations]] if you didn't read it yet."
    },
    {
        "name": "InlineKeyboard-Example.md",
        "description": "# Introduction\nHey, this wiki page will walk you through the inline keyboard example found [here](../blob/master/examples/inlinekeyboard.py). We will start with how python starts with the example, then follow through the code in the same way we expect updates from the user would go through it. Let's do it.\n\n_Disclaimer: We will conveniently ignore the imports._\n## Startup\n\n```python\nif __name__ == '__main__':\n    main()\n```\n[Lines 68 to 69](../blob/master/examples/inlinekeyboard.py#L68-L69) tell python that after starting the script, it's supposed to call the main function\n## main\n\n```python\napplication = Application.builder().token(\"TOKEN\").build()\n```\n[The first line](../blob/master/examples/inlinekeyboard.py#L58) in the main function builds an application instance from the [Application class](https://docs.python-telegram-bot.org/telegram.ext.application.html). The function calls lined up after another means that the calls happen on the return of the previous call. So `.builder()` is called on `Application`, `.token(\"TOKEN\")` on the return of `.builder()`, `.build()` on whatever `.token(\"TOKEN\")` returns. If you check the docs, you will find that [builder](https://docs.python-telegram-bot.org/telegram.ext.application.html#telegram.ext.Application.builder) returns an [ApplicationBuilder instance](https://docs.python-telegram-bot.org/en/stable/telegram.ext.applicationbuilder.html). So looking there for [token](https://docs.python-telegram-bot.org/telegram.ext.applicationbuilder.html#telegram.ext.ApplicationBuilder.token), we find that it also returns an (updated) `ApplicationBuilder` instance, which is the same for almost every method on that page. This allows this chaining of function calls, since all the function are defined inside the `ApplicationBuilder` and it is always returned. Finally, the `.build()` builds and then returns the application instance we expect.\n\n```python\napplication.add_handler(CommandHandler(\"start\", start))\napplication.add_handler(CallbackQueryHandler(button))\napplication.add_handler(CommandHandler(\"help\", help_command))\n```\n[Line 60 to 62](../blob/master/examples/inlinekeyboard.py#L60-L62) registers our three handlers. The first handler is a [CommandHandler](https://python-telegram-bot.readthedocs.io/telegram.ext.commandhandler.html). Whenever a user sends a /start command to the bot, the function `start` is called. Same situation with the third handler: Whenever a user sends the /help command, `help_command` gets called.\n\nThe second handler is a [CallbackQueryHandler](https://docs.python-telegram-bot.org/telegram.ext.callbackqueryhandler.html). A [Callbackquery](https://docs.python-telegram-bot.org/telegram.callbackquery.html) is what Telegram sends to our bot when a user presses an [InlineButton](https://docs.python-telegram-bot.org/telegram.inlinekeyboardbutton.html). Every press of a button gets sent to the `button` handler.\n\n```python\napplication.run_polling()\n```\n[Line 65](../blob/master/examples/inlinekeyboard.py#L65) tells the PTB library to start the bot using polling, which means that the library will continuously make a request to the telegram servers and get new updates from there, if they exists.\n\n\nLet's start our way through the handlers in the same way we would expect a user to go through it. This means we begin with the start handler:\n## start\n\n```python\nasync def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n```\nIn [line 24](../blob/master/examples/inlinekeyboard.py#L24) we define a function called start. It is an async function and it takes the two arguments update (instance of an [Update](https://docs.python-telegram-bot.org/telegram.update.html)) and context (instance of a [CallbackContext](https://docs.python-telegram-bot.org/telegram.ext.callbackcontext.html)). The context is the default context type, since we didn't change anything with it. If you want to see how that works, checkout the [ContextType bot example](../blob/master/examples/contexttypesbot.py). The `-> None` indicates to a type checker that this function returns nothing.\n\n```python\nkeyboard = [\n    [\n        InlineKeyboardButton(\"Option 1\", callback_data='1'),\n        InlineKeyboardButton(\"Option 2\", callback_data='2'),\n    ],\n    [InlineKeyboardButton(\"Option 3\", callback_data='3')],\n]\n\n```\n[Line 26 to 32](../blob/master/examples/inlinekeyboard.py#L26-L32) a variable called keyboard is defined. It is a list of lists, representing a 2D-Matrix. Every \"parent\" list is a row in the actual inline keyboard (so `[[1], [2]]` would be two rows), every entry inside an parent list is a column. So this keyboard will have two rows, Option 1 and Option 2 will be in the first; Option 3 in the second one.\n\n```python\nreply_markup = InlineKeyboardMarkup(keyboard)\n```\n[Line 34](../blob/master/examples/inlinekeyboard.py#L34) turns our list into an actual Inline Keyboard that we can pass along with our message.\n\n```python\nawait update.message.reply_text('Please choose:', reply_markup=reply_markup)\n```\nIn [line 36](../blob/master/examples/inlinekeyboard.py#L36) we reply to the update message with a text (hence [reply_text](https://docs.python-telegram-bot.org/telegram.message.html#telegram.Message.reply_text)) and pass the keyboard along in the `reply_markup` argument. The `await` tells the program to stop and wait for the function call to finish. `async` and `await` are both fundamentals of asyncio programming in python, explaining this further is outside of this example explainer. If you are curious, feel free to search for it, otherwise just accept these keywords as they are.\n\nNow we expect people to press one of the provided buttons, so let's jump to the button callback\n## button\n\n```python\nasync def button(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n```\n[Line 39](../blob/master/examples/inlinekeyboard.py#L39) defines a function called button. It takes the two arguments update and context and returns nothing. Basically the same as `start`.\n\n```python\nquery = update.callback_query\n```\n[Line 41](../blob/master/examples/inlinekeyboard.py#L41) defines query as a shortcut to access the provided [CallbackQuery](https://docs.python-telegram-bot.org/telegram.callbackquery.html). This is the part of the update which has all the information in it, remember, it gets generated/send to the bot once a user presses a button.\n\n\n```python\nawait query.answer()\n```\n[Line 45](../blob/master/examples/inlinekeyboard.py#L45) here we answer the `CallbackQuery`. We use a convenient shortcut PTB provides. It takes care of calling the [actual function](https://docs.python-telegram-bot.org/telegram.bot.html#telegram.Bot.answer_callback_query) and passing all the required parameters to it. If you check out the function, you see that you can pass a `text` argument to it, which will be displayed in a little pop-up on the client end, and if you pass `show_alert` on top of it, the user has to dismiss the pop-up. Not useful for this example, so we just pass it without these optional arguments.\n\n```python\nawait query.edit_message_text(text=f\"Selected option: {query.data}\")\n```\n[Line 47](../blob/master/examples/inlinekeyboard.py#L47) edits the message where `CallbackQuery` originates from with the text where we tell the user which option we picked. We insert `query.data` into the string, which is the data we defined in the keyboard, so the number 1, 2 or 3. Since we don't pass the inline keyboard along again, it will disappear.\n## help\n\n```python\nasync def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:\n    await update.message.reply_text(\"Use /start to test this bot.\")\n```\n[Line 50 to 52](../blob/master/examples/inlinekeyboard.py#L50-L52) is a simple callback. Here we reply to the /help command with the provided text: They should use /start to use this bot.\n## error\n\n```python\nlogging.basicConfig(\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO\n)\nlogger = logging.getLogger(__name__)\n```\n[Line 18 to 21](../blob/master/examples/inlinekeyboard.py#L18-L21) are the only lines of the code we haven't covered yet. Here we set up the logging module to have the format we want, and we define logger in case we want to use it later. More docs regarding logging can be found [here](https://docs.python.org/3/library/logging.html)\n\n***\n\nThis section of the wiki is currently in development, feedback is greatly appreciated. Ping one of the admins in our telegram group to anything you want to tell us."
    },
    {
        "name": "Internal-test-bots.md",
        "description": "**Note: This guide is of no use to the regular user.**\n\n### Variables:\n```\nCI = AppVeyor|Travis\npy_platform = CPython|PyPy\npy_version = 2.7|3.4|3.5|3.6|3.7\nbot_username = ptb_{CI.lower()}_{py_platform.lower()}_{py_version.replace('.', '')}_bot\n```\n## Script\n[Here](https://gist.github.com/jsmnbom/2e8044ca5cc55813a0e0380ad375b320) is a script that does all the setup below in a semi automated way using Telethon. Also check [this version](https://gist.github.com/Bibo-Joshi/75f135edf1ca3530decf4c2ae06bd699), which was updated for the animated sticker sets and automatically creates a new super group for the bot to be added to (see [#1919](https://github.com/python-telegram-bot/python-telegram-bot/pull/1919)). ⚠️ The script needs to be updated to create a forum test group for each bot and make the bot admin (with right to edit forums!) in that group. Teltehons `ToggleForumRequest` is helpful for converting groups to forums.\n\n**Note:** It doesn't create the video sticker set yet, but the test suite creates that on the fly, if necessary.\n\n\n## Setup a new bot\n\n`#` means *send a message to @BotFather*  \n`%` means *click button in inlinekeyboard*  \n\n### Create the bot\n\n`# /newbot`  \n`# Python-telegram-bot tests on {CI} using {py_platform} {py_version}` *(Bot name)*  \n`# {bot_username}` *(Bot username)*  \n\nThe token for the new bot will be shown.\n\n### Allow the bot to talk to you\nSearch for the bot, and press the `Start` button\n\n### Set texts in case a user stumbles upon the bot\n\n`# /set_description`  \n`# @{bot_username}`  \n`# This bot is only for running tests for python-telegram-bot and has no actual functionality.`  \n\n`# /set_abouttext`  \n`# @{bot_username}`  \n`# This bot is only for running tests for python-telegram-bot and has no actual functionality.`  \n\n### Make sure it can join groups\n\n`# /setjoingroups`  \n`# @{bot_username}`  \n`# Enable`  \n\n### Add it to the developer group\n`>>> telegram.Bot() - Developers`\n\n### Add it to the testing channel\n[`>>> telegram.Bot() - Tests`](https://t.me/pythontelegrambottests)\n\n### Make sure it can not join groups anymore\n\n`# /setjoingroups`  \n`# @{bot_username}`  \n`# Disable` \n\n### Turn on inline so we can create a game for the bot\n\n`# /set_inline`  \n`# @{bot_username}`  \n`# This bot is only for running tests.`  \n\n### Create a game for the bot\n\n`# /newgame`  \n`# OK`  \n`# Accept`  \n`# @{bot_username}`  \n`# Python-telegram-bot test game`  \n`# A no-op test game, for python-telegram-bot bot framework testing.`  \n`Upload tests/data/game.png`  \n`Upload tests/data/game.gif`  \n`# test_game`  \n\n### Payment\nNow we need to setup payment. This can only be done via the beta /mybots interface.\n\n`# /mybots`  \n`% @{bot_username}`  \n`% Payments`  \n`% Stripe` *(might have a flag in front, depending on your country)*  \n`% Connect Stripe Test`  \n`Press start in @StripeTestBot`  \n`% Authorize`  \n`Press \"Skip this account form\" at the top of your browser`  \n`Go back to @StripeTestBot and make sure everything went well`  \n`Go back to @BotFather`  \n\nThe payment provider token should be displayed in the last message.\n\n### Create a sticker set for the bot\n\nWe need to use the bot api to do this.\n```\nme_id = YOURUSERID\nsticker_set_name = 'test_by_{username}\nsticker_set_title = 'Test',\nsticker = 'tests/data/telegram_sticker.png',\nsticker_emoji = '😄'\n\nbot = telegram.Bot(token)\nwith open(sticker, 'rb') as f:\n    assert bot.create_new_sticker_set(me.id, sticker_set_name, sticker_set_title,\n                                      f, sticker_emoji)\n```\n\n### Create an animated sticker set for the bot\n\nWe need to use the bot api to do this.\n```\nme_id = YOURUSERID\nanimated_sticker_set_name = 'test_by_{username}\nanimated_sticker_set_title = 'Test',\nanimated_sticker = 'tests/data/telegram_animated_sticker.png',\nsticker_emoji = '😄'\n\nbot = telegram.Bot(token)\nwith open(animated_sticker, 'rb') as f:\n    assert bot.create_new_sticker_set(me.id, animated_sticker_set_name, animated_sticker_set_title,\n                                      f, sticker_emoji)\n```\n\n### Create a video sticker set for the bot\n\nSimilar to above\n"
    },
    {
        "name": "Introduction-to-the-API.md",
        "description": "## Pure Telegram Bot API\n\nThe Bot API is exposed via the [`telegram.Bot`](https://python-telegram-bot.readthedocs.io/telegram.bot.html) class.\nThe methods are the `snake_case` equivalents of the methods described in the official [Telegram Bot API](https://core.telegram.org/bots/api).\nThe exact `camelCase` method names as in the Telegram docs are also available for your convenience.\nFor example, `telegram.Bot.send_message` is the same as `telegram.Bot.sendMessage`.\nAll the classes of the Bot API can also be found in the `telegram` module, e.g. the `Message` class is available as [`telegram.Message`](https://python-telegram-bot.readthedocs.io/telegram.message.html).\n\nTo generate an Access Token, you have to talk to [BotFather](https://t.me/botfather) and follow a few simple steps (described [here](https://core.telegram.org/bots/features#botfather)).\n\nFor full details see the official Telegram documentation at [Bots: An introduction for developers](https://core.telegram.org/bots). You might also find [the official tutorial](https://core.telegram.org/bots/tutorial) useful for getting to know the principles of working with Telegram API (although Java is used in examples there, you will find a link to equivalent Python code).\n\n#### Hello, Telegram!\n\nTo get a feeling for the API and how to use it with `python-telegram-bot`, please create a new Python file.\n\nWe first want to create an instance of the `telegram.Bot` and check that the credentials are correct.\nPlease paste the following code into your file.\n`'TOKEN'` should be replaced by the API token you received from `@BotFather`\n\n```python\nimport asyncio\nimport telegram\n\n\nasync def main():\n    bot = telegram.Bot(\"TOKEN\")\n    async with bot:\n        print(await bot.get_me())\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n```\n\nHere we simply call the API method [getMe](https://core.telegram.org/bots/api#getme).\nThe `async with bot:` ensures that PTB can properly acquire and release resources.\nIf you run the file you should get an output along the lines\n\n```sh\n$ python main.py\nUser(first_name=\"Toledo's Palace Bot\", is_bot=True, username=\"ToledosPalaceBot\", ...)\n```\n\nSo far so good.\nNow we can try and actually do something - let's send a message.\n\n> [!IMPORTANT]\n> Bots can't initiate conversations with users.\n> A user must either add them to a group or send them a message first.\n> People can use ``t.me/<bot_username>`` links or username search to find your bot.\n\nBecause of that restriction, we'll have to first send a message to the bot.\nAfter we've done that, we can fetch the update by refactoring the `main` function in our file with\n\n```python\nasync def main():\n    bot = telegram.Bot(\"TOKEN\")\n    async with bot:\n        updates = (await bot.get_updates())[0]\n        print(updates)\n```\n\nThe output should now look something like this (we abbreviated the output a bit):\n\n```sh\n$ python main.py\nUpdate(message=Message(chat=Chat(first_name='John', id=1234567890, last_name='Doe', ...), from_user=User(first_name='John', id=1234567890, last_name='Doe', ...), text='Hi!', ...), update_id=219017225)\n```\n\nWe copy the chat id, here `1234567890`.\nNote that you can access it also as `updates[0].message.from_user.id`, because `updates[0]` is an instance of the [`Update`](https://docs.python-telegram-bot.org/telegram.update.html) class.\nNow that we have the chat ID, we can send a message by again adjusting the `main()`:\n\n```python\nasync def main():\n    bot = telegram.Bot(\"TOKEN\")\n    async with bot:\n        await bot.send_message(text='Hi John!', chat_id=1234567890)\n```\n\n## Beyond the pure API\n\nThat's all very nice, but usually you want your bot to actually react to more complex user input. That is, you want to build a chat-bot. `python-telegram-bot` offers a powerful extension module called `telegram.ext` that takes a lot of work off your shoulders. You can find an introduction at the [[Tutorial: Your first bot|Extensions---Your-first-Bot]]."
    },
    {
        "name": "Local-Bot-API-Server.md",
        "description": "Since Bot API 5.0, Telegram made the [Bot API server](https://github.com/tdlib/telegram-bot-api) open source, allowing you to host your own instance. For details on what benefits hosting your own instance has and how it works, please see the [official docs](https://core.telegram.org/bots/api#using-a-local-bot-api-server).\n\nBot API 5.0 (and therefore local API server) is supported by PTB since v13.1.\n\n## How to use a local Bot API Server with PTB\n\n* Before you can move your bot from the official server cloud to a self hosted server, you need to call the [`log_out`](https://python-telegram-bot.readthedocs.io/telegram.bot.html#telegram.Bot.log_out) method.\n* Before moving from one self hosted instance to another, you need to use the [`delete_webhook`](https://python-telegram-bot.readthedocs.io/telegram.bot.html#telegram.Bot.delete_webhook) and [`close`](https://python-telegram-bot.readthedocs.io/telegram.bot.html#telegram.Bot.close) methods.\n* To make PTB aware that you're not using the official server, pass the following to your [`ApplicationBuilder`](https://python-telegram-bot.readthedocs.io/en/latest/telegram.ext.applicationbuilder.html#telegram.ext.ApplicationBuilder.base_url) (or [`Bot`](https://python-telegram-bot.readthedocs.io/en/latest/telegram.bot.html#telegram.Bot.params.base_url)):\n  * `base_url='your-bot-api-server.com/bot'`\n\n### Working with files\n* When running the server with the `--local` flag\n  * you need to set `local_mode=True`\n  * `get_file` will give you the local file path as `file_path`. PTB detects that, so that `await get_file(…).download_to_drive()` just returns the local file string instead of downloading it.\n  * you can send files by passing `'file:///absolute/path/to/file'` instead of an URL or a file handle.\n  * passing relative paths (without prefix) or even passing `pathlib.Path` objects is supported as well, even if you're not running in `local` mode, in which case it will be opened and send via upload as usual.\n  * To adjust for larger file sizes transmitted between PTB and the local API server, it may be beneficial to extend the timeout values for networking operations. See the wiki pages on [[handling networking errors|Handling-network-errors]] as well as on [[adding defaults|Adding-defaults-to-your-bot]].\n* When running the server *without* the `--local` flag\n  * you need to set `base_file_url='your-bot-api-server.com/file/bot'`\n  * the Bot API server does *not* automatically serve the files obtained by `get_file()`, see [telegram-bot-api/#26](https://github.com/tdlib/telegram-bot-api/issues/26). So be aware that you have to run a web server which serves them, otherwise you will run into 404 errors."
    },
    {
        "name": "Making-your-bot-persistent.md",
        "description": "In V12.0b1 we added a persistence mechanism to `telegram.ext`. This wiki page is there to help you understand and set up persistence for your bots.\n\n- [What can become persistent?](#what-can-become-persistent)\n- [Included persistence classes](#included-persistence-classes)\n- [3rd party persistence classes](#3rd-party-persistence-classes)\n- [What do I need to change?](#what-do-i-need-to-change)\n- [Refreshing at runtime](#refreshing-at-runtime)\n- [Storing Bots](#storing-bots)\n\n## What can become persistent?\n* The persistence structure is designed to make\n  * `bot_data`\n  * `chat_data`\n  * `user_data`,\n  * `ConversationHandler`'s states and\n  * `ExtBot.callback_data_cache` persistent.\n\n* `Job`'s and the `job_queue` is not supported.\nHowever, the current `JobQueue` backend [APScheduler](https://apscheduler.readthedocs.io/) has its own persistence logic that you can leverage.\nSee e.g. [`ptbcontrib/ptb_jobstores`](https://github.com/python-telegram-bot/ptbcontrib/tree/main/ptbcontrib/ptb_jobstores)\n* For a special note about `Bot` instances, see [below](#storing-bots)\n\n## Included persistence classes\nThree classes concerning persistence in bots have been added.  \n* [BasePersistence](https://python-telegram-bot.readthedocs.io/en/latest/telegram.ext.basepersistence.html) - Is an interface class for persistence classes.\nIf you create your own persistence classes to maintain a database-connection for example, you must inherit from `BasePersistence` and implement all abstract methods\n* [PicklePersistence](https://python-telegram-bot.readthedocs.io/en/latest/telegram.ext.picklepersistence.html) - Uses pickle files to make the bot persistent.  \n* [DictPersistence](https://python-telegram-bot.readthedocs.io/en/latest/telegram.ext.dictpersistence.html) - Uses in memory dicts and easy conversion to and from JSON to make the bot persistent.\nNote that this class is mainly intended as starting point for custom persistence classes that need to JSON-serialize the stored data before writing them to file/database and does *not* actually write any data to file/database.\n\n## 3rd party persistence classes\nInstead of manually handling a database to store data, consider implementing a subclass of `BasePersistence`. This allows you to simply pass an instance of that subclass to the `Application` and let PTB handle the loading, updating & storing of the data!\n\nIf you want to create your own persistence class, please carefully read the docs on [BasePersistence](https://python-telegram-bot.readthedocs.io/en/latest/telegram.ext.basepersistence.html). It will tell you what methods you need to overwrite. \n\nIf you've written a persistence class that could benefit others (e.g., a general one covering all types of data), it would be great if you linked it here or even better made it available in [ptbcontrib](https://github.com/python-telegram-bot/ptbcontrib).\n\nThese 3rd party packages contain persistence classes (the list is incomplete):\n* [python-telegram-bot-django-persistence](https://github.com/GamePad64/python-telegram-bot-django-persistence) - Uses Django ORM to store persistence data. It is most useful for projects, that use PTB and Django.\n* [MongoPersistence](https://github.com/LucaSforza/MongoPersistence) - Package to add persistence to your telegram bot and upload data to your mongo database.\n\n## What do I need to change?\n\nTo make your bot persistent you need to do the following.\n\n- Create a persistence object (e.g. `my_persistence = PicklePersistence(filepath='my_file')`)\n- Construct `Application` with the persistence (`Application.builder().token('TOKEN').persistence(persistence=my_persistence).build()`).\n\nThis is enough to make `user_data`, `bot_data`, `chat_data` and `ExtBot.callback_data_cache` persistent.\nTo make a conversation handler persistent (save states between bot restarts) you **must name it** and set `persistent` to `True`.\nFor example `ConversationHandler(..., persistent=True, name='my_name')`. `persistent` is `False` by default.\nAdding these arguments and adding the conversation handler to a persistence-aware `Application` will make it persistent.\n\nWhen starting the `Application` with `Application.start()` or `Application.run_{polling, webhook}`, it will loads the data from the persistence on startup and automatically update the persistence in regular intervals.\nYou can customize the interval via the [`update_interval`](https://python-telegram-bot.readthedocs.io/telegram.ext.basepersistence.html#telegram.ext.BasePersistence.params.update_interval) argument of `Base/Pickle/Dict/…Persistence`.\n\nYou can also selectively store only some of `{bot,chat,user,callback}_data` by passing a `PersistenceInput` to the `store_data` argument your persistence class.\n\n> [!NOTE]\n> Since the persisted data is loaded on start-up, any data written to `Application.{bot, chat, user_data}` *before* startup will hence be overridden! To manually write data into these *after* the persisted data has been loaded, please use [`Application.post_init`](https://docs.python-telegram-bot.org/telegram.ext.applicationbuilder.html?highlight=ApplicationBuilder#telegram.ext.ApplicationBuilder.post_init).\n\n## Refreshing at runtime\n\nIf your persistence reads the data from an external database, the entries in this database could change at runtime.\nThis is the case in particular, if the entries in the database are created by a 3rd party service independently of your bot.\nIf you want to make sure that the data in `context.user/chat/bot_data` are always up-to-date, your persistence class should implement the methods [`refresh_bot/chat/user_data`](https://python-telegram-bot.readthedocs.io/telegram.ext.basepersistence.html#telegram.ext.BasePersistence.refresh_chat_data).\nThose will be called when in update comes in, before any of your callbacks are called.\n\nThese methods can also be useful to implement a lazy-loading strategy.\n\n## Storing Bots\n\nInstances of `telegram.Bot` should not be serialized, because changes to the bot don't apply to the serialized object.\n\nFor example, you might change the [[default values|Adding-defaults-to-your-bot]] used by the bot.\nOr if you change the bots token, this may lead to e.g. `Chat not found` errors.\nThis is relevant e.g., if you store Telegram objects like `Message` in `bot/user/chat_data`, as some of them hold a reference to `Application.bot` (which is how the shortcuts like `Message.reply_text` work).\n\nThe interface class `BasePersistence` does not question what kind of data you supply to its methods.\nHence, each implementation should take care that it does not try to serialize `telegram.Bot` instances.\nFor example, it can check if the data equals the attribute `BasePersistence.bot` (which will be the bot object used by the `Application`) and instead store a placeholder.\nWhen loading the data, the `BasePersistence.bot` can be reinserted instead of the placeholder.\nIndeed, this is basically what the built-in `PicklePersistence` does.\n\nFor more technical details, please refer to the documentation of [`BasePersistence`](https://python-telegram-bot.readthedocs.io/telegram.ext.basepersistence.html#telegram-ext-basepersistence), \n[`PicklePersistence`](https://python-telegram-bot.readthedocs.io/telegram.ext.picklepersistence.html#telegram-ext-picklepersistence)\n\n> [!NOTE]\n> Although `PicklePersistence` does the 'placeholder' process described above, all the data are deep copied with `copy.deepcopy` before being handed over to persistence. This means that you should either store only copyable data (e.g. no `telegram.Bot` objects) and/or ensure that your stored data defines appropriate custom deepcopy behavior. This technical detail is described in a note [here](https://docs.python-telegram-bot.org/telegram.ext.application.html#telegram.ext.Application.update_persistence)"
    },
    {
        "name": "MWE.md",
        "description": "# How to write a Minimal Working Example\n\nIf you read this, you probably were asked to provide a minimal working example (MWE) in the [user group](https://t.me/pythontelegrambotgroup) or the [issue tracker](https://github.com/python-telegram-bot/python-telegram-bot/issues) of the [python-telegram-bot](https://python-telegram-bot.org) library.\n\nSo here is what that means:\n\n## Example\n\nWhen trying to help you with a problem, it's often helpful to see your code instead of a vague description of the issue. Of course, a better description often also helps (see [[this article|Ask-Right]] on asking good technical questions).\n\n## Working\nIn order for the example to actually be helpful, it must work. This means that it:\n\n### Is ready to run\nCode that's not runnable is not very useful to see an issue - at least most times. Make sure that whoever is trying to help you only needs to plug in a bot token, run the script and send `/start` to the bot for the example to run.\n\nIn particular this means that\n\n* all necessary imports are included\n* no undefined functions are called or undefined modules imported\n* apart from PTB no additional dependencies need to be installed\n\n### Reproduces the issue\nIf the provided example doesn't show the described problem, it's not much of an example.\n\n## Minimal\nMake sure that your example contains everything needed for the problem to show - and nothing more! Nothing delays finding a bug more than hundreds of unrelated lines of code. Your example should fit in a single short file. Reducing your problematic code to such a minimal example often times already helps to identify the actual issue.\n\n## Publishing\nBe sure to remove your bot token before publishing the MWE!\nAlways send it along with a concise description of what exactly the problem is and how it can be reproduced with your MWE.\n\nAs a final note, if you were asked for an MWE in the user group, please post your code using a pastebin, e.g. https://hastebin.com or https://pastebin.com, instead of posting it as plain text in the user group."
    },
    {
        "name": "Notes-about-GAE---Google-App-Engine.md",
        "description": "**NOTE: This page needs more work**\n\n***\n\nMake sure to add this block to `app.yaml` (see [1393](https://github.com/python-telegram-bot/python-telegram-bot/issues/1393)):\n\n```\nenv_variables:\n    GAE_USE_SOCKETS_HTTPLIB : 'true'\n```\nNote: This environmental variable applies only to applications developed for the Standard Environment and using Python 2.7 (see https://cloud.google.com/appengine/docs/standard/python/sockets/)"
    },
    {
        "name": "Performance-Optimizations.md",
        "description": "## Introduction\nWhen your bot becomes popular, you will eventually want to improve response times. After all, Telegram places high priority on fast messaging. At the same time, responses become slower as more people are using your bot. This happens more quickly for inline bots, as they may receive multiple inline queries during one interaction. \n\nThere are of course many ways to tackle this problem and not all work for everyone.\nBefore we list a few of them, here are some very important notes:\n\n### Avoid premature optimization\n\nPutting hours upon hours into squeezing every last bit of performance out of your code is worthless if your bot doesn't actually get much traffic.\nBefore you start optimizing, you should assess the actual usage of your bot.\nFor example, you can track the number of updates your bot receives along with a timestamp such that you can get an overview of the number of updates it processes on average.\nAlso check if your bot gets new updates in peaks or if they are spread evenly across the day.\n\n### Avoid misdirected optimizations\n\nNot all ways of improving performance will work for everyone.\nMore precisely, which methods to choose depend on which parts of your code slow down the bot the most.\n\nIf you do a lot of requests to the Bot API/an external API - i.e. I/O tasks -, concurrency may help.\nOTOH, if you do a lot of heavy calculations, i.e. CPU-bound tasks, you can use `asyncio.create_task` all you want but you won't make much progress in terms of performance.\n\nYou should carefully analyze your bot and check e.g. which handler callbacks take the most runtime and check how to minimize that.\n\n### Have realistic expectations\n\nKeep in mind that you're programming in Python.\nImmense speed is not something that Python is well known for.\nIf performance is more important to you than programming in Python, you might want to consider using a different programming language, e.g. a compiled language. \n\n## Free Optimizations\n\n### PyPy\n[PyPy](http://pypy.org/) is a different implementation of the Python programming language. Is your bot only using pure Python code? Using PyPy can then probably¹ optimize all your code -- free of charge.\n\n¹PTB does *not* officially support PyPy as there have been a lot of issues in the past. It may still work out for you.\n\n## Concurrency\n\nMuch of the work a usual bot does, boils down to making requests to the Bot API, i.e. network communication.\nSuch I/O operations usually involve a lot of *waiting*, i.e. time during which nothing really happens in your code.\nRunning I/O operations concurrently can hence save a lot of time.\n\nThis is probably one of the main motivations behind Pythons `asyncio` library, which PTB is built upon.\nBecause this topic is so important, it has its own [[wiki page|Concurrency]].\n\n## Server location\nAnother potential bottleneck is the time your server (the computer that runs your bot script) needs to contact the Telegram server.\nAs of *June 2016*, there is only one server location for the Bot API, which is in the Netherlands.\n\n**Note:** As of Bot API 5.0 you can also host your very own [[Bot API Server|Local-Bot-API-Server]].\n\n### Test your connection\n\n#### Using the ping utility\nYou can test your connection by running `ping api.telegram.org` on the command line of your server. A good connection should have a stable ping of 50ms or less. A server in Central Europe (France, Germany) can easily archive under 15ms, a server in the Netherlands reportedly archived 2ms ping. Servers in the US, Southeast Asia or China are not recommended to host Telegram bots.\n\n#### Using the cURL utility\nWhile the `ping` utility is helpful and the information is valuable, it's a rather primitive way to test your connection. In reality, there are many factors that influence the response times of your bot. For a more detailed test that actually connects to the Telegram servers via HTTPS, you can use cURL. The following is taken from [this blog post](https://josephscott.org/archives/2011/10/timing-details-with-curl/).\n\n##### Step 1\nOn the server you want to test, create a file called `curl-format.txt` and paste this:\n\n```\n\\n\n            time_namelookup:  %{time_namelookup}\\n\n               time_connect:  %{time_connect}\\n\n            time_appconnect:  %{time_appconnect}\\n\n           time_pretransfer:  %{time_pretransfer}\\n\n              time_redirect:  %{time_redirect}\\n\n         time_starttransfer:  %{time_starttransfer}\\n\n                            ----------\\n\n                 time_total:  %{time_total}\\n\n\\n\n```\n\n##### Step 2\nMake a request to the Telegram API. In the following command, replace `<token>` with your API token and `<chat_id>` with your User ID (you can get your User ID from [@userinfobot](https://telegram.me/userinfobot)) and run it on your command line:\n\n- Linux: `curl -w \"@curl-format.txt\" -o /dev/null -s \"https://api.telegram.org/bot<token>/sendMessage?chat_id=<chat_id>&text=Test\"`\n- Windows: `curl -w \"@curl-format.txt\" -o NUL -s \"https://api.telegram.org/bot<token>/sendMessage?chat_id=<chat_id>&text=Test\"`\n\nThe result should look similar to this:\n\n```\n    time_namelookup:  0,004\n       time_connect:  0,041\n    time_appconnect:  0,119\n   time_pretransfer:  0,119\n      time_redirect:  0,000\n time_starttransfer:  0,156\n                    ----------\n         time_total:  0,156\n```\n\n**TODO:** Interpreting and improving these numbers.\n\n**Note:** When choosing a server for the sole purpose of hosting a Telegram bot, these (ping and cURL) are the only relevant timings. Even if you are the only user of the bot, there is no advantage in choosing a server close to *you.* \n\nIf you need some suggestions on where to host your bot, read [[Where to host Telegram Bots|Where-to-host-Telegram-Bots]].\n\n# What to read next?\nLearn [[how to use webhooks|Webhooks]] to get every last bit of performance from your bot."
    },
    {
        "name": "Press.md",
        "description": "A collection of blogposts and other external articles that are related to `python-telegram-bot`.\n\nFeel free to add your own, ordered by Date published.\n\nArticle | Date published | Type | Language\n------- | -------------- | ---- | --------\n[Create a Chatbot for Telegram in Python to Summarize Text](http://blog.algorithmia.com/create-a-chatbot-telegram-python-summarize-text/) | 2016-08-25 | Tutorial | English\n[Fazendo um Bot para Telegram em Python](https://juliarizza.wordpress.com/2016/08/06/fazendo-um-bot-para-telegram-em-python/) | 2016-08-06 | Tutorial | pt_BR\n[Creating a Telegram bot using Python](https://medium.com/@ngrjs/creating-a-telegram-bot-using-python-9d11a43a8d2/) | 2016-11-25 | Tutorial | English"
    },
    {
        "name": "Project-Bots,-Groups-and-Channels.md",
        "description": "# Groups\n\n* [@pythontelegrambotgroup](https://t.me/pythontelegrambotgroup) is the on-topic user group for questions about PTB. It's owned by the test user account.\n* [@pythontelegrambottalk](https://t.me/pythontelegrambottalk) is the off-topic user group were we can redirect people who have off-topic questions about e.g. python in general and where meta-discussions can happen. It's owned by the test user account.\n* [@pythontelegrambotdev](https://t.me/pythontelegrambotdev) is the group for any question related to the development of PTB. It's owned by the test user account.\n\n# Bots\nBesides the test bots, the developers team maintains a few helper bots:\n\n* [@roolsbot](https://t.me/roolsbot) Is admin in both the on-topic and the off-topic usergroup and runs on [this source](https://github.com/python-telegram-bot/rules-bot). It's owned by the test user account.\n* [@PythonTelegramBot](https://t.me/PythonTelegramBot) is owned by the PTB test user account and currently does nothing but blocking the name.\n\nMoreover [@python_telegram_bot](https://t.me/python_telegram_bot) is *not* owned by any of the developers and we don't know who it belongs to.\n\n# Channels\n\n* [@pythontelegrambotchannel](https://t.me/pythontelegrambotchannel) is the offical channel of PTB where the release notes go. It's owned by the test user account.\n* [@ptbfaq](https://t.me/PTBFaq) is a channel that was supposed to hold FAQ messages, but was never really in use (roolsbot can still forward to there?!). @josxa is still admin, but he lost the phone with the owner account.\n\nMoreover [@run_async](https://t.me/run_async) is *not* owned by any of the developers and also irrelevant since the deprecation of `@run_async` in v13.0\n\n# Sticker Packs\n\nThe test user account ownes the sticker pack [PythonTelegramBot](https://t.me/addstickers/PythonTelegramBot), which is the group sticker pack in both the on- & off-topic group. The stickers can be found [here](https://github.com/python-telegram-bot/logos/tree/master/sticker-pack)."
    },
    {
        "name": "PTB-test-writing-knowledge-base.md",
        "description": "This page contains useful knowledge bits for writing tests for the PTB library. This might also help you out writing tests for your bots **using** PTB, but that is definitely not the goal of this document. If you have questions writing tests for PTB, feel free to ask them in the [dev group](https://t.me/pythontelegrambotdev). If you want to ask about writing tests for your bots, ask those either in [@pythontelegrambotgroup](https://t.me/pythontelegrambotgroup) or [@pythontelegrambottalk](https://t.me/pythontelegrambottalk).\n\n- [How to generate encrypted passport files](#how-to-generate-encrypted-passport-files)\n\n### How to generate encrypted passport files\n\nFor Passport encryption, [decrypting data](https://core.telegram.org/passport#decrypting-data) is clearly laid out by Telegram (for obvious reasons) while they only implicitly explain how they decrypt it. As of writing this document, I could not have been bothered figuring out the exact steps they take to encrypt the file, so I did the following:\n* Setup a bot with botfather for passport decryption by providing the public key (with /setpublickey) from [PTBs test private file](../blob/master/tests/data/private.key). As of the time of writing that is <details><summary>this Key.</summary>\n-----BEGIN PUBLIC KEY-----<br/>\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAstn3GNj9MRAz7Dsk2bY5<br/>\n1//yxadHbYdLr6cro6cWw4JqsTHU3CweFcKuRhw/jOpv37GlTHk1VFrBlhchmvao<br/>\nl6zdBLPQPXV5tMa3VQi/y03Y7Ax09C0rndAgjq6Xhsrnx/i1T8AUjBjbeqcuoiVf<br/>\n0ZJwatGIODFRtf3CuXZifXlRYgyfrJEP8vd9SfkCHWQabSFE6z0m/vF3Yh4AjsRk<br/>\nwugwWVWlOLhmTXHCSsnIPEZhdsuK1E85Nye7H1h68c+wYk07h1b01zlObCmJuS/L<br/>\nCt02JKEHNpCw0DAQF/3C+agLD2CFnN1j+m4RgZqqchVd0tsorGZKG7fMDu6vKOEh<br/>\nWwIDAQAB<br/>\n-----END PUBLIC KEY-----</details>\n* Download the JS SDK and use it as described [here](https://core.telegram.org/passport/sdk-javascript). Fill out the stuff in the examples, don't forget the new lines in the public key. Set scope to the type you want to test.\n* Once you press on the button, the tgdesktop app should open, and you can select a file to upload. Either the desktop or the the telegram servers compress pictures on upload and PTBs decryption compares hashes as it should, so have that in mind and download the decrypted part if needed.\n* Once you done this, get the update, I copy pasted the json part of the PassportData.\n* Setup a Bot object instance with the PTB private key and pass it to PassportData.\n* Now you can use PassportData.de_json with the bot instance and the json string to generate a PassportData object.\n* From there, you can either get the encrypted elements by accessing .credentials or .data[X], or get the decrypted ones with .decrypted_data()."
    },
    {
        "name": "Related-Projects.md",
        "description": "A list of projects that are somehow related to `python-telegram-bot`. This includes integrations with other projects like django, projects that are built on top of this library for specific use-cases and potentially others.\n\n**Note:** For *bots* that are built with this library, please use the [[Examples|Examples]] page and not this one.\n\nIf you are developing a project that fits this description, please add it here in alphabetical order. If you found a project that project that fits this description, please suggest to the maintainer of the project to add it here.\n\nPlease try to keep this page up-to-date.\n\n| Project | Description | `python-telegram-bot` version | Development Status |\n| ------- | ----------- | ----------------------------- | ------------------ |\n| [autoconv](https://github.com/Mortafix/AutoConv-Telegram-Python) | A module to build automatic and simple to manage conversation | >=13 | Alpha |\n| [django-telegrambot](https://github.com/JungDev/django-telegrambot) | A simple app to develop Telegram bots with Django | >=6.0.1 | Stable |\n| [jackfruit](https://github.com/zzzzlzzzz/jackfruit) | A menus and forms for Telegram bots | >=12.0 | Alpha |\n| [ownbot](https://github.com/michaelimfeld/ownbot) | Ownbot provides some cool decorators to protect your command handler functions from unauthorized users! | 5.1.1 | Beta |\n| [permabots](https://github.com/jlmadurga/permabots) | Connect instant messaging bots to your APIs. https://permabots.readthedocs.org | 4.2.0 | Beta |\n| [python-telegram-bot-seed](https://github.com/alesanmed/python-telegram-bot-seed) | Seed project for developing bots using python-telegram-bot | 10.1.0 | Pre-Alpha |\n| [telegram-send](https://github.com/rahiel/telegram-send) | Send messages and files over Telegram from the command-line | >=2.9 | Beta |\n| [telegram.bot](https://github.com/ebeneditos/telegram.bot) | Develop a Telegram Bot with R | >=6.0.0 | Stable |\n| [flexget](https://github.com/Flexget/Flexget)| Use telegram as a notifier | 3.4 | Stable\n| [ptb-django-cookiecutter](https://github.com/lugodev/ptb-django-cookiecutter)| A simple cookiecutter to create Python Telegram bots, wrapped with Django. | 0.1.0 | Beta |\n| [ptb-menu-pagination](https://github.com/SergSm/ptb-menu-pagination) | Makes a google style pagination line for a list of items. | >=13.8.1 | Alpha |\n| [ptb-pagination](https://github.com/wiltonsr/ptb-pagination) | Python inline keyboard pagination for Telegram Bot API. | >=13.6 | Alpha |\n[Video Tutorial](https://youtu.be/fQo_327-AZA) | How to create a simple Telegram bot using PTB and then hosting it on Heroku|13.7|-|\n| [python-telegram-bot-django-persistence](https://github.com/GamePad64/python-telegram-bot-django-persistence) | A persistence engine, that uses Django ORM as storage. No separate infrastructure needed! | >=13.7 | Beta |\n| [python-telegram-bot-template](https://github.com/Lur1an/python-telegram-bot-template) | A template for a python-telegram-bot application, inlcudes MongoDB persistence, barebone user module, application-state handling and some decorators and utility classes | 20.0a0 | - |"
    },
    {
        "name": "Storing-bot,-user-and-chat-related-data.md",
        "description": "Sometimes you need to temporarily store some information about the current user and/or chat for later use. An example of this would be a survey bot that asks the user a series of questions one after another and saves them to your database when all answers are collected. \n\n# `bot_data`, `user_data` and `chat_data`\n\nThe `telegram.ext` framework provides a built-in solution for this common task. Let's jump straight to an example:\n\n```python\nfrom uuid import uuid4\nfrom telegram.ext import Application, CommandHandler\n\nasync def put(update, context):\n    \"\"\"Usage: /put value\"\"\"\n    # Generate ID and separate value from command\n    key = str(uuid4())\n    # We don't use context.args here, because the value may contain whitespaces\n    value = update.message.text.partition(' ')[2]\n\n    # Store value\n    context.user_data[key] = value\n    # Send the key to the user\n    await update.message.reply_text(key)\n\nasync def get(update, context):\n    \"\"\"Usage: /get uuid\"\"\"\n    # Separate ID from command\n    key = context.args[0]\n\n    # Load value and send it to the user\n    value = context.user_data.get(key, 'Not found')\n    await update.message.reply_text(value)\n\nif __name__ == '__main__':\n    application = Application.builder().token('TOKEN').build()\n\n    application.add_handler(CommandHandler('put', put))\n    application.add_handler(CommandHandler('get', get))\n    application.run_polling()\n```\n\n## Explanation\nBy using `context.user_data` in any `Handler` callback, you have access to a user-specific `dict`.\n\n*Every time the bot receives a message*, the handler for that message finds (or creates) the `user_data` of the user who sent the message. This dictionary is *shared across all handlers* of the bot.\n\n## What about `bot_data` and `chat_data`?\n`chat_data` works in the exact same way as `user_data`, except it is managed per *chat* instead of every *user*. Use `context.chat_data` to get access to this dict. As of version 12.4 `bot_data` is provided as well and works in the exact same way as `user_data`, except it's a single dictionary for your bot. Use `context.bot_data` to get access to this dict.\n\n## Notes & Tips\n- **Everything is stored in memory.** This means that all `bot_data`, `user_data` and `chat_data` is deleted when the bot process ends. If you don't want this, have a look at the [persistence page](Making-your-bot-persistent).\n - If not empty, `bot_data`, `user_data` and `chat_data` will be kept until the process ends.\n- `user_data` and `chat_data` are different dictionaries even for private chats.\n- You can not assign a new value to `bot_data`, `user_data` or `chat_data`. Instead of `user_data = {}` and `user_data = other_dict`, use `user_data.clear()` and/or `user_data.update(other_dict)` respectively.\n\n## Chat Migration\nIf a group chat migrates to supergroup, its chat id will change. Since the `chat_data` dicts are stored *per chat id* you'll need to transfer the data to the new id. Here are the two situations you may encounter:\n\n### Status Updates sent by Telegram\nWhen a group migrates, Telegram will send an update that just states the new info. In order to catch those, simply define a corresponding handler:\n\n```python\nasync def chat_migration(update, context):\n    message = update.message\n    application = context.application\n    application.migrate_chat_data(message=message)\n...\n\ndef main():\n    application = Application.builder().token('TOKEN').build()\n    application.add_handler(\n        MessageHandler(filters.StatusUpdate.MIGRATE, chat_migration)\n    )\n\n...\n```\nSee also: [`migrate_chat_data`](https://python-telegram-bot.readthedocs.io/telegram.ext.application.html#telegram.ext.Application.migrate_chat_data)\n\nTo be entirely sure that the update will be processed by this handler, either add it first or put it in its own group.\n\n### ⚠️ Note: Migration update comes duplicated\n> TLDR: Just ignore the second update\n\nYou may notice that your migration handler receives 2 updates consecutively when a group is migrated to a supergroup. The first update communicates the migration, and the second one _does the same thing_, but Telegram sends it with `from_user` set to an Anonymous user `GroupAnonymousBot`. They do this so older clients of Telegram - where every `Update` needs a `from_user` - don't crash. You can simply ignore the second update as it brings the same information but with different fields :)\n\n### ChatMigrated Errors\n\nIf you try e.g. sending a message to the old chat id, Telegram will respond by a `BadRequest` including the new chat id. You can access it using an error handler:\n\n```python\nasync def error(update, context):\n    \"\"\"Log Errors caused by Updates.\"\"\"\n    logger.warning('Update \"%s\" caused error \"%s\"', update, context.error)\n\n    if isinstance(context.error, ChatMigrated):\n        new_chat_id = context.error.new_chat_id\n```\nUnfortunately, Telegram does *not* pass along the old chat id, so there is currently no simple way to perform a data transfer like above within the error handler. So make sure, that you catch the status updates! Still, you can wrap your requests into a `try-except`-clause:\n\n```python\nasync def my_callback(update, context):\n    application = context.application\n    ...\n\n    try:\n        await context.bot.send_message(chat_id, text)\n    except ChatMigrated as exc:\n        new_id = exc.new_chat_id\n\n        # Resend to new chat id\n        await context.bot.send_message(new_id, text)\n\n        # Get old and new chat ids\n        old_id = update.message.migrate_from_chat_id or message.chat_id\n        new_id = update.message.migrate_to_chat_id or message.chat_id\n\n        # transfer data, only if old data is still present\n        # this step is important, as Telegram sends *two* updates\n        # about the migration\n        if old_id in application.chat_data:\n        application.migrate_chat_data(\n            old_chat_id=old_id,\n            new_chat_id=new_id\n        )\n    ...\n```\n"
    },
    {
        "name": "Storing-user--and-chat-related-data.md",
        "description": "This page is now over at [[Storing bot, user and chat related data|Storing-bot,-user-and-chat-related-data]]"
    },
    {
        "name": "Telegram-Passport.md",
        "description": "As of Bot API 4.0, Telegram added support for something they call Telegram Passport. It allows a bot developer to receive personal information such as ID documents, phone_number, email and more in a secure encrypted way. This page will teach you most of what you need to know to get starting with Telegram Passport as a bot developer.\n\nIf you're here because you received a warning from your bot about not having configured a private key, first be sure that you actually need to use Telegram Passport. If no key is configured, updates sent to your bot with passport data is simply ignored.\n\nPlease read the following article describing Telegram Passport from a user's perspective before continuing: [Introducing Telegram Passport](https://telegram.org/blog/passport)\n\n### Step 1) Make sure ptb is up to date\n\nPython-telegram-bot added support for Telegram Passport in version 11.0.0, so first make sure that your installation is up to date by upgrading using:\n\n``` console\n$ pip install python-telegram-bot --upgrade\n```\n\n### Step 2) Generating keys\n\nTelegram Passport requires that you generate encryption keys so that the data is transmitted securely. More info about asymmetric encryption can be found on [Wikipedia](https://en.wikipedia.org/wiki/Public-key_cryptography).\n\nThen make sure you have `openssl` installed by typing the command below in a console:\n\n```console\n$ openssl version\nOpenSSL 1.0.2o  27 Mar 2018\n```\n\nIf your output did not match the above (note that a newer or older version is fine) then you'll need to install openssl. A simple google search for `install openssl on [your OperatingSystem]` should show you how.\n\nNow you can generate your private key.\n\n```console\n$ openssl genrsa 2048 > private.key\n``` \n\nThis will create a file named `private.key` in your current folder.\n**Keep this file private at all times!** Anyone who has this file will be able to decrypt telegram passports meant for you.\n\nNext generate your public key.\n\n```console\n$ openssl rsa -in private.key -pubout\n-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0B\n[snip]\nKwIDAQAB\n-----END PUBLIC KEY-----\n```\n\nYou will need this key for two things. The first is registering it with @BotFather (next step). The other is every time you wanna call the Telegram Passport API from your website.\n\n### Step 3) Registering with @BotFather\nNext you wanna paste the public key you just generated, and then paste it into a chat with @BotFather after sending the `/setpublickey` command to him.\n\nAt this point you should also add a privacy policy to your bot if you don't already have one. This can be done via the `/setprivacypolicy` command. Note: this command expects a url, so you will need to host the privacy policy somewhere online.\n\n### Step 4) Set up \"Log in with Telegram\" button\nNow you need to set up the button that your users will press to be able to log in with Telegram. Telegram has written SDK (software development kits) to help you quickly get started with this. In this guide we will only use the Javascript SDK, but the instructions should be easy to adapt to an iOS/macOS or Android app.\n\nDetailed instructions about the Telegram Passport Javascript SDK can be found [here](https://core.telegram.org/passport/sdk-javascript). If you are developing a native app you will instead need to use the [iOS/macOS SDK](https://core.telegram.org/passport/sdk-ios-mac) or the [Android SDK](https://core.telegram.org/passport/sdk-android).\n\nTo get started, you will need a simple webpage where you have access to the HTML source code or similar. Then you will need to include the Javascript SDK and then call the `Telegram.Passport.createAuthButton` javascript function.\nIf you just want to quickly get started we have created a [sample html page example](https://github.com/python-telegram-bot/python-telegram-bot/blob/master/examples/passportbot.html) that you can just download, edit using an editor and then open in your preferred browser. (Note that you will need to [download the actual SDK file](https://github.com/TelegramMessenger/TGPassportJsSDK/blob/master/telegram-passport.js) and put it in the same folder as the HTML file)\n\nNext you will need to fill out your bot id (the numeral part before `:` in your bot token), scope (what data you would like to request), your public key (take care with newlines), the nonce, and the callback url.\n\n```javascript\nTelegram.Passport.createAuthButton('telegram_passport_auth', {\n    bot_id:       BOT_ID, // YOUR BOT ID\n    scope:        {data: [{type: 'id_document', selfie: true}, 'address_document', 'phone_number', 'email'], v: 1}, // WHAT DATA YOU WANT TO RECEIVE\n    public_key:   '-----BEGIN PUBLIC KEY----- ...', // YOUR PUBLIC KEY\n    nonce:      'thisisatest', // YOUR BOT WILL RECEIVE THIS DATA WITH THE REQUEST\n    callback_url: 'https://example.org' // TELEGRAM WILL SEND YOUR USER BACK TO THIS URL\n});\n```\n\nNote: For security purposes you should generate a random nonce for each user that visits your site, and ALWAYS verify it with your bot when you receive the passport data. If your site has a python backend something like [itsdangerous](https://pythonhosted.org/itsdangerous/) could come in handy - otherwise other HMAC signing methods should be safe too.\n\nNote: For simple testing using `https://example.org` as the callback_url is fine, but on real sites, this should be set to a url where users will be notified that they've been logged in successfully - after your bot has verified the passport data of course.\n\nNote: The documentation for the scope can be found [here](https://core.telegram.org/passport#passportscope). In the example above we are requesting an ID document (like passport, drivers license etc.) that includes a selfie, a document that shows the users' address, and their phone number and email. You can also use [Telegram Passport > Passport example](https://core.telegram.org/passport/example) to figure out the different scope combinations.\n\n### Step 5) Add a MessageHandler that accepts PassportData elements\nNow you wanna add a [MessageHandler](https://python-telegram-bot.readthedocs.io/en/latest/telegram.ext.messagehandler.html) to your dispatcher so that you are able to receive [Message](https://python-telegram-bot.readthedocs.io/en/latest/telegram.message.html) elements. This is because the [PassportData](https://python-telegram-bot.readthedocs.io/en/latest/telegram.passportdata.html) will be present as an attribute ([passport_data](https://python-telegram-bot.readthedocs.io/en/latest/telegram.message.html#telegram.Message.passport_data)) of [Message](https://python-telegram-bot.readthedocs.io/en/latest/telegram.message.html). If you want to limit a message handler to only receive Telegram Passports (recommended), use the [filters.PASSPORT_DATA ](https://python-telegram-bot.readthedocs.io/telegram.ext.filters.html#telegram.ext.filters.StatusUpdate) filter.\n\nIn our example folder you will find a [passportbot.py](https://github.com/python-telegram-bot/python-telegram-bot/blob/master/examples/passportbot.py) example bot script. This script will simply decrypt and print all Telegram Passport data that it receives. It will also download all [PassportFiles](https://python-telegram-bot.readthedocs.io/en/latest/telegram.passportfile.html) that it finds to the current directory. To get started with it, replace `TOKEN` with your bot token, and put your `private.key` in the same directory as the script.\n\n### Step 6) Test it!\nLast step is simply to run the bot, and then open the webpage in your browser and press the blue \"Login with Telegram\" button. After configuring a password and uploading the proper documents, you should see the data printed in your console.\n\n\n"
    },
    {
        "name": "Transition-guide-to-Version-12.0.md",
        "description": "## Table of contents\n* [Context based callbacks](#context-based-callbacks)\n    * [What exactly is CallbackContext](#what-exactly-is-callbackcontext)\n    * [Handler callbacks](#handler-callbacks)\n    * [Error handler callbacks](#error-handler-callbacks)\n    * [Job callbacks](#job-callbacks)\n    * [Note about group and groupdict](#note-about-group-and-groupdict)\n    * [Note about version 13](#note-about-version-13)\n    * [Custom handlers](#custom-handlers)\n* [Handler changes](#handler-changes)\n    * [CommandHandler](#commandhandler)\n    * [PrefixHandler](#prefixhandler)\n    * [MessageHandler](#messagehandler)\n    * [ConversationHandler](#conversationhandler)\n    * [Error Handler](#error-handler)\n* [Filters in handlers](#filters-in-handlers)\n    * [Special note about regex filters](#special-note-about-regex-filters)\n    * [Special note about `Filters.command` and `Filters.text`](#special-note-about-filterscommand-and-filterstext)\n* [Persistence](#persistence)\n* [Return UTC from from_timestamp()](#return-utc-from-from_timestamp)\n\n# Context based callbacks\nThe biggest change in this release is context based callbacks. When running your bot you will probably see a warning like the following:\n```\nechobot2.py:62: TelegramDeprecationWarning: Old Handler API is deprecated - see https://git.io/fxJuV for details\n```\nThis means you're using the old style callbacks and should upgrade to context based callbacks.\n\nThe first thing you should do is find where you create your `Updater`.\n``` python\nupdater = Updater('TOKEN')\n```\nAnd add `use_context=True` so it looks like\n```python\nupdater = Updater('TOKEN', use_context=True)\n```\n**Note that this is only necessary in version 12 of `python-telegram-bot`. Version 13 will have `use_context=True` set as default.**  \n_If you do **not** use `Updater` but only `Dispatcher` you should instead set `use_context=True` when you create the `Dispatcher`._\n\n## What exactly is `CallbackContext`\n[`CallbackContext`](https://python-telegram-bot.readthedocs.io/en/latest/telegram.ext.callbackcontext.html) is an object that contains all the extra context information regarding an `Update`, error or `Job`. It replaces the old behaviour with having a ton of `pass_something=True` in your handlers. Instead, all this data is available directly on the `CallbackContext` - always!\nSo what information is stored on a `CallbackContext`? The parameters marked with a star will only be set on specific updates.\n* bot\n* job_queue\n* update_queue\n* chat_data*\n* user_data*\n* job*\n* error*\n* args*\n* matches/match*\n\n## Handler callbacks\nNow on to the bulk of the change. You wanna change all your callback functions from the following:\n``` python\ndef start(bot, update, args, job_queue):\n    # Stuff here\n```\n\nto the new style using CallbackContext\n``` python\ndef start(update: Update, context: CallbackContext):\n    # Stuff here\n    # args will be available as context.args\n    # jobqueue will be available as context.jobqueue\n```\n_On python 2 which doesn't support annotations replace `update: Update, context: CallbackContext` with simply `update, context`._\n\n## Error handler callbacks\nError handler callbacks are the ones added using `Dispatcher.add_error_handler`. These have also been changed from the old form:\n```python\ndef error_callback(bot, update, error):\n    logger.warning('Update \"%s\" caused error \"%s\"', update, error)\n```\ninto\n```python\ndef error_callback(update, context):\n    logger.warning('Update \"%s\" caused error \"%s\"', update, context.error)\n```\n_Note that the error is now part of the `CallbackContext` object._\n\n## Job callbacks\nJob callbacks (the ones that are passed to `JobQueue.run_once` and similar) have also changed. Old form:\n``` python\ndef job_callback(bot, job):\n   bot.send_message(SOMEONE, job.context)\n```\nNew form:\n``` python\ndef job_callback(context):\n    job = context.job\n    context.bot.send_message(SOMEONE, job.context)\n```\n_Note that both bot, and job have been merged into the `CallbackContext` object._\n\n## Note about groups and groupdict\nBefore version 12, you could both pass_groups and pass_groupdict. Inside `CallbackContext` this has been combined into a single `Match` object. Therefore if your handler looked like this before:\n``` python\ndef like_callback(bot, update, groups, groupdict): # Registered with a RegexHandler with pattern (?i)i (like|dislike) (?P<thing>.*)\n    update.reply_text('You {} {}'.format(groups[1], groupdict['thing'])\n```\nIt would instead now look something like this:\n``` python\ndef like_callback(update, context): # Registered with a RegexHandler with pattern (?i)i (like|dislike) (?P<thing>.*)\n    update.reply_text('You {} {}'.format(context.match[1], context.match.groupdict()['thing'])\n```\nAlso see [Special note about regex filters](#special-note-about-regex-filters).\n\n## Note about version 13\nIn version 13 of `python-telegram-bot`, `use_context` will default to `True`. This means that your old handlers using pass_ will stop working. It also means that after upgrading to version 13, you can remove `use_context=True` from your `Updater` if you so desire.\n\n# Custom handlers\nThis part is only relevant if you've developed custom handlers, that subclass `telegram.ext.Handler`. To support the new context based callbacks, add a method called `collect_additional_context` to your handler. The method receives a `CallbackContext` object and whatever is return by `check_update()`, and should add whatever extra context is needed (at least everything that could be added via `pass_` arguments before). Note that `job_queue, update_queue, chat_data, user_data` is automatically added by the base `Handler`.\n\n***\n# Handler changes\nWe made some changes to the behaviour of some handlers. Listed below are the changes notable to you and maybe requires some action in your code.\n\n## CommandHandler\nFrom now on `CommandHandler` will only respond to [valid bot commands](https://core.telegram.org/bots#commands). It will raise `ValueError` when an invalid command is given as the `command` argument. If you previously used commands not considered valid by @botfather, you can use the new [PrefixHandler](#prefixhandler) instead.\nIn addition `allow_edited` is deprecated until V13, when it will be removed. The new default behavior is to accept both `message` and `edited_message` with a valid command. If you would like to exclude edited message from your CommandHandler pass `filters=~Filters.update.edited_message` to the constructor.\n\n## PrefixHandler\nNewly added is the `PrefixHandler`. [read the docs ](https://python-telegram-bot.readthedocs.io/en/latest/telegram.ext.prefixhandler.html) for more details on its use and implementation.\n\n## MessageHandler\n`MessageHandler` received some upgrades to switch to the filter system. We've removed `allow_edited` which has been deprecated for a while. Also we now deprecated `message_updates`, `channel_post_updates` and `edited_updates` in the constructor. The defaults have also changed to accepting **all updates** by default. This includes (edited_)channel_posts and (edited_)messages. To tweak the message you receive with MessageHandler, please use the [update filters](https://python-telegram-bot.readthedocs.io/en/latest/telegram.ext.filters.html#telegram.ext.filters.Filters.update).\n\n## RegexHandler\n`RegexHandler` is being deprecated. It's basically a MessageHandler with a `Filters.regex`, now the CallbackContext contains all match information. For now, we keep it in, but you should switch the use of `RegexHandler` to using `MessageHandler(Filters.regex('pattern'), callback)`.  \nSee [Special note about regex filters](#special-note-about-regex-filters) and [Note about group and groupdict](#note-about-group-and-groupdict) for more details.\n\n## ConversationHandler\nThe arguments `run_async_timeout` and `timed_out_behavior` have been removed.\nThe timeout for waiting for a @run_async handler is now always 0. If an update would have waited before, ConversationHandler will now try to use a handler in the new special state `ConversationHandler.WAITING`. This allows you to either manually wait in the handler if you want the old functionality, or send a message back to the user like \"I am still processing your last request, please wait\".\n\n## Error handler\nError handler got a major improvement. Instead of only handling TelegramErrors, every error from every handler will be passed to its callback.\n\nYou can use it for example to send yourself notifications if an error happened while your bot is running.\n\nNote: If an error handler callback is successfully executed, the error itself won't be caught by the logger module. If you still want this, reraise the error at the end of your function.\n\n***\n# Filters in handlers\nUsing a list of filters in a handler like below has been deprecated for a while now. Version 12 removes the ability completely.\n``` python\nMessageHandler([Filters.audio, Filters.video], your_callback)\n```\n## Combine filters using bitwise operators\nInstead, you can now combine filters using bitwise operators like below. (The pipe ( `|` ) character means OR, so the below is equivalent to the above example using a list).\n``` python\n# Handle messages that contain EITHER audio or video\nMessageHandler(Filters.audio | Filters.video, your_callback)\n```\n### Also supports AND, NOT and more than 3 filters\n**AND:**\n```python\n# Handle messages that are text AND contain a mention\nFilters.text & Filters.entity(MesageEntity.MENTION)\n```\n**NOT:**\n``` python\n# Handle messages that are NOT commands (same as Filters.text in most cases)\n~ Filters.command\n```\n**More advanced combinations:**\n``` python\n# Handle messages that are text and contain a link of some kind\nFilters.text & (Filters.entity(URL) | Filters.entity(TEXT_LINK))\n# Handle messages that are text but are not forwarded\nFilters.text & (~ Filters.forwarded)\n```\n\n### Special note about regex filters\nRegex filters can also be used in advanced combinations like so:  \n``` python\n((Filters.regex('(test)') | Filters.command) & (Filters.regex('(it)') | Filters.forwarded))\n```\nThis would make `context.matches` equal a list of regex matches, but only if the regex filter actually executed. This means that:\n * it will be a list with a single match for `test` if it's a command but not forwarded.\n * it will be a list with a single match for `it` if it's forwarded but not a command.\n * it will be a list of two matches. The first one will be `test` and the second one `it`.\nNote that in the last case, the order is the order that the filters were executed in, and not necessarily left to right.\n\nAlso note that `context.match` is a shortcut for `context.matches[0]`. Very useful when you are only interested in the first match.\n\n### Special note about `Filters.command` and `Filters.text`:\nAs of **version 12.4**, `Filters.command` checks for `MessageEntity.BOT_COMMAND` instead of a leading slash and accordingld, `Filters.text` accepts text with a leading slash. Use `Filters.text & (~Filters.command)` to filter for text messages that have no commands. For more details, please see the [changelog](https://python-telegram-bot.readthedocs.io/changelog.html#version-12-4-0) and the documentation on filters.\n\n***\n# Persistence\nIn version 12 we introduce persistence to the bot's mechanics. If you want to use this please read the [[wiki page|Making-your-bot-persistent]] dedicated to persistence.\n***\n# Return UTC from from_timestamp()\n\nfrom_timestamp() now returns UTC timestamps. The recommended way to work is to run your bot on a machine configured to UTC. This means that from now on. `telegram.Message.date` will always be in UTC format."
    },
    {
        "name": "Transition-guide-to-Version-13.0.md",
        "description": "## Table of contents\n- [Deprecations](#deprecations)\n  * [Old handler API](#old-handler-api)\n  * [Python 3.5](#python-35)\n  * [`Message.default_quote`](#-messagedefault-quote-)\n  * [`@run_async`](#run_async)\n- [Persistence of Bots](#persistence-of-bots)\n  * [Converting existing pickle files](#converting-existing-pickle-files)\n- [API Keyword Arguments](#api-keyword-arguments)\n- [JobQueue Refactored](#jobqueue-refactored)\n  * [Handling of timezones](#handling-of-time-zones)\n  * [Changes in advanced scheduling](#changes-in-advanced-scheduling)\n    + [New features](#new-features)\n    + [Changes](#changes)\n  * [Setting up a `JobQueue`](#setting-up-a--jobqueue-)\n- [Rich Comparison](#rich-comparison)\n  * [Special note on `Message`](#special-note-on--message-)\n- [Refactoring of Filters](#refactoring-of-filters)\n- [Special Note on `Updater.start_webhook`](#special-note-on-updaterstart_webhook)\n\n# Deprecations\n\n## Old handler API\n\nThe context-based API introduced in v12 is now the default, i.e. the `use_context` argument of the `Dispatcher`/`Updater` now defaults to `True`.\n\n## Python 3.5\n\nAs Python 3.5 reached its end of life on 2020-09-05, v13 drops support for Python 3.5. More precisely, some Python 3.6+-only features are introduced, making PTB incompatible with Python 3.5 as of v13.\n\n## `Message.default_quote`\n\n`Message` objects no longer have a `default_quote` attribute. Instead, `Message.bot.defaults.quote` is used. This happened in accordance with the refactoring of persistence of Bots.\n\n## `@run_async`\n\nIt has been a long-standing issue that methods decorated with `@run_async` have not received proper error handling. We therefore decided to *deprecate* the decorator. To run functions asynchronously, you now have two options, both of which support error handling:\n\n1. All the `Handler` classes have a new parameter `run_async`. By instantiating your handler as e.g. `CommandHandler('start', start, run_async=True)`, the callback (here `start`) will be run asynchronously.\n2. To run custom functions asynchronously, you can use `Dispatcher.run_async`. Here is a small example:\n\n    ```python\n    def custom_function(a, b=None):\n        pass\n\n    def my_callback(update, context):\n        a = 7\n        b = 'b'\n        context.dispatcher.run_async(custom_function, a, update=update, b=b)\n    ```\n    Of course the use of  `Dispatcher.run_async` is not limited to handler callbacks and you don't have to pass an `update` in that case. Passing the `update` when possible is just preferable because that way it's available in the error handlers.\n\nWhile `@run_async` will still work, we recommend switching to the new syntax, as the decorator will be deprecated over the course of the next releases. \n\n# Persistence of Bots\n\nStoring `Bot` objects (directly or e.g. as attributes of an PTB object) may lead to problems. For example, if you change\nthe `Defaults` object passed to your `Updater`, you would expect the loaded `Bot` instances to use the new defaults.\nFor that reason, v13 makes two changes:\n\n1. `Bot` instances are no longer picklable\n2. Instead, all subclasses of `BasePersistence` will replace all* `Bot` instances with a placeholder. When loading the data again,\nthe new `Bot` instance will be inserted.\n\nNote that changing the used bot token may lead to e.g. `Chat not found` errors.\n\n*Alright, almost all instances. For the limitations, see [`replace_bot`](https://python-telegram-bot.readthedocs.io/telegram.ext.basepersistence.html#telegram.ext.BasePersistence.replace_bot) and [`insert_bot`](https://python-telegram-bot.readthedocs.io/telegram.ext.basepersistence.html#telegram.ext.BasePersistence.insert_bot).\n\n## Converting existing pickle files\n\nIn order for v13s `PicklePersistence` to be able to read your pickle files, you need to convert them once *before* upgrading to v13.* We have prepared a [Gist](https://gist.github.com/Bibo-Joshi/5fd32dde338fba474fb15f40909c92f8) for that. Use [this version](https://gist.github.com/Bibo-Joshi/23b8c02249264256ded07661d0cd8a4f), if you're upgrading directly to v13.1. This is of course only needed if you store `Bot` instances somewhere. But if you're not sure, just run the Gist ;)\n\nIf you have a custom implementation of `BasePersistence` and you currently store `Bot` instances (or any PTB object that has a `bot` attribute, e.g. `Message`), you may need to do something similar. The above Gist is a good starting point in that case.\n\n*This is due to the fact that `PicklePersistence` uses `deepcopy`, which in turn uses the same interface as `pickle` and `Bots` are no longer pickable in v13…\n\n# API Keyword Arguments\n\nPre v13, the Bot methods accepted arbitrary keyword arguments via the `**kwargs` parameter. This was implemented in order to allow for minor API updates to be patched into PTB calls while there was no release of the library just yet. However, this also lead to editors not highlighting typos. For this reason, the `**kwargs` parameter was replaced by the `api_kwargs` parameter. This means that function calls like\n\n```python\nbot.send_message(..., custom_kwarg=42)\n```\n\nneed to be changed to\n\n```python\nbot.send_message(..., api_kwargs={'custom_kwarg': 42})\n```\nAs PTB is currently up to date with the Telegram API, this shouldn't affect your code. If it does, it probably means that you had a typo somewhere ;)\n\n# JobQueue Refactored\n\nPreviously, PTB implemented the scheduling of tasks inside the `JobQueue` manually. As timing logic is not always straightforward, maintaining the `JobQueue` was not easy and new features were only reluctantly added. To decrease development effort in that area, we refactored the `JobQueue` in v13. Now, it relies on the third party library [APScheduler](https://apscheduler.readthedocs.io/) behind the scenes.\n\nBut what does this mean for you in detail? If you're scheduling tasks vanilla style as e.g.\n\n```python\ncontext.job_queue.run_once(callback, when)\n```\n\nyou will only have to change the handling of time zones, or likely nothing at all. In fact, everything covered in this [[wiki article|Extensions---JobQueue]] will work unchanged except for time zones. So before bothering to read on, just try to run you bot - in most cases it will still work. However, there are some more advanced things which changed.\n\n## Handling of time zones\n\nThe `APScheduler` library only accepts time zones provided by the `pytz` library. If you pass time zone aware objects for job creating, you will need to take that into account.\n\n## Changes in advanced scheduling\n\nLeveraging the APScheduler library brings both some perks in terms of new features as well as some breaking changes. Please keep in mind:\n\n* PTBs `JobQueue` provides an easy and ready to use way of scheduling tasks which ties in with the PTB architecture\n* Managing scheduling logic is not the main intend of PTB and hence a third party library is used for that now\n* If you need highly customized scheduling, you *can* use these advanced features of the third party library\n* We can't guarantee that the back end will stay the same forever. For example, if APScheduler is discontinued, we will have to look for alternatives.\n\nThat said, here are the perks and changes:\n\n### New features\n\n* `run_repeating` now has a `last` parameter as originally proposed in #1333 \n* `JobQueue.run_custom` allows you to run a job with a custom scheduling logic. See the APS [User Guide](https://apscheduler.readthedocs.io/userguide.html) and the page on [how to combine triggers](https://apscheduler.readthedocs.io/modules/triggers/combining.html#module-apscheduler.triggers.combining) for more details.\n* All methods `JobQueue.run_*` now have a `job_kwargs` argument that accepts a dictionary. Use this to specify additional kwargs for [`JobQueue.scheduler.add_job()`](https://apscheduler.readthedocs.io/modules/schedulers/base.html#apscheduler.schedulers.base.BaseScheduler.add_job).\n* Persistence of jobs: APScheduler has it's own logic of persisting jobs. Because of the aforementioned reasons, we decided to not integrate this logic with PTBs own persistence logic (at least for now). You may however set up persistence for jobs yourself. See the APS [User Guide](https://apscheduler.readthedocs.io/userguide.html) for details.\n\n### Changes\n\nMost importantly, the `Job` class is now a wrapper for APSchedulers own `Job` class, i.e. `job.job` is an `apscheduler.job` (don't get confused here!). In particular, attributes like `days`, `interval` and `is_monthly` were removed. Some of those could previously be used to alter the scheduling of the job. You will now have to use `job.job.modify` for that. Please see the [APScheduler docs](https://apscheduler.readthedocs.io/modules/job.html#apscheduler.job.Job.modify) for details.\n\nThere are some other minor changes, most of which will likely not affect you. For details, please see the documentation of [`JobQueue`](https://python-telegram-bot.readthedocs.io/telegram.ext.jobqueue.html) and [`Job`](https://python-telegram-bot.readthedocs.io/telegram.ext.job.html).\n\n## Setting up a `JobQueue`\n\nPassing a `Bot` instance to the `JobQueue` has been deprecated for a while now. v13 removes this completely. Use `JobQueue.set_dispatcher()` instead.\n\n# Rich Comparison\n\nv13 adds rich comparison to more Telegram objects. This means that e.g. `inline_keyboard_1 == inline_keyboard_2` is not equivalent to `inline_keyboard_1 is inline_keyboard_2`, but all the buttons will be compared. For each class supporting rich comparison, the documentation now explicitly states how equality of the class objects is determined. Warnings will be raised when trying to compare Telegram objects that don't support rich comparison.\n\n## Special note on `Message`\n\nPre-v13, comparing `Message` objects only compared the `message_id`. As those are not globally unique, as of v13, `message.chat` is compared as well, i.e. messages with the same `message_id` sent in different chats are no longer evaluated as equal. While strictly speaking this is a breaking change, it shouldn't affect your code.\n\n# Refactoring of Filters\n\nIn order to reduce confusion over the arguments of the `filter()` method, the handling of message filters vs update filters was refined. v13 brings two classes\n\n* `telegram.ext.MessageFilter`, where `MessageFilter.filter()` accepts a `telegram.Message` object (the `update.effective_message`)\n\nand\n\n* `telegram.ext.UpdateFilter`, where `UpdateFilter.filter()` accepts a `telegram.Update` object (the `update`),\n\nboth inheriting from `BaseFilter`.\n\nIf you have custom filters inheriting from `BaseFilter`, you will need to change their parent class to `MessageFilter` or, if you're currently setting `update_filter = True`, to `UpdateFilter`. In that case, you can remove the `update_filter = True`.\n\n# Special Note on `Updater.start_webhook`\n\nIf you're upgrading directly to v13.4+ and use something like\n\n```python\nupdater.start_webhook(…)\nupdater.bot.set_webhook(my_url)\n```\nyou will have to change that to\n```python\nupdater.start_webhook(…, webhook_url=my_url)\n```\n"
    },
    {
        "name": "Transition-guide-to-Version-20.0.md",
        "description": "## Introduction\n\nThis transition guide aims to easy transitions from v13.x to v20.0 by listing relevant changes between these versions.\nIt's important to note that this transition guide will not cover every last one of the many smaller changes that came along with the bigger structural changes.\nIf you notice that some non trivial change is missing in here, feel free to add it.\n\n## Table of contents\n\n- [Transition Script](#transition-script)\n- [Structural changes & Deprecations](#structural-changes---deprecations)\n  * [Overall architecture](#overall-architecture)\n  * [`asyncio`](#asyncio)\n  * [Optional Dependencies](#optional-dependencies)\n  * [Refinement of the public API](#refinement-of-the-public-api)\n  * [`__slots__`](##__slots__)\n  * [Keyword Only Arguments](#keyword-only-arguments)\n  * [Initialization of Telegram Classes](#initialization-of-telegram-classes)\n  * [Immutability](#immutability)\n  * [Removed features](#removed-features)\n- [Changes for specific modules, classes & functions](#changes-for-specific-modules--classes---functions)\n  * [`telegram`](#telegram)\n    + [Several classes](#several-classes)\n    + [Networking Backend](#networking-backend)\n    + [`telegram.ChatAction`](#telegramchataction)\n    + [`telegram.constants`](#telegramconstants)\n    + [`telegram.Bot`](#telegrambot)\n    + [`telegram.EncryptedPassportElement`](#telegramencryptedpassportelement)\n    + [`telegram.error`](#telegramerror)\n    + [`telegram.File`](#telegramfile)\n    + [`telegram.ForceReply`](#telegramforcereply)\n    + [`telegram.InlineQuery.answer`](#telegraminlinequeryanswer)\n    + [`telegram.InputFile.is_image`](#telegraminputfileis_image)\n    + [`telegram.ParseMode`](#telegramparsemode)\n    + [`telegram.PassportFile`](#telegrampassportfile)\n    + [`telegram.ReplyMarkup`](#telegramreplymarkup)\n    + [`telegram.VideoChat`](#telegramvideochat)\n  * [`telegram.ext`](#telegramext)\n    + [`BasePersistence`](#basepersistenca)\n      - [`asyncio`](#asyncio-1)\n      - [Data must be copyable](#data-must-be-copyable)\n      - [Persisting `telegram.Bot` instances.](#persisting-telegrambot-instances)\n      - [Return value of `get_{user, chat}_data`](#return-value-of-get_user-chat_data)\n      - [Abstract methods](#abstract-methods)\n      - [`store_*_data`](#store__data)\n    + [`CallbackContext`](#callbackcontext)\n    + [`CommandHandler`](#commandhandler)\n    + [`ConversationHandler`](#conversationhandler)\n    + [`filters`](#filters)\n    + [`Handler`](#handler)\n    + [`PrefixHandler`](#prefixhandler)\n    + [`JobQueue`](#jobqueue)\n      - [New arguments `{chat, user}_id`](#new-arguments-chat-user_id)\n      - [`context` argument](#context-argument)\n      - [`Job.run_daily`](#jobrun_daily)\n      - [`JobQueue.run_monthly`](#jobqueuerun_monthly)\n    + [`Job`](#job)\n      - [Removed the attribute `job_queue`](#removed-the-attribute-job_queue)\n      - [Attribute `Job.context`](#attribute-jobcontext)\n    + [`PicklePersistence`](#picklepersistence)\n    + [`Updater`](#updater)\n    + [`Application`/`Dispatcher`](#applicationdispatcher)\n      - [`user/chat_data`](#userchat_data)\n\n# Transition Script\n\nWe have prepared a script that is aimed at easing the transition for you.\nNote that this script currently just does some regex-based search & replace take some of the transition work off your shoulders.\nIt is no way a substitute for reading this transition guide and manually adjusting your code base.\nIn addition to the script, we recommend using a language interpreter (e.g. `pylint`) and a static type checker (e.g. `mypy`) on your code base to minimize the trial-and-error time during transitioning at a minimum.\nYou can find the script [[here|/assets/v20_code_transition.py]].\n\nContributions that fine tune or extend the script are welcome (you must clone the wiki repo to make changes)!\n\n# Structural changes & Deprecations\n\n## Overall architecture\n\n`ext.Updater` is no longer the entry point to a PTB program and we have replaced the `ext.Dispatcher` class with the new class `ext.Application`.\n\nThe `Application` is the new entry point to a PTB program and binds all its components together. The following diagram gives you an overview.\n\n<details><summary>Click to show the diagram</summary>\n\n[[/assets/ptb_architecture.png]]\n\n</details>\n\nWhen initializing an `Application`, many settings can be configured for the individual components.\nIn an effort to make this instantiation both clear and clean, we adopted the so-called [builder pattern](https://en.wikipedia.org/wiki/Builder_pattern).\nThis means that instead of passing arguments directly to `Application`, one creates a builder via `Application.builder()` and then specifies all required arguments via that builder.\nFinally, the `Application` is created by calling `builder.build()`. A simple example is\n\n```python\nfrom telegram.ext import Application, CommandHandler\napplication = Application.builder().token('TOKEN').build()\napplication.add_handler(CommandHandler('start', start_callback))\napplication.run_polling()\n```\n\nWe hope that this design makes it easier for you to understand what goes where and also simplifies setups of customized solutions, e.g. if you want to use a custom webhook.\n\nThere is also a [[standalone wiki page|Builder-Pattern]] just about this topic.\n\n## `asyncio`\n\nThe deepest structural change is introducing the `asyncio` module into `python-telegram-bot`.\n\n> [`asyncio`](https://docs.python.org/3/library/asyncio.html) is a library to write concurrent code using the `async`/`await` syntax.\n\nWhat does this mean and why do we care?\n\n`python-telegram-bot` is a library with the main purpose of communicating with the Telegram Bot API via web requests.\nWhen making web requests, your code usually spends a *lot* of time with - waiting.\nNamely, waiting for a response from Telegram.\nThe same holds for many so-called input-output (I/O) tasks.\nInstead of sitting around, your program could already do other stuff in that time.\n\nSo far, PTB has build on the [`threading`](https://docs.python.org/3/library/threading.html) library to overcome this issue.\n\n`asyncio` is a modern alternative to `threading` that comes with multiple advantages.\nCovering those or an introduction to how using `asyncio` works, is sadly beyond the scope of this transition guide or the PTB resources in general.\nSearching for `python asyncio introduction` or `python asyncio vs threading` in your favorite search engine will yield numerous results that will help you get up to speed.\n\nThe main points of what `asyncio` changed in PTB are:\n\n* PTB doesn't use threads anymore. It is also not thread safe!\n* All API methods of `telegram.Bot` are now coroutine functions, i.e. you have to `await` them\n* All handler & job callbacks must be coroutine functions, i.e. you need to change `def callback(update, context)` to `async def callback(update, context)`.\n* the `run_async` parameter of the handlers was replaced by the `block` parameter, which has a similar functionality. More details on this can be found on [[this page|Concurrency]].\n* The method `Dispatcher.run_async` doesn't exist anymore. Something that comes close to its functionality is `Application.create_task` (more on `Application` below). More details on this can be found on [[this page|Concurrency]].\n* All methods that make calls to coroutines or perform any I/O bound tasks are now coroutine functions.\nThis includes all abstract methods of `BasePersistence`. Listing them all here would be too long. When in doubt, please consult the documentation at [ReadTheDocs](https://python-telegram-bot.readthedocs.io).\n\n## Optional Dependencies\n\nSome of the functionality of the `telegram` and `telegram.ext` modules rely on 3rd party dependencies.\nSince these features are optional to use and we aim to keep the footprint of `python-telegram-bot` small, we have reduced the number of 3rd party dependencies that automatically get's installed along with `python-telegram-bot` to a minimum.\nAs of v20.0a5, only the 3rd party library `httpx` is installed, which is used for the default networking backend `HTTPXRequest`.\nIf you wish to use any of the optional features of the `telegram` and `telegram.ext` modules, you will have to specify that while installing `python-telegram-bot` from now on.\nPlease have a look at [the readme](https://docs.python-telegram-bot.org/#optional-dependencies) for further details.\n\n## Refinement of the public API\n\nWe've made an effort to make it clearer which parts of `python-telegram-bot` can be considered to be part of the public interface that users are allowed to use. To phrase it the other way around: Which parts are internals of `python-telegram-bot` are implementation details that might change without notice. Notably this means:\n\n1. Only non-private modules are part of the public API and you should import classes & functions the way they are described in the docs. E.g. `from telegram.error import TelegramError` is fine, but `from telegram._message import Message` is strongly discouraged - use `from telegram import Message` instead.\n2. We have removed the module `telegram.utils`. The parts of this module that we consider to be part of the public API have been moved into the modules `telegram.{helpers, request, warnings}`.\n\n## `__slots__`\n\nWe introduced the usage of `__slots__` in v13.6, which can reduce memory usage and improve performance. In v20 we removed the ability to set custom attributes on all objects except for `ext.CallbackContext`. To store data, we recommend to use PTB's built-in mechanism for [storing data](Storing-bot,-user-and-chat-related-data) instead. If you want to add additional functionality to some class, we suggest subclassing it.\n\n## Keyword-Only arguments\n\nSince v20.0a1, all arguments of bot methods that were added by PTB are now keyword-only arguments.\nMost importantly, this covers the `*_timeout` and `api_kwargs` arguments.\n\n## Initialization of Telegram Classes\n\nSince v20.0a5, `TelegramObject` and it's subclasses no longer accept arbitrary keyword arguments (`**kwargs`). These were formerly used to ensure that PTB wouldn't break when Telegram added new fields to existing classes.\nInstead, `TelegramObject` and it's subclasses now have an argument `api_kwargs` that will be used to store fields that are passed by Telegram and that PTB did not yet incorporate. These fields will also be available via the `api_kwargs` *attribute*.\n\n## Immutability\n\nAny data objects received by Telegram represent a current state on the Telegram servers, that only be changed by making a request to Telegram (or even not at all).\nWe hence decided to make `TelegramObject` and all of its subclasses immutable, meaning:\n\n* Attributes of these classes can neither be changed nor deleted. For example `update.message = new_message` or `del update.message` will both raise `AttributeErrors`\n* Any attributes that contain a list/an array of items are now of the immutable type `tuple`. For example, `Message.photo` is now a `tuple` instead of a `list`\n* All API methods of the `telegram.Bot` class that return a list/an array of items now return an immutable `tuple`. For example, the return value of `get_chat_administrators` is now a `tuple` instead of a `list`\n\nIf these changes have an effect on your current code, we highly recommend to overthink your code design.\nKeep in mind that for storing data in memory, PTB provides a handy [built-in solution](Storing-bot,-user-and-chat-related-data).\n\nThese changes were introduced in v20.0b0.\n\n## Removed features\n\nWe made a cut and dropped all deprecated functionality. Most importantly, this includes the old-style handler API, which was deprecated in [[Version 12|Transition-guide-to-Version-12.0#context-based-callbacks]], and the `MessageQueue`. As replacement for the `MessageQueue`, `telegram.ext.{Base, AIO}RateLimiter` where introduced in v20.0a3 (see also [this wiki page](https://github.com/python-telegram-bot/python-telegram-bot/wiki/Avoiding-flood-limits)).\n\n# Changes for specific modules, classes & functions\n\n## `telegram`\n\nPreviously some parts of `telegram.{error, constants}` where available directly via the `telegram` package - e.g. `from telegram import TelegramError`. These imports will no longer work. Only classes that directly reflect the official Bot API are now available directly via the `telegram` package. Constants and errors are available via the modules `telegram.{error, constants}` - e.g. `from telegram.error import TelegramError`.\n\n### Several classes\n\nPreviously, some classes (like `telegram.{Message, User, Chat}`) had an attribute `bot` that was used for the shortcuts (e.g. `Message.reply_text`). This attribute was removed.\nInstead, the new method `TelegramObject.{set, get}_bot()` are used.\n\n### Networking backend\n\nPreviously, the class `telegram.utils.request.Request` formed the networking backend of PTB.\nThis class has been removed.\nInstead, there is the new module `telegram.request`, which contains an interface class `BaseRequest` as well as an implementation `HTTPXRequest` of that class via the `httpx` library.\nBy default, the `HTTPXRequest` class is used for the networking backend.\nAdvanced users may use a custom backend by implementing a custom subclass of `BaseRequest`.\nSee [[this page|Architecture]] for more information on that.\n\n### `telegram.ChatAction`\n\nThis class was removed as it is not part of the official Bot API. Use `telegram.constants.ChatAction` instead.\n\n### `telegram.constants`\n\nThis module was rewritten from scratch. The constants are now grouped with the help of [Enums](https://docs.python.org/3/library/enum.html#enum.Enum).\n\n### `telegram.Bot`\n\n* The class has a new argument `get_updates_request` in addition to `request` and the corresponding request instance will be used exclusively for calling `getUpdates`.\n* The argument `media` of `Bot.edit_message_media` is now the first positional argument as specified by the Bot API.\n* The argument `url` of `Bot.set_webhook` is now required as specified by the Bot API.\n* The argument `description` of `Bot.set_chat_description` is now optional as specified by the Bot API.\n\n### `telegram.EncryptedPassportElement`\n\nThe argument `hash` is now the second positional argument as specified by the Bot API.\n\n### `telegram.error`\n\n`telegram.error.Unauthorized` was replaced by `telegram.error.Forbidden`.\nMoreover, `telegram.error.Forbidden` is now only raised if your bot tries to perform actions that it doesn't have enough rights for.\nIn case your bot token is invalid, `telegram.error.InvalidToken` is raised.\n\n### `telegram.File`\n\nThe method `File.download` was split into the two methods `File.download_to_drive` and `File.download_to_memory`.\nFor `download_to_drive`, the `custom_path` parameter now also accepts `pathlib.Path` objects.\nMoreover instead of returning the file path as string, it's now returned as `pathlib.Path` object.\n\n### `telegram.ForceReply`\n\nThe argument `force_reply` was removed, since it *always* must be `True` anyway.\n\n### `telegram.InlineQuery.answer`\n\nIf both parameters `current_offset` and `auto_pagination` are supplied, the method now raises a `ValueError` rather than a `TypeError`.\n\n### `telegram.InputFile.is_image`\n\nThis method was removed in v20.0a1.\n\n### `telegram.ParseMode`\n\nThis class was removed as it is not part of the official Bot API. Use `telegram.constants.ParseMode` instead.\n\n### `telegram.PassportFile`\n\nThe argument `file_size` is now optional as specified by the Bot API.\n\n### `telegram.ReplyMarkup`\n\nThis class was removed as it is not part of the official Bot API.\n\n### `telegram.VideoChat`\n\nThe argument `users` is now optional as specified by the Bot API.\n\n## `telegram.ext`\n\n### `BasePersistence`\n\n#### `asyncio`\n\nAll abstract methods are now coroutine functions as implementations should be able to perform I/O tasks in a non-blocking way.\n\n#### Data must be copyable\n\nAny data passed to persistence will be copied with [`copy.deepcopy`](https://docs.python.org/3/library/copy.html#copy.deepcopy).\nThis requirement is in place to avoid race conditions.\n\n#### Persisting `telegram.Bot` instances.\n\nIn [[Version 13|Transition-guide-to-Version-13.0]], we introduced a mechanism that replaces any `telegram.Bot` instance with a placeholder automatically *before* `update_*_data` was called and inserts the instance back into the return value of `get_*_data`. Unfortunately, this mechanism has proven to be unstable and also slow.\n\nWe have therefore decided to remove this functionality. `Bot` instances should still not be serialized, but handling this is now the responsibility of the specific implementation of `BasePersistence`. For example, `ext.PicklePersistence` uses the built-in functionality of the `pickle` module to achieve the same effect in a more reliable way.\n\nMore detailed information on this can be found in the documentation of `{Base, Pickle}Persistence`.\n\n#### Return value of `get_{user, chat}_data`\n\n`BasePersistence.get_{user, chat}_data` are no longer expected to return `collections.defaultdict`. Instead, they may return plain `dicts`.\n\n#### Abstract methods\n\n`BasePersistence` made a full transition to an abstract base class. This means that now all methods that a subclass should implement are marked as `abc.abstractmethod`. If e.g. you don't need `update_bot_data` because your persistence class is not supposed to store `bot_data`, you will still have to override that method, but you can simply make it `pass`.\n\n#### `store_*_data`\n\nThe parameters & attributes `store_{user,chat,bot}_data` were removed. Instead, these settings were combined into the argument/attribute `store_data`, which accepts an instance of the new helper class [`telegram.ext.PersistenceInput`](https://python-telegram-bot.readthedocs.io/en/latest/telegram.ext.persistenceinput.html#telegram-ext-persistenceinput).\n\nNote that `callback_data` is now persisted by default.\n\n### `CallbackContext`\n\n* `CallbackContext.from_error` has a new optional argument `job`. When an exception happens inside a `ext.Job` callback, this parameter will be passed.\n* Accordingly, the attribute `CallbackContext.job` will now also be present in error handlers if the error was caused by a `ext.Job`.\n* v20.0a1 removed the constant `CallbackContext.DEFAULT_TYPE`. That constant can now be found as `ContextTypes.DEFAULT_TYPE`.\n\n### `CommandHandler`\n\nThe attribute `commands` was made immutable in v20.0a1.\n\n### `ConversationHandler`\n\nConversationHandler now raises warnings for more handlers which are added in the wrong context/shouldn't be in the handler at all.\n\n### `filters`\n\nThe `ext.filters` module was rewritten almost from scratch and uses a new namespace policy. The changes are roughly as follows:\n\n1. `telegram.ext.Filters` no longer exists. Instead, use the module `telegram.ext.filters` directly. For example, `Filters.text` has to be replaced by `filters.TEXT`\n2. Already instantiated filters that don't need arguments are now in `SCREAMING_SNAKE_CASE`, e.g. `filters.TEXT`. Filter *classes* that do need arguments to be used are now in `CamelCase`, e.g. `filters.User`.\n3. For filters that are closely related, we now use a namespace class to group them. For example, `filters.Document` can not be used in `MessageHandler`. To filter for messages with *any* document attached, use `filters.Document.ALL` instead.\n\nMoreover, filters are no longer callable. To check if a filter accepts an update, use the new syntax `my_filter.check_update(update)` instead.\n\n### `Handler`\n\nv20.0a1 renamed the class `Handler` to `BaseHandler` in an effort to emphasize that this class is an abstract base class.\n\n### `PrefixHandler`\n\nSince v20.0a1, this is no longer a subclass of `CommandHandler`.\nMoreover, the prefixes and commands are no longer mutable.\n\n### `JobQueue`\n\n#### New arguments `{chat, user}_id`\n\nAll scheduling methods (`JobQueue.run_*`) have two new arguments `{chat, user}_id`, which allows to easily associate a user/chat with a job. By specifying these arguments, the corresponding ID will be available in the job callback via `context.job.{chat, user}_id`.\n\nMoreover, `context.{chat, user}_data` will be available. This has some subtle advantages over the previous workaround `job_queue.run_*(..., context=context.chat_data)` and we recommend using this new feature instead.\n\n#### `context` argument\n\nTo address the frequent confusion about `context` vs `context.job.context`, v20.0a1 renamed the argument `context` of all `JobQueue.run_*` methods to `data`.\nThis also covers the corresponding attribute of `Job`.\n\n#### `Job.run_daily`\n\nSince v20.0a1, the behavior of this method is aligned with `cron`, i.e. 0 is Sunday and 6 is Saturday.\n\n#### `JobQueue.run_monthly`\n\nUnfortunately, the `day_is_strict` argument was not working correctly (see [#2627](../issues/2627)) and was therefore removed. Instead, you can now pass `day='last'` to make the job run on the last day of the month.\n\n### `Job`\n\n#### Removed the attribute `job_queue`\n\nThis was removed because if you have access to a job, then you also have access to either the `JobQueue` directly or at least a `CallbackContext` instance, which already contains the `job_queue`.\n\n#### Attribute `Job.context`\n\nTo address the frequent confusion about `context` vs `context.job.context`, v20.0a1 renamed the argument `context` of all `JobQueue.run_*` methods to `data` and renamed `Job.context` to `Job.data`.\n\n### `PicklePersistence`\n\n* The argument `filename` was renamed to `filepath` and now also accepts a `pathlib.Path` object\n* [Changes to `BasePersistence`](#basepersistence) also affect this class.\n\nWe have prepared a script that will help you convert your v13 pickle-files into v20 pickle files.\nNote that this script is a best-effort solution for a conversion - for some special cases, a conversion may not be possible without adjusting the v13 data before.\nYou can find the script [[here|/assets/v20_picklepersistence_transition.py]].\n\n### `Updater`\n\nThe sole purpose of this class now is to fetch updates from Telegram. It now only accepts the arguments `bot` and `update_queue` and only has those attributes.\n\n### `Application`/`Dispatcher`\n\n#### `user/chat_data`\n\nIf you were modifying the `user/chat_data` of `Dispatcher` directly e.g. by doing `context.dispatcher.chat_data[id] = ...`, then this will now not work. [`Application.user/chat_data`](https://python-telegram-bot.readthedocs.io/en/latest/telegram.ext.application.html#telegram.ext.Application.chat_data) is now read only. Note that `context.chat/user_data[key] = ...` will still work.\n"
    },
    {
        "name": "Transition-guide-to-Version-4.0.md",
        "description": "# What's new?\nAll changes can also be reviewed in our [official documentation](http://python-telegram-bot.readthedocs.io/)!\n## Dispatcher\n\n**For users coming from RC release predating 26th of April, 2016**: \n- Changes in \"filters\" syntax (upper/lower case)\n- Handler groups are now identified by `int` only, and are processed in order, smallest first.\n\nThe `Dispatcher` class has now a cleaner interface and more precise Message filtering. Instead of many methods with long names like `Dispatcher.addTelegramMessageHandler(handler)`, we now only have two of those methods:\n\n> #### `add_handler(handler, group=0)`\n> Register a handler.\n>\n> TL;DR: Order and priority counts. 0 or 1 handlers per group will be used.\n>\n> A handler must be an instance of a subclass of `telegram.ext.Handler`. All handlers are organized in groups with a numeric value. The default group is `0`. All groups will be evaluated for handling an update, but only 0 or 1 handler per group will be used.\n>\n> The priority/order of handlers is determined as follows:\n>\n> - Priority of the group (lower group number == higher priority)\n> - The first handler in a group which should handle an update will be used. Other handlers from the group will not be used. The order in which handlers were added to the group defines the priority.\n\n> ##### Parameters:\n> `handler (Handler)` - A Handler instance  \n> `group (optional[int])` - The group identifier. Default is `0`\n\n> #### `add_error_handler(callback)`\n\n> This method remains unchanged, only the name has been changed to snake_case.\n\nSo, the `add_handler` method is accepting an object of a subclass of `telegram.ext.Handler`. Let's see how that looks in real life:\n\n```python\nfrom telegram.ext import MessageHandler, Filters\n\ndef text_callback(bot, update):\n  print(\"New text message: \" + update.message.text)\n\ndispatcher.add_handler(MessageHandler([Filters.text], text_callback))\n```\n\nAs you can see here, the `MessageHandler` class is one of the included `Handler` subclasses. All that was possible before is still possible, but now more organized and more explicit. Lets take a quick look at another handler class, the `RegexHandler`:\n\n```python\nfrom telegram.ext import RegexHandler\n\ndef name_callback(bot, update, groupdict):\n  print(\"The name of the user is: \" + groupdict['name'])\n\nname_regex = r'My name is (?P<name>.*)'\ndispatcher.add_handler(RegexHandler(name_regex, text_callback, pass_groupdict=True))\n```\nHere you can see the optional argument `groupdict` passed to the handler callback function. Note that it is necessary to specify this explicitly when creating the `Handler` object.\n\n### Other changes\n* You can easily implement your own handlers. Just subclass `telegram.ext.handler` and take a look at the implementation of the provided handlers.\n* Instead of `addTelegramInlineHandler` there are now `InlineHandler`, `ChosenInlineResultHandler` and `CallbackQueryHandler`\n* There is no replacement for `addUnknownTelegramCommandHandler`. Instead, it is recommended to use `RegexHandler(r'/.*', ...)` and add it as the last handler\n* The `UpdateQueue` class and `context` parameters have been removed\n\n## Bot API 2.0\n\nPlease read the documentation of the [Telegram Bot API](https://core.telegram.org/bots/api#recent-changes) to learn about all the new things in version 2 of the bot API. This section covers only those changes that are not backwards compatible and not listed in the **Recent Changes** list.\n\n* `new_chat_participant` and `left_chat_participant` of the `Message` class are now `new_chat_member` and `left_chat_member`\n* The following parameters on `InlineResult` and `InlineQueryResult` objects are removed in favor of `InlineMessageContent`:\n - message_text\n - parse_mode\n - disable_web_page_preview\n* In `InlineQueryResultPhoto` the parameter `mime_type` has been removed. JPEG is now required.\n* `ReplyKeyboardMarkup` now takes a list of a list of `KeyboardButton` instead of strings.\n - From v4.0.2 you can use `str` again\n\n## The `telegram.ext` module\n\nThe classes `Updater`, `Dispatcher` and `JobQueue` that were previously available for import directly `from telegram` are now located in `telegram.ext`."
    },
    {
        "name": "Transition-guide-to-Version-5.0.md",
        "description": "## JobQueue\nWe did some serious work on the `telegram.ext.JobQueue` class. The changes are similar to the changes made to the `telegram.ext.Dispatcher` class in version 4. The [[Extensions - JobQueue|Extensions---JobQueue]] article has been updated with the changes.\n\n## Botan\nBotan was moved from `telegram.utils.botan` to `telegram.contrib.botan`\n\n## New: ConversationHandler\nThe `telegram.ext.ConversationHandler` class has been added. It implements a [state machine](https://en.wikipedia.org/wiki/Finite-state_machine) and replaces the old `state_machine_bot.py` example with the new [`conversationbot.py`](https://github.com/python-telegram-bot/python-telegram-bot/blob/master/examples/conversationbot.py) example. [Read the documentation](http://python-telegram-bot.readthedocs.io/en/latest/telegram.ext.conversationhandler.html) for more information."
    },
    {
        "name": "Type-Checking.md",
        "description": "# Using Type Checkers with PTB\n\nSince Python 3.6, static type hinting is established in Python and PTB makes use of it (since v13.0). Static type checking helps to avoid and find errors both in PTBs source code and in your bot code. If you want to take advantage of this, you should use a type checker to check your code. As type checking in general is not PTB specific and a big topic, an introduction to type hinting is beyond the scope of this wiki.\n\n### ℹ️ Note\n\nWhile static type hints *are* of great value and we try our best to make them as precise as possible, they usually don't have any implications on runtime behavior. It therefore may happen that some type hints are not perfect or outright wrong and we may change & fix them between minor versions without announcement. This may lead to your type checker reporting errors after an upgrade, but it won't introduce bugs into your code.\n\nPlease also note that type hinting in Python does not cover all edge cases, so there might be situations where PTB just can't do better.\n\nOf course, you are always welcome to report any type hinting errors through the bug tracker.\n\n## Generic classes in PTB\n\nSome of the classes in `telegram.ext` that may be subclassed by users are generic classes, i.e. subclasses of [`typing.Generic`](https://docs.python.org/3/library/typing.html#typing.Generic).\nWhen subclassing them, the type variables should be specified.\nThese classes currently are `telegram.ext.Handler`, `telegram.ext.BasePersistence` and `telegram.ext.CallbackContext`.\nPlease have a look at the respective documentation page for more info on the type variables that these classes accept."
    },
    {
        "name": "Types-of-Handlers.md",
        "description": "A `Handler` is an instance derived from the base class [`telegram.ext.BaseHandler`](https://docs.python-telegram-bot.org/telegram.ext.basehandler.html#telegram.ext.BaseHandler) which is responsible for the routing of different kinds of updates (text, audio, inlinequery, button presses, ...) to their _corresponding callback function_ in your code.\n\nFor example, if you want your bot to respond to the command `/start`, you can use a [`telegram.ext.CommandHandler`](https://python-telegram-bot.readthedocs.io/en/latest/telegram.ext.commandhandler.html) that maps this user input to a callback named `start_callback`:\n```python\nasync def start_callback(update, context):\n    await update.message.reply_text(\"Welcome to my awesome bot!\")\n\n...\n\napplication.add_handler(CommandHandler(\"start\", start_callback))\n```\n\n## Different types of `Update`s\n\nFor different kinds of user input, the received `telegram.Update` will have different attributes set. For example an incoming message will result in `update.message` containing the sent message. The pressing of an inline button will result in `update.callback_query` being set. To differentiate between all those updates, `telegram.ext` provides\n\n1) [`telegram.ext.MessageHandler`](https://python-telegram-bot.readthedocs.io/telegram.ext.messagehandler.html) for all message updates\n2) [`telegram.ext.CommandHandler`](https://python-telegram-bot.readthedocs.io/telegram.ext.commandhandler.html) for messages with bot commands\n3) multiple handlers for all the other different types of updates, e.g. [`telegram.ext.CallbackQueryhandler`](https://python-telegram-bot.readthedocs.io/telegram.ext.callbackqueryhandler.html) for `update.callback_query` and [`telegram.ext.InlineQueryHandler`](https://python-telegram-bot.readthedocs.io/telegram.ext.inlinequeryhandler.html) for `update.inline_query`\n4) A few more handlers for more advanced use cases\n\nThe special thing about `MessageHandler` is that there is such a vast variety of message types (text, gif, image, document, sticker, …) that it's infeasible to provide a different `Handler` for each type. Instead `MessageHandler` is coupled with so called [filters](https://python-telegram-bot.readthedocs.io/telegram.ext.filters.html) that allow to make fine-grained distinctions: `MessageHandler(filters.ALL, callback)` will handle all updates that contain\n\n* `update.message`\n* `update.edited_message`\n* `update.channel_post`\n* `update.edited_channel_post`\n\nYou can use the different filters to narrow down which updates your `MessageHandler` will handle. See also [[this article|Extensions---Advanced-Filters]] for advanced usage of filters.\n\nBecause bot commands are another special part of the user interface of bots, there is the dedicated `CommandHandler`, which allows you to easily handle messages like `/start` or `/help`. Of course those messages can also be handled with `MessageHandler`, if needed.\n\n## CommandHandlers with arguments\n\nIt is also possible to work with parameters for commands offered by your bot. Let's extend the `start_callback` with some arguments so that the user can provide additional information in the same step:\n\n```python\nasync def start_callback(update, context):\n    user_says = \" \".join(context.args)\n    await update.message.reply_text(\"You said: \" + user_says)\n\n...\n\napplication.add_handler(CommandHandler(\"start\", start_callback))\n```\n\nSending `/start Hello World!` to your bot will now split everything after `/start` separated by the space character into a list of words and pass it on to the [`args` attribute of `context`](https://python-telegram-bot.readthedocs.io/en/latest/telegram.ext.callbackcontext.html#telegram.ext.CallbackContext.args): `[\"Hello\", \"World!\"]`. We join these chunks together by calling `\" \".join(context.args)` and echo the resulting string back to the user.\n\n### Deep-Linking start parameters\nThe argument passing described above works exactly the same when the user clicks on a deeply linked start URL, like this one:\n\n[https://t.me/roolsbot?start=Hello_World!](https://t.me/roolsbot?start=Hello_World!)\n\nClicking this link will open your Telegram Client and show a big START button. When it is pressed, the URL parameters \"Hello_World!\" will be passed on to the `args` of your context object.\n\nNote that since telegram doesn't support spaces in deep linking parameters, you will have to manually split the single `Hello_World` argument, into `[\"Hello\", \"World!\"]` (using `context.args[0].split('_')` for example)\n\nYou also have to pay attention to the maximum length accepted by Telegram itself. As stated in [Telegram API documentation](https://core.telegram.org/bots/features#deep-linking) (and reflected in [PTB documentation](https://python-telegram-bot.readthedocs.io/en/latest/telegram.constants.html#telegram.constants.MessageLimit.DEEP_LINK_LENGTH)), the maximum length for the `start` parameter is `64`.\n\nAlso, since this is an URL parameter, you have to pay attention on how to correctly pass the values in order to avoid passing URL reserved characters. Consider the usage of `base64.urlsafe_b64encode`.\n\n## Pattern matching: `filters.Regex`\n\nFor more complex inputs you can employ the [`telegram.ext.MessageHandler`](https://python-telegram-bot.readthedocs.io/telegram.ext.messagehandler.html) with [`telegram.ext.filters.Regex`](https://python-telegram-bot.readthedocs.io/telegram.ext.filters.html#telegram.ext.filters.Regex), which internally uses the `re`-module to match textual user input with a supplied pattern.\n\nKeep in mind that for extracting URLs, #Hashtags, @Mentions, and other Telegram entities, there's no need to parse them with a regex filter because the Bot API already sends them to us with every update. Refer to [[this snippet|Code-snippets#message-entities]] to learn how to work with entities instead.\n\nThis tutorial only covers some of the available handlers (for now). Refer to [the documentation](https://docs.python-telegram-bot.org/telegram.ext.handlers-tree.html) for all other types.\n\n## Custom updates\n\nIn some cases, it's useful to handle updates that are not from Telegram. E.g. you might want to handle notifications from a 3rd party service and forward them to your users. For such use cases, PTB provides\n\n* [`TypeHandler`](https://python-telegram-bot.readthedocs.io/telegram.ext.typehandler.html)\n* [`StringCommandHandler`](https://python-telegram-bot.readthedocs.io/telegram.ext.stringcommandhandler.html)\n* [`StringRegexHandler`](https://python-telegram-bot.readthedocs.io/telegram.ext.stringregexhandler.html)\n\nSee also this [FAQ entry](https://github.com/python-telegram-bot/python-telegram-bot/wiki/Frequently-Asked-Questions#i-want-to-handle-updates-from-an-external-service-in-addition-to-the-telegram-updates-how-do-i-do-that)\n"
    },
    {
        "name": "Webhooks.md",
        "description": "## Introduction\nOur [examples](https://docs.python-telegram-bot.org/examples.html) usually start the bot using [`Application.run_polling`](https://docs.python-telegram-bot.org/telegram.ext.application.html#telegram.ext.Application.run_polling). This method uses the [getUpdates](https://core.telegram.org/bots/api#getupdates) API method to receive new updates for your bot. This is fine for smaller to medium-sized bots and for testing, but if your bot receives a lot of traffic, it might slow down the response times. There might be other reasons for you to switch to a webhook-based method for update retrieval.\n\n**First things first:** You should have a good reason to switch from polling to a webhook. Don't do it simply because it sounds cool.\n\n## Polling vs. Webhook\nThe general difference between polling and a webhook is: \n\n- Polling (via `get_updates`) periodically connects to Telegram's servers to check for new updates\n- A Webhook is a URL you transmit to Telegram once. Whenever a new update for your bot arrives, Telegram sends that update to the specified URL.\n\nLet's explain this with a metaphor.\nImagine you want to check if you have mail.\n\nWith (long) polling, you have a post office box and need to check yourself if you have new mail.\nSo you rush to the post office and wait in front of your box all day to see if the postman puts something in there - you only go home for small pee breaks.\n\nWith a webhook, you have a mailbox right at your home and the postman delivers the mail right to that mailbox. However, that only works if the postman knows your address (the URL).\n\n## Requirements\n### A public IP address or domain\nUsually this means you have to run your bot on a server, either a dedicated server or a VPS. Read [[Where to host Telegram Bots|Where-to-host-Telegram-Bots]] to find a list of options. \n\nMake sure you can connect to your server from the **public internet**, either by IP or domain name. If `ping` works, you're good to go.\n\n### A SSL certificate\nAll communication with the Telegram servers must be encrypted with HTTPS using SSL. With polling, this is taken care of by the Telegram Servers, but if you want to receive updates via a Webhook, you have to take care of it. Telegram will not send you any updates if you don't.\n\nThere are two ways to do this: \n\n1. A verified certificate issued by a trusted certification authority (CA)\n2. A self-signed certificate\n\nIf you don't already have a verified certificate, use a self-signed one. It's easier and there is no disadvantage to it.\n\n#### Creating a self-signed certificate using OpenSSL\nTo create a self-signed SSL certificate using `openssl`, run the following command:\n```\nopenssl req -newkey rsa:2048 -sha256 -noenc -keyout private.key -x509 -days 3650 -out cert.pem\n```\n\nThe `openssl` utility will ask you for a few details. **Make sure you enter the correct FQDN!** If your server has a domain, enter the full domain name here (eg. `sub.example.com`). If your server only has an IP address, enter that instead. If you enter an invalid FQDN (Fully Qualified Domain Name), you won't receive any updates from Telegram but also won't see any errors!\n\n## Choosing a server model\nThere actually is a third requirement: a HTTP server to listen for webhook connections. At this point, there are several things to consider, depending on your needs. \n\n### The integrated webhook server\nThe `python-telegram-bot` library ships a custom HTTP server that is tightly integrated in the `telegram.ext` module and can be started using [`Updater.start_webhook`](https://docs.python-telegram-bot.org/en/stable/telegram.ext.updater.html#telegram.ext.Updater.start_webhook)/[`Application.run_webhook`](https://docs.python-telegram-bot.org/en/stable/telegram.ext.application.html#telegram.ext.Application.run_webhook). This webserver also takes care of decrypting the HTTPS traffic. It is probably the easiest way to set up a webhook.\n\nHowever, there is a limitation to this solution. Telegram currently only supports four ports for webhooks: *443, 80, 88* and *8443.* As a result, you can only run **a maximum of four bots** on one domain/IP address with the integrated server. \n\nIf that's not a problem for you (yet), you can use the code below (or similar) to start your bot with a webhook. The `listen` address should either be `'0.0.0.0'` or, if you don't have permission for that, the public IP address of your server. The port can be one of `443`, `80`, `88` or `8443`. It is recommended to set a secret token in the `secret_token` parameter, so no one can send fake updates to your bot. `key` and `cert` should contain the path to the files you generated [earlier](#creating-a-self-signed-certificate-using-openssl). The `webhook_url` should be the actual URL of your webhook. Include the `https://` protocol in the beginning, use the domain or IP address you set as the FQDN of your certificate and the correct port and URL path.\n\n```python\napplication.run_webhook(\n    listen='0.0.0.0',\n    port=8443,\n    secret_token='ASecretTokenIHaveChangedByNow',\n    key='private.key',\n    cert='cert.pem',\n    webhook_url='https://example.com:8443'\n)\n```\n\n> Remember to observe [the limitations for the secret token](https://docs.python-telegram-bot.org/en/stable/telegram.bot.html#telegram.Bot.set_webhook.params.secret_token), otherwise Telegram will not accept it.\n>\n> It obviously not such a good idea to store the value of `secret_token` right in your code, so consider creating an environment variable for it.\n\n### Reverse proxy + integrated webhook server\nTo overcome the port limitation, you can use a reverse proxy like *nginx* or *haproxy*.\n\nIn this model, a single server application listening on the public IP, the *reverse proxy*, accepts all webhook requests and forwards them to the correct instance of locally running *integrated webhook servers.* It also performs the *SSL termination*, meaning it decrypts the HTTPS connection, so the webhook servers receive the already decrypted traffic. These servers can run on *any* port, not just the four ports allowed by Telegram, because Telegram only connects to the reverse proxy directly. \n\nDepending on the reverse proxy application you (or your hosting provider) are using, the implementation will look a bit different. In the following, there are a few possible setups listed.\n\n#### Heroku\nOn Heroku using webhook can be beneficial because it will automatically manage the downtime required.\nThe reverse proxy is set up for you and an environment is created. From this environment you will have to extract the port the bot is supposed to listen on. Heroku manages the SSL on the proxy side, so you don't have to provide the certificate yourself.\n\n```python\nimport os\n\nTOKEN = \"TOKEN\"\nPORT = int(os.environ.get('PORT', '8443'))\n# add handlers\napplication.run_webhook(\n    listen=\"0.0.0.0\",\n    port=PORT,\n    secret_token='ASecretTokenIHaveChangedByNow',\n    webhook_url=\"https://<appname>.herokuapp.com/\"\n)\n```\n\n#### Using nginx with one domain/port for all bots\nThis is similar to the Heroku approach, just that you set up the reverse proxy yourself. All bots set their `url` to the same domain and port. To differentiate the bots, add a different `url_path`. The integrated server should usually be started on the `localhost` or `127.0.0.1` address, the port can be any port you choose.\n\n**Note:** `example.com` could be replaced by an IP address if you have no domain associated to your server.\n\nExample code to start the bot:\n```python\napplication.run_webhook(\n    listen='127.0.0.1',\n    port=5000,\n    url_path='1',\n    secret_token='ASecretTokenIHaveChangedByNow',\n    webhook_url='https://example.com/1',\n    cert='cert.pem'\n)\n```\n\nWhen setting up nginx, it is usually a good idea to secure it with an SSL certificate right away (see for example [this tutorial](https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-22-04)). If you've done that, you must not pass your certificate in `cert` parameter (if you do, Telegram will return an error).\n\nExample configuration for `nginx` (reduced to important parts) with two bots configured:\n```\nserver {\n    listen              443 ssl;\n    server_name         example.com;\n    ssl_certificate     cert.pem;\n    ssl_certificate_key private.key;\n\n    location /TOKEN1 {\n        proxy_pass http://127.0.0.1:5000/1/;\n    }\n\n    location /TOKEN2 {\n        proxy_pass http://127.0.0.1:5001/2/;\n    }\n}\n```\n\n> If you try and reproduce the [custom webhook example](https://docs.python-telegram-bot.org/en/stable/examples.customwebhookbot.html) while using nginx as a reverse proxy, make sure you remove trailing slashes from the addresses in `proxy_pass` directive. A trailing slash [may cause status code 307 being emitted by Starlette](https://github.com/encode/starlette/issues/869) that is used in the example.\n\n#### Using haproxy with one subdomain per bot\nIn this approach, each bot is assigned their own *subdomain*. If your server has the domain *example.com*, you could have the subdomains *bot1.example.com*, *bot2.example.com* etc. You will need one certificate for each bot, with the FQDN set for their respective subdomain (or a wildcard certificate). The reverse proxy in this example is `haproxy`. The integrated server should usually be started on the `localhost` or `127.0.0.1` address, the port can be any port you choose.\n\n**Note:** For this to work, you need a domain for your server.\n\nExample code to start the bot:\n```python\napplication.run_webhook(\n    listen='127.0.0.1',\n    port=5000,\n    secret_token='ASecretTokenIHaveChangedByNow',\n    webhook_url='https://bot1.example.com',\n    cert='cert_bot1.pem')\n)\n```\n\nExample configuration for `haproxy` (reduced to important parts) with two bots configured. Again: The FQDN of both certificates must match the value in `ssl_fc_sni`. Also, the `.pem` files are the `private.key` file and `cert.pem` files concatenated:\n```\nfrontend  public-https\n    bind        0.0.0.0:443 ssl crt cert_key_bot1.pem crt cert_key_bot2.pem\n    option      httpclose\n\n    use_backend bot1 if  { ssl_fc_sni bot1.example.com }\n    use_backend bot2 if  { ssl_fc_sni bot2.example.com }\n\nbackend bot1\n    mode            http\n    option          redispatch\n    server          bot1.example.com 127.0.0.1:5000 check inter 1000\n\nbackend bot2\n    mode            http\n    option          redispatch\n    server          bot2.example.com 127.0.0.1:5001 check inter 1000\n```\n\n### Custom solution\nYou don't necessarily have to use the integrated webserver *at all*. If you choose to go this way, **you should not use the `Updater` class.** The `telegram.ext` module was designed with this option in mind, so you can still use the `Application` class to profit from the message filtering/sorting it provides. You will have to do some work by hand, though.\n\nThe general idea is outlined below and also explained in more detail in [this wiki section](https://github.com/python-telegram-bot/python-telegram-bot/wiki/Frequently-requested-design-patterns#running-ptb-alongside-other-asyncio-frameworks).\n\n```python\nfrom telegram import Bot\nfrom telegram.ext import Application\n\napplication = Application.builder().token('TOKEN').build()\n    \n# Register handlers here\n\n# Get the update_queue from which the application fetches the updates to handle\nupdate_queue = application.update_queue\nstart_fetching_updates(update_queue)\n\n# Start and run the application\nasync with application:\n    application.start()\n    # when some shutdown mechanism is triggered:\n    application.stop()\n```\n\nHere, `start_fetching_updates` is a placeholder for whichever method you use to set up a webhook.\nThe important part is that you enqueue the received updates into the `update_queue`.\nThat is, call `await update_queue.put(update)`, where `update` is the decoded `Update` object (use `Update.de_json(json.loads(text), bot)` to decode the update from the received JSON data).\n\nWe have an example using this approach available [here](https://docs.python-telegram-bot.org/examples.html#examples-customwebhookbot).\n\n#### Alternative: No long running tasks\nIf you don't want to use the long running tasks started by `application.start()`, you don't have to!\nInstead of putting the updates into the `update_queue`, you can directly process them via `application.process_update(update)`.\n\n## Checking your webhook\nTo check if the webhook was accepted by Telegram, you can simply open this link in your browser:\n`https://api.telegram.org/bot<your_bot_token>/getWebhookInfo`\n"
    },
    {
        "name": "Where-to-host-Telegram-Bots.md",
        "description": "Look at [[Hosting your bot|Hosting-your-bot]] if you've decided to get a server.\n\n#### ⚠️ Note\n\nThe linked articles/blog posts on how to use PTB with the different providers are\n\n* usually written for a specific (range of) versions of `python-telegram-bot` and may not be compatible with the version that you are using\n* not written or maintained by the PTB dev team.\n\nWhen in doubt, please check the official PTB resources.\n\n### Cloud\n* [Amazon Web Services](https://aws.amazon.com/)\n    * [Running a Python Telegram Bot on AWS Serverless (Lambda) for PTB v13.x](https://github.com/jojo786/Sample-Python-Telegram-Bot-AWS-Serverless)\n    * [Running a Python Telegram Bot on AWS Serverless (Lambda) for PTB v20.x](https://github.com/havebeenfitz/om-random-coffee-bot/wiki/Hosting-the-bot-on-AWS-Lambda)\n* [Microsoft Azure](https://azure.microsoft.com/)\n* [Google App Engine](https://cloud.google.com/appengine) \n    * [[Notes about GAE - Google App Engine]]\n    * **[How to create a Bot on Google App Engine](https://github.com/sooyhwang/Simple-Echo-Telegram-Bot)** by [sooyhwang](https://github.com/sooyhwang) (NOTE: This might be obsolete)\n* [Google Cloud Functions](https://cloud.google.com/functions/) \n    * **[Building a serverless Telegram bot](https://seminar.io/2018/09/03/building-serverless-telegram-bot/)** by [pabluk](https://github.com/pabluk)\n* [Google Cloud Run](https://cloud.google.com/run/) \n    * **[Hosting Telegram bots on Cloud Run for free](https://nullonerror.org/2021/01/08/hosting-telegram-bots-on-google-cloud-run/)** by [skhaz](https://github.com/skhaz/)\n* [Back4App](https://www.back4app.com)\n* [Heroku](https://www.heroku.com/)\n    * **[Heroku getting started with Python](https://devcenter.heroku.com/articles/getting-started-with-python#introduction)**\n    * **[[Webhooks on Heroku|Webhooks#heroku]]**\n    * **[Skeleton repository](https://github.com/Bibo-Joshi/ptb-heroku-skeleton)**\n* [Code Capsules](https://codecapsules.io)\n    * **[Host a Telegram Bot on Code Capsules](https://codecapsules.io/docs/tutorials/create-and-host-telegram-bot/)**\n* [OpenShift](https://www.openshift.com/)\n    * **[How to run a Bot on Openshift v2](https://github.com/lufte/python-telegram-bot-openshift)**\n    * **[How to run a Bot on Openshift v3](https://github.com/Gotham13121997/python-telegram-bot-openshift3)**\n* [Fly.io](https://fly.io/)\n    * **[How to deploy a Telegram bot to Fly.io](https://bakanim.xyz/posts/deploy-telegram-bot-to-fly-io/)** (written for v20.0a2)\n* [Joyent Triton](https://www.joyent.com/triton)\n* [Vercel serverless functions](https://vercel.com/docs/serverless-functions/supported-languages#python)\n* [PythonAnywhere](https://www.pythonanywhere.com)\n* [Oracle Cloud](https://www.oracle.com/cloud/free/) an AlwaysFree feature for a decent instance.\n* [Deta](https://www.deta.sh/)\n    * **[python-telegram-bot template on deta.sh](https://github.com/suriing/telegram-bot-template-on-deta)**\n\n### VPS\n* [DigitalOcean](https://www.digitalocean.com/)\n* [Linode](https://www.linode.com/)\n* [RamNode](https://www.ramnode.com/)\n* [Scaleway](https://www.scaleway.com/)\n* [RunAbove](https://www.runabove.com/)\n* [sabahost](http://sabatemplate.ir/)\n* [Netcup](https://www.netcup.eu/vserver/vps.php)\n* [Hetzner](http://hetzner.cloud/)\n* [Vultr](https://www.vultr.com/)\n\n\n### Low budget\n* [OVH](https://www.ovh.com/us/vps/) \n* [Uberspace](https://uberspace.de/)\n\n### Web IDEs\n* [Codenvy](https://codenvy.com/)\n    * **[How to create a Bot on Codenvy](https://github.com/p92camcj/Tutorial-telegram-bot)** by [p92camcj](https://github.com/p92camcj/Tutorial-telegram-bot)\n* [Koding](https://koding.com/)\n* [Cloud9](https://c9.io/)\n* [Replit](https://replit.com/)\n* [Glitch](https://glitch.com/)\n\n### Tunnels\n* [localtunnel](https://localtunnel.me/)\n* [ngrok](https://ngrok.com/)\n\n### Boards\n* [Banana Pi](http://www.banana-pi.org/)\n* [Raspberry Pi](https://www.raspberrypi.org/)"
    },
    {
        "name": "Working-Behind-a-Proxy.md",
        "description": "PTBs default networking backend `HTTPXRequest` comes with built-in support for proxies.\nNote that the details below only apply to `HTTPXRequest`.\nIf you use a different implementation of `BaseRequest`, you'll have to configure proxies yourself.\n\n# How is a Proxy Server Chosen?\n\nPTB will obtain its proxy configuration in the following order (the first to be found will be used):\n1. Programmatic.\n2. Using `HTTP_PROXY` environment variable.\n3. Using `HTTPS_PROXY` environment variable.\n4. Using `ALL_PROXY` environment variable.\n\n# Setting a HTTP(S) Proxy Server Programmatically\n\nProxies can be setup like this:\n\n```python\nfrom telegram.ext import ApplicationBuilder\n\n# \"USERNAME:PASSWORD@\" is optional, if you need authentication:\nproxy_url = 'http://USERNAME:PASSWORD@PROXY_HOST:PROXY_PORT'  # can also be a https proxy\napp = ApplicationBuilder().token(\"TOKEN\").proxy(proxy_url).get_updates_proxy(proxy_url).build()\n```\n\nIn the last line, we setup the proxy such that it'll be used both for making requests to the Bot API like  `Bot.send_message` ([`proxy()`](https://docs.python-telegram-bot.org/telegram.ext.applicationbuilder.html#telegram.ext.ApplicationBuilder.proxy)) and for fetching updates from Telegram ([`get_updates_proxy`](https://docs.python-telegram-bot.org/telegram.ext.applicationbuilder.html#telegram.ext.ApplicationBuilder.get_updates_proxy)). It is not necessary to setup a proxy for both, you can do it for either of them.\n\n# Working Behind a Socks5 Server\nThis configuration is supported, but requires an optional/extra python package.\nTo install:\n```bash\npip install python-telegram-bot[socks]\n```\n```python\nfrom telegram.ext import ApplicationBuilder\n\nproxy_url = \"socks5://user:pass@host:port\"\n\napp = ApplicationBuilder().token(\"TOKEN\").proxy(proxy_url).get_updates_proxy(proxy_url).build()\n```\n\nIf you're more of an advanced user and would like to customize your proxy setup even further, check out the [docs of httpx](https://www.python-httpx.org/advanced/proxies/) for more info."
    },
    {
        "name": "Working-with-Files-and-Media.md",
        "description": "Bots interacting with users in plain text messages is often times not enough for a pleasant user experience.\nProviding the users with images, videos, files and other media is therefore a common use case for bot programmers and the Bot API provides several ways to do this.\nOn this wiki page, we explain how files and media are handled in the `python-telegram-bot` framework.\n\n- [Sending files](#sending-files)\n  - [Sending a media group](#sending-a-media-group)\n  - [Sending files via inline mode](#sending-files-via-inline-mode)\n- [Editing a file](#editing-a-file)\n- [Downloading a file](#downloading-a-file)\n\n## Sending files\n\nIf you want to send a file (e.g. send a document or a photo) with the bot, you have three options:\n\n* Upload the file\n* Send an HTTP URL that leads to the file\n* Send a `file_id` of a file that has already been sent.\n\nNote that not every method is supported everywhere (e.g. for thumbnails you can't pass a `file_id`). Make sure to check out the documentation of the corresponding bot method for details.\n\nPlease also check out the [official Telegram API docs](https://core.telegram.org/bots/api#sending-files) on sending files.\n\nLet's have a look at how sending a document can be done. In these examples, we'll be using `Bot`'s [`send_document()`](https://python-telegram-bot.readthedocs.io/telegram.bot.html#telegram.Bot.send_document) method.\n\n> [!NOTE]\n> In discussion and examples below, we will be using methods of `Bot`, but most of them\n> (including [`send_document()`](https://python-telegram-bot.readthedocs.io/telegram.bot.html#telegram.Bot.send_document)) \n> have shortcut methods in classes like `User`, `Chat` or `Message` that can be more \n> convenient to use in your particular situation. Documentation for every method in `Bot`\n> contains links to shortcut methods in other classes.\n\n\n1. Uploading a file\n\n    ```python\n    await bot.send_document(chat_id=chat_id, document=open('tests/test.png', 'rb'))\n    ```\n    or even just \n\n    ```python\n    await bot.send_document(chat_id=chat_id, document='tests/test.png')\n    ```\n    When you pass a file path (note that both `str` and [`pathlib.Path`](https://docs.python.org/3/library/pathlib.html#pathlib.Path) are accepted as [`document`](https://python-telegram-bot.readthedocs.io/telegram.bot.html#telegram.Bot.send_document.params.document) parameter), PTB will automatically check if your bot is running in [local mode](https://github.com/python-telegram-bot/python-telegram-bot/wiki/Local-Bot-API-Server#how-to-use-a-local-bot-api-server-with-ptb). If it is, the file does not need to be uploaded. Otherwise, the file is read in binary mode, so just as when you pass `open('tests/test.png', 'rb')`.\n\n2. Sending an HTTP URL\n\n    ```python\n    await bot.send_document(chat_id=chat_id, document='https://python-telegram-bot.org/static/testfiles/telegram.gif')\n    ```\n\n3. Sending by `file_id`:\n\n    ```python\n    await bot.send_document(chat_id=chat_id, document=file_id)\n    ```\n\n    Two further notes on this:\n    \n    1. Each bot has its own `file_id`s, i.e. you can't use a `file_id` from a different bot to send a photo\n    2. How do you get a `file_id` of a photo you sent? Read it from the return value of [`bot.send_document()`](https://python-telegram-bot.readthedocs.io/telegram.bot.html#telegram.Bot.send_document) (or any other [`Message`](https://python-telegram-bot.readthedocs.io/telegram.message.html#telegram.Message) object you get your hands on):\n    \n        ```python\n        message = await bot.send_document(...)\n        file_id = message.document.file_id\n        ```\n       \nThis pretty much works the same way for all the other `send_<media_type>()` methods like [`send_photo()`](https://python-telegram-bot.readthedocs.io/telegram.bot.html#telegram.Bot.send_photo), [`send_video()`](https://python-telegram-bot.readthedocs.io/telegram.bot.html#telegram.Bot.send_video) etc. There is one exception, though: [`send_media_group()`](https://python-telegram-bot.readthedocs.io/telegram.bot.html#telegram.Bot.send_media_group). \n\n### Sending a media group\n\nA call to [`send_media_group()`](https://python-telegram-bot.readthedocs.io/telegram.bot.html#telegram.Bot.send_media_group) looks like this:\n\n```python\nawait bot.send_media_group(chat_id=chat_id, media=[media_1, media_2, ...])\n```\n\nEach of the items in the `media` sequence (list or tuple) must be an instances of [`InputMediaAudio`](https://python-telegram-bot.readthedocs.io/telegram.inputmediaaudio.html#telegram-inputmediaaudio), [`InputMediaDocument`](https://python-telegram-bot.readthedocs.io/telegram.inputmediadocument.html#telegram-inputmediadocument), [`InputMediaPhoto`](https://python-telegram-bot.readthedocs.io/telegram.inputmediaphoto.html#telegram-inputmediaphoto) or [`InputMediaVideo`](https://python-telegram-bot.readthedocs.io/telegram.inputmediavideo.html#telegram-inputmediavideo). The media comes into play like so:\n\n```python\nmedia_1 = InputMediaDocument(media=open('tests/test.png', 'rb'), ...)\nmedia_1 = InputMediaDocument(media='https://python-telegram-bot.org/static/testfiles/telegram.gif', ...)\nmedia_1 = InputMediaDocument(media=file_id, ...)\n```\n\n> [!CAUTION]\n> For the `InputMedia*` classes, passing a file path only works if your bot is running in [local mode](https://docs.python-telegram-bot.org/telegram.bot.html#telegram.Bot.params.local_mode).\n\n### Sending files via inline mode\n\nYou may want to allow users to send media via your bots inline mode. This works a little bit different than posting media via `send_*`. Most notably, you can't upload files for inline mode! You must provide either an HTTP URL or a `file_id`.\n\nLet's stick to example of sending a document. You have to provide [`bot.answer_inline_query()`](https://python-telegram-bot.readthedocs.io/telegram.bot.html#telegram.Bot.answer_inline_query) with an [`InlineQueryResult`](https://python-telegram-bot.readthedocs.io/telegram.inlinequeryresult.html#telegram-inlinequeryresult) that represents that document. There are two ways of doing that:\n\n1. HTTP URL:\n\n    ```python\n    result = InlineQueryResultDocument(document_url='https://python-telegram-bot.org/static/testfiles/telegram.gif', ...)\n    ```\n   \n2. `file_id`:\n\n    ```python\n    result = InlineQueryResultCachedDocument(document_file_id=file_id, ...)\n    ```\n\nIn this example, we are using [`InlineQueryResultDocument`](https://python-telegram-bot.readthedocs.io/telegram.inlinequeryresultdocument.html#telegram-inlinequeryresultdocument) for option #1 and [`InlineQueryResultCachedDocument`](https://python-telegram-bot.readthedocs.io/telegram.inlinequeryresultcacheddocument.html#telegram-inlinequeryresultcacheddocument) for option #2. The scheme `InlineQueryResult<media_type>` vs `InlineQueryResultCached<media_type>` is similar for the other media types.\nAgain, please check out the docs for details on required and optional arguments. \n\n## Editing a file\n\nWhen you have sent a file, you may want to edit it. This works similarly as `send_media_group`, i.e. the media must be wrapped into a `InputMedia<media_type>` object. Again, with `document` as example, we'll call [`bot.edit_message_media()`](https://python-telegram-bot.readthedocs.io/telegram.bot.html#telegram.Bot.edit_message_media) and pass an instance of [`InputMediaDocument`](https://python-telegram-bot.readthedocs.io/telegram.inputmediadocument.html#telegram-inputmediadocument) as `media`:\n\n```python\nawait bot.edit_message_media(chat_id=chat_id, message_id=message_id, media=InputMediaDocument(media=open('tests/test.png'), ...))\n```\n\nPlease check out the restrictions on editing media in the official docs of [`editMessageMedia`](https://core.telegram.org/bots/api#editmessagemedia).\n\n## Downloading a file\n\nWhen you receive files from a user, you sometimes want to download and save them. If it's a document, that could look like this:\n\n```python\nfile_id = message.document.file_id\nnew_file = await bot.get_file(file_id)\nawait new_file.download_to_drive()\n```\n\nFor a received video/voice/... change [`message.document`](https://python-telegram-bot.readthedocs.io/telegram.message.html#telegram.Message.document) to `message.video/voice/...`. However, there is one exception: [`message.photo`](https://python-telegram-bot.readthedocs.io/telegram.message.html#telegram.Message.photo) is a *list* of [`PhotoSize`](https://python-telegram-bot.readthedocs.io/telegram.photosize.html) objects, which represent different sizes of the same photo. Use `message.photo[-1].file_id` to get the largest size.\n\n> **See also:** \n>\n> Documentation for [`Bot.get_file()`](https://python-telegram-bot.readthedocs.io/telegram.bot.html#telegram.Bot.get_file)\n\nMoreover, the above snippet can be shortened by using PTB's built-in utility shortcuts:\n\n```python\nnew_file = await message.effective_attachment.get_file()\nawait new_file.download_to_drive('file_name')\n```\n\n[`message.effective_attachment`](https://python-telegram-bot.readthedocs.io/telegram.message.html#telegram.Message.effective_attachment) automatically contains whichever media attachment the message has. In case of a photo, you'll again have to use e.g. `message.effective_attachment[-1].get_file()`.\n\n> **See also:** \n>\n> Documentation for [`File.download_to_drive()`](https://python-telegram-bot.readthedocs.io/telegram.file.html#telegram.File.download_to_drive) and [`File.download_to_memory()`](https://python-telegram-bot.readthedocs.io/telegram.file.html#telegram.File.download_to_memory)\n\n"
    },
    {
        "name": "Writing-Tests.md",
        "description": "In case you want to practice [test-driven development](https://en.wikipedia.org/wiki/Test-driven_development), or ensure your bot still works after consecutive changes ([regression bugs](https://en.wikipedia.org/wiki/Software_regression) are rather common for chatbots), you should write test cases.\n\n## Unit Tests\nUnit tests are performed on a logically encapsulated component of the system. The definition of unit tests in contrast to integration tests is that they have no external dependencies.\n\nThanks to PTBs modular structure, integration with unit tests can already be achieved for many use cases without additional tooling. For example, you can\n\n* manually enqueue updates in the [`Application.update_queue`](https://docs.python-telegram-bot.org/en/stable/telegram.ext.application.html#telegram.ext.Application.update_queue) or directly call [`Application.process_update`](https://docs.python-telegram-bot.org/en/stable/telegram.ext.application.html#telegram.ext.Application.process_update). This allows you to check that verify that updates are being processed as desiderd without fetching any data from Telegram. Note that for this approach, you'll probably want to set [the updater to `None`](https://docs.python-telegram-bot.org/en/stable/telegram.ext.applicationbuilder.html#telegram.ext.ApplicationBuilder.updater)\n* mock the networking connection to Telegram, i.e. instead of sending the API requests to Telegram you send them to a fictional backend that you control yourself. That way, your tests can not be corrupted by networking issues and do not need an internet connection. This can be achieved e.g. by subclassing the [`Bot`](https://docs.python-telegram-bot.org/en/stable/telegram.bot.html) class and overriding all methods or by implementing a subclass of [`BaseRequest`](https://docs.python-telegram-bot.org/en/stable/telegram.request.baserequest.html).\n\nMoreover, @Eldinnie has written an initial POC of a unit test framework for python-telegram-bot, but as the library grew it was not maintained. Perhaps you might be able to help us out here and help in completing the project ;)\nhttps://github.com/Eldinnie/ptbtest\n\n## Integration Tests\nIn contrast to unit tests, integration tests may test the system in its eventual environment together with service integrations, such as the Bot API.\n\nIn order to test your bot in a real environment, you can make use of a [userbot](http://telegra.ph/How-a-Userbot-superacharges-your-Telegram-Bot-07-09) library that will send messages to your bot and evaluate whether it responds in the way it should. [Telethon](https://github.com/LonamiWebs/Telethon) or [Pyrogram](https://github.com/pyrogram/pyrogram) should be the choices in a Python environment.\nThe currently unmaintained [TgIntegration library](https://github.com/JosXa/tgintegration/) was written for exactly this purpose, so maybe someone could come along with a pull request to update it to the latest version of Pyrogram."
    },
    {
        "name": "_Footer.md",
        "description": "* Wiki of [`python-telegram-bot`](https://python-telegram-bot.org/) © Copyright 2015-2024 – Licensed by [Creative Commons](https://creativecommons.org/licenses/by/3.0/)"
    },
    {
        "name": "_Sidebar.md",
        "description": "## Must read\n\n1. [[Introduction to the API|Introduction-to-the-API]]\n2. [[Tutorial: Your first bot|Extensions---Your-first-Bot]]\n3. [[FAQ|Frequently-Asked-Questions]]\n4. [[How to ask good questions|Ask-Right]]\n5. [[How to write an MWE|MWE]]\n\n## Concepts & Important Elements\n\n1. [[Architecture Overview|Architecture]]\n2. [Builder Pattern for `Application`](Builder-Pattern)\n3. [[Types of Handlers|Types-Of-Handlers]]\n4. [[Working with Files and Media]]\n5. [[Exceptions, Warnings and Logging|Exceptions, Warnings and Logging]]\n6. [[Concurrency in PTB|Concurrency]]\n\n## Notable Features\n\n1. [[Advanced Filters|Extensions---Advanced-Filters]]\n2. [[Storing data|Storing-bot,-user-and-chat-related-data]]\n3. [[Making your bot persistent|Making-your-bot-persistent]]\n4. [[Adding Defaults|Adding-defaults-to-your-bot]]\n5. [[Job Queue|Extensions---JobQueue]]\n6. [Arbitrary `callback_data`](Arbitrary-callback_data)\n7. [[Avoiding flood limits|Avoiding-flood-limits]]\n8. [[Webhooks|Webhooks]]\n9. [[Bot API Forward Compatiblity|Bot-API-Forward-Compatibility]]\n\n## Code Resources\n\n1. [[Frequently requested design patterns|Frequently-requested-design-patterns]]\n2. [[Code snippets|Code-snippets]]\n3. [[Performance Optimizations|Performance-Optimizations]]\n4. [[Telegram Passport|Telegram-Passport]]\n5. [[Bots built with PTB|Bots-built-with-PTB]]\n6. [[Automated Bot Tests|Writing-Tests]]\n\n## Examples explained\n\n1. [[InlineKeyboard Example|InlineKeyboard-Example]]\n\n## Networking\n\n1. [[Working Behind a Proxy|Working-Behind-a-Proxy]]\n2. [[Handling network errors|Handling-network-errors]]\n\n## Other resources\n\n1. [[Where to host Telegram Bots|Where-to-host-Telegram-Bots]]\n2. [[How to host your bot|Hosting-your-bot]]\n3. [[Local API Server|Local-Bot-API-Server]]\n4. [[Type Checking with PTB|Type-Checking]]\n5. [[Press|Press]]\n6. [[Notes on GAE|Notes-about-GAE---Google-App-Engine]]\n7. [[Related Projects|Related-Projects]]\n8. [[Emoji|Emoji]]\n\n## Transition Guides\n\n- [[Version 4|Transition-guide-to-Version-4.0]]\n- [[Version 5|Transition-guide-to-Version-5.0]]\n- [[Version 12|Transition-guide-to-Version-12.0]]\n- [[Version 13|Transition-guide-to-Version-13.0]]\n- [[Version 20|Transition-guide-to-Version-20.0]]\n\n## Administration\n\n- [[Test Bots|Internal-test-bots]]\n- [[How To Release|Releasing-a-new-version]]\n- [[Bots, Groups & Channels|Project-Bots,-Groups-and-Channels]]\n- [[PTB tests knowledge base|PTB-test-writing-knowledge-base]]\n- [[Bot API Backward Compatibility|Bot-API-Backward-Compatibility]]"
    }
]